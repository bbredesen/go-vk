// Code generated by go-vk from vk.xml at 2023-01-14 15:10:03.2770995 -0600 CST m=+1.170543701. DO NOT EDIT.
package vk

import "unsafe"

const (
	keyvkAllocateCommandBuffers vkCommandKey = iota
	keyvkAllocateDescriptorSets
	keyvkAllocateMemory
	keyvkBeginCommandBuffer
	keyvkBindBufferMemory
	keyvkBindBufferMemory2
	keyvkBindImageMemory
	keyvkBindImageMemory2
	keyvkCmdDispatchBase
	keyvkCmdSetDeviceMask
	keyvkCreateBuffer
	keyvkCreateBufferView
	keyvkCreateCommandPool
	keyvkCreateComputePipelines
	keyvkCreateDescriptorPool
	keyvkCreateDescriptorSetLayout
	keyvkCreateDescriptorUpdateTemplate
	keyvkCreateDevice
	keyvkCreateEvent
	keyvkCreateFence
	keyvkCreateFramebuffer
	keyvkCreateGraphicsPipelines
	keyvkCreateImage
	keyvkCreateImageView
	keyvkCreateInstance
	keyvkCreatePipelineCache
	keyvkCreatePipelineLayout
	keyvkCreateQueryPool
	keyvkCreateRenderPass
	keyvkCreateSampler
	keyvkCreateSamplerYcbcrConversion
	keyvkCreateSemaphore
	keyvkCreateShaderModule
	keyvkDestroyBuffer
	keyvkDestroyBufferView
	keyvkDestroyCommandPool
	keyvkDestroyDescriptorPool
	keyvkDestroyDescriptorSetLayout
	keyvkDestroyDescriptorUpdateTemplate
	keyvkDestroyDevice
	keyvkDestroyEvent
	keyvkDestroyFence
	keyvkDestroyFramebuffer
	keyvkDestroyImage
	keyvkDestroyImageView
	keyvkDestroyInstance
	keyvkDestroyPipeline
	keyvkDestroyPipelineCache
	keyvkDestroyPipelineLayout
	keyvkDestroyQueryPool
	keyvkDestroyRenderPass
	keyvkDestroySampler
	keyvkDestroySamplerYcbcrConversion
	keyvkDestroySemaphore
	keyvkDestroyShaderModule
	keyvkDestroySurfaceKHR
	keyvkDeviceWaitIdle
	keyvkEndCommandBuffer
	keyvkEnumerateDeviceExtensionProperties
	keyvkEnumerateDeviceLayerProperties
	keyvkEnumerateInstanceExtensionProperties
	keyvkEnumerateInstanceLayerProperties
	keyvkEnumerateInstanceVersion
	keyvkEnumeratePhysicalDeviceGroups
	keyvkEnumeratePhysicalDevices
	keyvkFlushMappedMemoryRanges
	keyvkFreeCommandBuffers
	keyvkFreeDescriptorSets
	keyvkFreeMemory
	keyvkGetBufferMemoryRequirements
	keyvkGetBufferMemoryRequirements2
	keyvkGetDescriptorSetLayoutSupport
	keyvkGetDeviceGroupPeerMemoryFeatures
	keyvkGetDeviceMemoryCommitment
	keyvkGetDeviceProcAddr
	keyvkGetDeviceQueue
	keyvkGetDeviceQueue2
	keyvkGetEventStatus
	keyvkGetFenceStatus
	keyvkGetImageMemoryRequirements
	keyvkGetImageMemoryRequirements2
	keyvkGetImageSparseMemoryRequirements
	keyvkGetImageSparseMemoryRequirements2
	keyvkGetImageSubresourceLayout
	keyvkGetInstanceProcAddr
	keyvkGetPhysicalDeviceExternalBufferProperties
	keyvkGetPhysicalDeviceExternalFenceProperties
	keyvkGetPhysicalDeviceExternalSemaphoreProperties
	keyvkGetPhysicalDeviceFeatures
	keyvkGetPhysicalDeviceFeatures2
	keyvkGetPhysicalDeviceFormatProperties
	keyvkGetPhysicalDeviceFormatProperties2
	keyvkGetPhysicalDeviceImageFormatProperties
	keyvkGetPhysicalDeviceImageFormatProperties2
	keyvkGetPhysicalDeviceMemoryProperties
	keyvkGetPhysicalDeviceMemoryProperties2
	keyvkGetPhysicalDeviceProperties
	keyvkGetPhysicalDeviceProperties2
	keyvkGetPhysicalDeviceQueueFamilyProperties
	keyvkGetPhysicalDeviceQueueFamilyProperties2
	keyvkGetPhysicalDeviceSparseImageFormatProperties
	keyvkGetPhysicalDeviceSparseImageFormatProperties2
	keyvkGetPhysicalDeviceSurfaceCapabilitiesKHR
	keyvkGetPhysicalDeviceSurfaceFormatsKHR
	keyvkGetPhysicalDeviceSurfacePresentModesKHR
	keyvkGetPhysicalDeviceSurfaceSupportKHR
	keyvkGetPipelineCacheData
	keyvkGetQueryPoolResults
	keyvkGetRenderAreaGranularity
	keyvkInvalidateMappedMemoryRanges
	keyvkMapMemory
	keyvkMergePipelineCaches
	keyvkQueueBindSparse
	keyvkQueueSubmit
	keyvkQueueWaitIdle
	keyvkResetCommandBuffer
	keyvkResetCommandPool
	keyvkResetDescriptorPool
	keyvkResetEvent
	keyvkResetFences
	keyvkSetEvent
	keyvkTrimCommandPool
	keyvkUnmapMemory
	keyvkUpdateDescriptorSetWithTemplate
	keyvkUpdateDescriptorSets
	keyvkWaitForFences
)

func init() {
	lazyCommands[keyvkAllocateCommandBuffers] = vkCommand{"vkAllocateCommandBuffers", 3, true, nil}
	lazyCommands[keyvkAllocateDescriptorSets] = vkCommand{"vkAllocateDescriptorSets", 3, true, nil}
	lazyCommands[keyvkAllocateMemory] = vkCommand{"vkAllocateMemory", 4, true, nil}
	lazyCommands[keyvkBeginCommandBuffer] = vkCommand{"vkBeginCommandBuffer", 2, true, nil}
	lazyCommands[keyvkBindBufferMemory] = vkCommand{"vkBindBufferMemory", 4, true, nil}
	lazyCommands[keyvkBindBufferMemory2] = vkCommand{"vkBindBufferMemory2", 3, true, nil}
	lazyCommands[keyvkBindImageMemory] = vkCommand{"vkBindImageMemory", 4, true, nil}
	lazyCommands[keyvkBindImageMemory2] = vkCommand{"vkBindImageMemory2", 3, true, nil}
	lazyCommands[keyvkCmdDispatchBase] = vkCommand{"vkCmdDispatchBase", 7, true, nil}
	lazyCommands[keyvkCmdSetDeviceMask] = vkCommand{"vkCmdSetDeviceMask", 2, true, nil}
	lazyCommands[keyvkCreateBuffer] = vkCommand{"vkCreateBuffer", 4, true, nil}
	lazyCommands[keyvkCreateBufferView] = vkCommand{"vkCreateBufferView", 4, true, nil}
	lazyCommands[keyvkCreateCommandPool] = vkCommand{"vkCreateCommandPool", 4, true, nil}
	lazyCommands[keyvkCreateComputePipelines] = vkCommand{"vkCreateComputePipelines", 6, true, nil}
	lazyCommands[keyvkCreateDescriptorPool] = vkCommand{"vkCreateDescriptorPool", 4, true, nil}
	lazyCommands[keyvkCreateDescriptorSetLayout] = vkCommand{"vkCreateDescriptorSetLayout", 4, true, nil}
	lazyCommands[keyvkCreateDescriptorUpdateTemplate] = vkCommand{"vkCreateDescriptorUpdateTemplate", 4, true, nil}
	lazyCommands[keyvkCreateDevice] = vkCommand{"vkCreateDevice", 4, true, nil}
	lazyCommands[keyvkCreateEvent] = vkCommand{"vkCreateEvent", 4, true, nil}
	lazyCommands[keyvkCreateFence] = vkCommand{"vkCreateFence", 4, true, nil}
	lazyCommands[keyvkCreateFramebuffer] = vkCommand{"vkCreateFramebuffer", 4, true, nil}
	lazyCommands[keyvkCreateGraphicsPipelines] = vkCommand{"vkCreateGraphicsPipelines", 6, true, nil}
	lazyCommands[keyvkCreateImage] = vkCommand{"vkCreateImage", 4, true, nil}
	lazyCommands[keyvkCreateImageView] = vkCommand{"vkCreateImageView", 4, true, nil}
	lazyCommands[keyvkCreateInstance] = vkCommand{"vkCreateInstance", 3, true, nil}
	lazyCommands[keyvkCreatePipelineCache] = vkCommand{"vkCreatePipelineCache", 4, true, nil}
	lazyCommands[keyvkCreatePipelineLayout] = vkCommand{"vkCreatePipelineLayout", 4, true, nil}
	lazyCommands[keyvkCreateQueryPool] = vkCommand{"vkCreateQueryPool", 4, true, nil}
	lazyCommands[keyvkCreateRenderPass] = vkCommand{"vkCreateRenderPass", 4, true, nil}
	lazyCommands[keyvkCreateSampler] = vkCommand{"vkCreateSampler", 4, true, nil}
	lazyCommands[keyvkCreateSamplerYcbcrConversion] = vkCommand{"vkCreateSamplerYcbcrConversion", 4, true, nil}
	lazyCommands[keyvkCreateSemaphore] = vkCommand{"vkCreateSemaphore", 4, true, nil}
	lazyCommands[keyvkCreateShaderModule] = vkCommand{"vkCreateShaderModule", 4, true, nil}
	lazyCommands[keyvkDestroyBuffer] = vkCommand{"vkDestroyBuffer", 3, true, nil}
	lazyCommands[keyvkDestroyBufferView] = vkCommand{"vkDestroyBufferView", 3, true, nil}
	lazyCommands[keyvkDestroyCommandPool] = vkCommand{"vkDestroyCommandPool", 3, true, nil}
	lazyCommands[keyvkDestroyDescriptorPool] = vkCommand{"vkDestroyDescriptorPool", 3, true, nil}
	lazyCommands[keyvkDestroyDescriptorSetLayout] = vkCommand{"vkDestroyDescriptorSetLayout", 3, true, nil}
	lazyCommands[keyvkDestroyDescriptorUpdateTemplate] = vkCommand{"vkDestroyDescriptorUpdateTemplate", 3, true, nil}
	lazyCommands[keyvkDestroyDevice] = vkCommand{"vkDestroyDevice", 2, true, nil}
	lazyCommands[keyvkDestroyEvent] = vkCommand{"vkDestroyEvent", 3, true, nil}
	lazyCommands[keyvkDestroyFence] = vkCommand{"vkDestroyFence", 3, true, nil}
	lazyCommands[keyvkDestroyFramebuffer] = vkCommand{"vkDestroyFramebuffer", 3, true, nil}
	lazyCommands[keyvkDestroyImage] = vkCommand{"vkDestroyImage", 3, true, nil}
	lazyCommands[keyvkDestroyImageView] = vkCommand{"vkDestroyImageView", 3, true, nil}
	lazyCommands[keyvkDestroyInstance] = vkCommand{"vkDestroyInstance", 2, true, nil}
	lazyCommands[keyvkDestroyPipeline] = vkCommand{"vkDestroyPipeline", 3, true, nil}
	lazyCommands[keyvkDestroyPipelineCache] = vkCommand{"vkDestroyPipelineCache", 3, true, nil}
	lazyCommands[keyvkDestroyPipelineLayout] = vkCommand{"vkDestroyPipelineLayout", 3, true, nil}
	lazyCommands[keyvkDestroyQueryPool] = vkCommand{"vkDestroyQueryPool", 3, true, nil}
	lazyCommands[keyvkDestroyRenderPass] = vkCommand{"vkDestroyRenderPass", 3, true, nil}
	lazyCommands[keyvkDestroySampler] = vkCommand{"vkDestroySampler", 3, true, nil}
	lazyCommands[keyvkDestroySamplerYcbcrConversion] = vkCommand{"vkDestroySamplerYcbcrConversion", 3, true, nil}
	lazyCommands[keyvkDestroySemaphore] = vkCommand{"vkDestroySemaphore", 3, true, nil}
	lazyCommands[keyvkDestroyShaderModule] = vkCommand{"vkDestroyShaderModule", 3, true, nil}
	lazyCommands[keyvkDestroySurfaceKHR] = vkCommand{"vkDestroySurfaceKHR", 3, true, nil}
	lazyCommands[keyvkDeviceWaitIdle] = vkCommand{"vkDeviceWaitIdle", 1, true, nil}
	lazyCommands[keyvkEndCommandBuffer] = vkCommand{"vkEndCommandBuffer", 1, true, nil}
	lazyCommands[keyvkEnumerateDeviceExtensionProperties] = vkCommand{"vkEnumerateDeviceExtensionProperties", 4, true, nil}
	lazyCommands[keyvkEnumerateDeviceLayerProperties] = vkCommand{"vkEnumerateDeviceLayerProperties", 3, true, nil}
	lazyCommands[keyvkEnumerateInstanceExtensionProperties] = vkCommand{"vkEnumerateInstanceExtensionProperties", 3, true, nil}
	lazyCommands[keyvkEnumerateInstanceLayerProperties] = vkCommand{"vkEnumerateInstanceLayerProperties", 2, true, nil}
	lazyCommands[keyvkEnumerateInstanceVersion] = vkCommand{"vkEnumerateInstanceVersion", 1, true, nil}
	lazyCommands[keyvkEnumeratePhysicalDeviceGroups] = vkCommand{"vkEnumeratePhysicalDeviceGroups", 3, true, nil}
	lazyCommands[keyvkEnumeratePhysicalDevices] = vkCommand{"vkEnumeratePhysicalDevices", 3, true, nil}
	lazyCommands[keyvkFlushMappedMemoryRanges] = vkCommand{"vkFlushMappedMemoryRanges", 3, true, nil}
	lazyCommands[keyvkFreeCommandBuffers] = vkCommand{"vkFreeCommandBuffers", 4, true, nil}
	lazyCommands[keyvkFreeDescriptorSets] = vkCommand{"vkFreeDescriptorSets", 4, true, nil}
	lazyCommands[keyvkFreeMemory] = vkCommand{"vkFreeMemory", 3, true, nil}
	lazyCommands[keyvkGetBufferMemoryRequirements] = vkCommand{"vkGetBufferMemoryRequirements", 3, true, nil}
	lazyCommands[keyvkGetBufferMemoryRequirements2] = vkCommand{"vkGetBufferMemoryRequirements2", 3, true, nil}
	lazyCommands[keyvkGetDescriptorSetLayoutSupport] = vkCommand{"vkGetDescriptorSetLayoutSupport", 3, true, nil}
	lazyCommands[keyvkGetDeviceGroupPeerMemoryFeatures] = vkCommand{"vkGetDeviceGroupPeerMemoryFeatures", 5, true, nil}
	lazyCommands[keyvkGetDeviceMemoryCommitment] = vkCommand{"vkGetDeviceMemoryCommitment", 3, true, nil}
	lazyCommands[keyvkGetDeviceProcAddr] = vkCommand{"vkGetDeviceProcAddr", 2, true, nil}
	lazyCommands[keyvkGetDeviceQueue] = vkCommand{"vkGetDeviceQueue", 4, true, nil}
	lazyCommands[keyvkGetDeviceQueue2] = vkCommand{"vkGetDeviceQueue2", 3, true, nil}
	lazyCommands[keyvkGetEventStatus] = vkCommand{"vkGetEventStatus", 2, true, nil}
	lazyCommands[keyvkGetFenceStatus] = vkCommand{"vkGetFenceStatus", 2, true, nil}
	lazyCommands[keyvkGetImageMemoryRequirements] = vkCommand{"vkGetImageMemoryRequirements", 3, true, nil}
	lazyCommands[keyvkGetImageMemoryRequirements2] = vkCommand{"vkGetImageMemoryRequirements2", 3, true, nil}
	lazyCommands[keyvkGetImageSparseMemoryRequirements] = vkCommand{"vkGetImageSparseMemoryRequirements", 4, true, nil}
	lazyCommands[keyvkGetImageSparseMemoryRequirements2] = vkCommand{"vkGetImageSparseMemoryRequirements2", 4, true, nil}
	lazyCommands[keyvkGetImageSubresourceLayout] = vkCommand{"vkGetImageSubresourceLayout", 4, true, nil}
	lazyCommands[keyvkGetInstanceProcAddr] = vkCommand{"vkGetInstanceProcAddr", 2, true, nil}
	lazyCommands[keyvkGetPhysicalDeviceExternalBufferProperties] = vkCommand{"vkGetPhysicalDeviceExternalBufferProperties", 3, true, nil}
	lazyCommands[keyvkGetPhysicalDeviceExternalFenceProperties] = vkCommand{"vkGetPhysicalDeviceExternalFenceProperties", 3, true, nil}
	lazyCommands[keyvkGetPhysicalDeviceExternalSemaphoreProperties] = vkCommand{"vkGetPhysicalDeviceExternalSemaphoreProperties", 3, true, nil}
	lazyCommands[keyvkGetPhysicalDeviceFeatures] = vkCommand{"vkGetPhysicalDeviceFeatures", 2, true, nil}
	lazyCommands[keyvkGetPhysicalDeviceFeatures2] = vkCommand{"vkGetPhysicalDeviceFeatures2", 2, true, nil}
	lazyCommands[keyvkGetPhysicalDeviceFormatProperties] = vkCommand{"vkGetPhysicalDeviceFormatProperties", 3, true, nil}
	lazyCommands[keyvkGetPhysicalDeviceFormatProperties2] = vkCommand{"vkGetPhysicalDeviceFormatProperties2", 3, true, nil}
	lazyCommands[keyvkGetPhysicalDeviceImageFormatProperties] = vkCommand{"vkGetPhysicalDeviceImageFormatProperties", 7, true, nil}
	lazyCommands[keyvkGetPhysicalDeviceImageFormatProperties2] = vkCommand{"vkGetPhysicalDeviceImageFormatProperties2", 3, true, nil}
	lazyCommands[keyvkGetPhysicalDeviceMemoryProperties] = vkCommand{"vkGetPhysicalDeviceMemoryProperties", 2, true, nil}
	lazyCommands[keyvkGetPhysicalDeviceMemoryProperties2] = vkCommand{"vkGetPhysicalDeviceMemoryProperties2", 2, true, nil}
	lazyCommands[keyvkGetPhysicalDeviceProperties] = vkCommand{"vkGetPhysicalDeviceProperties", 2, true, nil}
	lazyCommands[keyvkGetPhysicalDeviceProperties2] = vkCommand{"vkGetPhysicalDeviceProperties2", 2, true, nil}
	lazyCommands[keyvkGetPhysicalDeviceQueueFamilyProperties] = vkCommand{"vkGetPhysicalDeviceQueueFamilyProperties", 3, true, nil}
	lazyCommands[keyvkGetPhysicalDeviceQueueFamilyProperties2] = vkCommand{"vkGetPhysicalDeviceQueueFamilyProperties2", 3, true, nil}
	lazyCommands[keyvkGetPhysicalDeviceSparseImageFormatProperties] = vkCommand{"vkGetPhysicalDeviceSparseImageFormatProperties", 8, true, nil}
	lazyCommands[keyvkGetPhysicalDeviceSparseImageFormatProperties2] = vkCommand{"vkGetPhysicalDeviceSparseImageFormatProperties2", 4, true, nil}
	lazyCommands[keyvkGetPhysicalDeviceSurfaceCapabilitiesKHR] = vkCommand{"vkGetPhysicalDeviceSurfaceCapabilitiesKHR", 3, true, nil}
	lazyCommands[keyvkGetPhysicalDeviceSurfaceFormatsKHR] = vkCommand{"vkGetPhysicalDeviceSurfaceFormatsKHR", 4, true, nil}
	lazyCommands[keyvkGetPhysicalDeviceSurfacePresentModesKHR] = vkCommand{"vkGetPhysicalDeviceSurfacePresentModesKHR", 4, true, nil}
	lazyCommands[keyvkGetPhysicalDeviceSurfaceSupportKHR] = vkCommand{"vkGetPhysicalDeviceSurfaceSupportKHR", 4, true, nil}
	lazyCommands[keyvkGetPipelineCacheData] = vkCommand{"vkGetPipelineCacheData", 4, true, nil}
	lazyCommands[keyvkGetQueryPoolResults] = vkCommand{"vkGetQueryPoolResults", 8, true, nil}
	lazyCommands[keyvkGetRenderAreaGranularity] = vkCommand{"vkGetRenderAreaGranularity", 3, true, nil}
	lazyCommands[keyvkInvalidateMappedMemoryRanges] = vkCommand{"vkInvalidateMappedMemoryRanges", 3, true, nil}
	lazyCommands[keyvkMapMemory] = vkCommand{"vkMapMemory", 6, true, nil}
	lazyCommands[keyvkMergePipelineCaches] = vkCommand{"vkMergePipelineCaches", 4, true, nil}
	lazyCommands[keyvkQueueBindSparse] = vkCommand{"vkQueueBindSparse", 4, true, nil}
	lazyCommands[keyvkQueueSubmit] = vkCommand{"vkQueueSubmit", 4, true, nil}
	lazyCommands[keyvkQueueWaitIdle] = vkCommand{"vkQueueWaitIdle", 1, true, nil}
	lazyCommands[keyvkResetCommandBuffer] = vkCommand{"vkResetCommandBuffer", 2, true, nil}
	lazyCommands[keyvkResetCommandPool] = vkCommand{"vkResetCommandPool", 3, true, nil}
	lazyCommands[keyvkResetDescriptorPool] = vkCommand{"vkResetDescriptorPool", 3, true, nil}
	lazyCommands[keyvkResetEvent] = vkCommand{"vkResetEvent", 2, true, nil}
	lazyCommands[keyvkResetFences] = vkCommand{"vkResetFences", 3, true, nil}
	lazyCommands[keyvkSetEvent] = vkCommand{"vkSetEvent", 2, true, nil}
	lazyCommands[keyvkTrimCommandPool] = vkCommand{"vkTrimCommandPool", 3, true, nil}
	lazyCommands[keyvkUnmapMemory] = vkCommand{"vkUnmapMemory", 2, true, nil}
	lazyCommands[keyvkUpdateDescriptorSetWithTemplate] = vkCommand{"vkUpdateDescriptorSetWithTemplate", 4, true, nil}
	lazyCommands[keyvkUpdateDescriptorSets] = vkCommand{"vkUpdateDescriptorSets", 5, true, nil}
	lazyCommands[keyvkWaitForFences] = vkCommand{"vkWaitForFences", 5, true, nil}
}

// AllocateCommandBuffers: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkAllocateCommandBuffers.html
func AllocateCommandBuffers(device Device, allocateInfo *CommandBufferAllocateInfo) (r Result) {
	// Parameter is a singular input, requires translation - allocateInfo
	pAllocateInfo := unsafe.Pointer(unsafe.Pointer(allocateInfo.Vulkanize()))

	// Parameter is binding-allocated array populated by Vulkan; length is possibly embedded in a struct (pAllocateInfo->commandBufferCount) - commandBuffers

	r = Result(execTrampoline(keyvkAllocateCommandBuffers, uintptr(device), uintptr(pAllocateInfo)))

	return
}

// AllocateDescriptorSets: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkAllocateDescriptorSets.html
func AllocateDescriptorSets(device Device, allocateInfo *DescriptorSetAllocateInfo) (r Result) {
	// Parameter is a singular input, requires translation - allocateInfo
	pAllocateInfo := unsafe.Pointer(unsafe.Pointer(allocateInfo.Vulkanize()))

	// Parameter is binding-allocated array populated by Vulkan; length is possibly embedded in a struct (pAllocateInfo->descriptorSetCount) - descriptorSets

	r = Result(execTrampoline(keyvkAllocateDescriptorSets, uintptr(device), uintptr(pAllocateInfo)))

	return
}

// AllocateMemory: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkAllocateMemory.html
func AllocateMemory(device Device, allocateInfo *MemoryAllocateInfo, allocator *AllocationCallbacks) (r Result, memory DeviceMemory) {
	// Parameter is a singular input, requires translation - allocateInfo
	pAllocateInfo := unsafe.Pointer(unsafe.Pointer(allocateInfo.Vulkanize()))

	// Parameter is a singular input, requires translation - allocator
	pAllocator := unsafe.Pointer(unsafe.Pointer(allocator.Vulkanize()))

	// memory is a binding-allocated single return value and will be populated by Vulkan
	pMemory := unsafe.Pointer(&memory)

	r = Result(execTrampoline(keyvkAllocateMemory, uintptr(device), uintptr(pAllocateInfo), uintptr(pAllocator), uintptr(pMemory)))

	return
}

// BeginCommandBuffer: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkBeginCommandBuffer.html
func BeginCommandBuffer(commandBuffer CommandBuffer, beginInfo *CommandBufferBeginInfo) (r Result) {
	// Parameter is a singular input, requires translation - beginInfo
	pBeginInfo := unsafe.Pointer(unsafe.Pointer(beginInfo.Vulkanize()))

	r = Result(execTrampoline(keyvkBeginCommandBuffer, uintptr(commandBuffer), uintptr(pBeginInfo)))

	return
}

// BindBufferMemory: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkBindBufferMemory.html
func BindBufferMemory(device Device, buffer Buffer, memory DeviceMemory, memoryOffset DeviceSize) (r Result) {

	r = Result(execTrampoline(keyvkBindBufferMemory, uintptr(device), uintptr(buffer), uintptr(memory), uintptr(memoryOffset)))

	return
}

// BindBufferMemory2: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkBindBufferMemory2.html
func BindBufferMemory2(device Device, bindInfos []BindBufferMemoryInfo) (r Result) {
	bindInfoCount := len(bindInfos)
	// bindInfos is an input slice that requires translation to an internal type
	sl_bindInfos := make([]_vkBindBufferMemoryInfo, bindInfoCount)
	for i, v := range bindInfos {
		sl_bindInfos[i] = *(v.Vulkanize())
	}
	pBindInfos := unsafe.Pointer(&sl_bindInfos[0])

	r = Result(execTrampoline(keyvkBindBufferMemory2, uintptr(device), uintptr(bindInfoCount), uintptr(pBindInfos)))

	return
}

// BindImageMemory: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkBindImageMemory.html
func BindImageMemory(device Device, image Image, memory DeviceMemory, memoryOffset DeviceSize) (r Result) {

	r = Result(execTrampoline(keyvkBindImageMemory, uintptr(device), uintptr(image), uintptr(memory), uintptr(memoryOffset)))

	return
}

// BindImageMemory2: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkBindImageMemory2.html
func BindImageMemory2(device Device, bindInfos []BindImageMemoryInfo) (r Result) {
	bindInfoCount := len(bindInfos)
	// bindInfos is an input slice that requires translation to an internal type
	sl_bindInfos := make([]_vkBindImageMemoryInfo, bindInfoCount)
	for i, v := range bindInfos {
		sl_bindInfos[i] = *(v.Vulkanize())
	}
	pBindInfos := unsafe.Pointer(&sl_bindInfos[0])

	r = Result(execTrampoline(keyvkBindImageMemory2, uintptr(device), uintptr(bindInfoCount), uintptr(pBindInfos)))

	return
}

// CmdDispatchBase: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDispatchBase.html
func CmdDispatchBase(commandBuffer CommandBuffer, baseGroupX uint32, baseGroupY uint32, baseGroupZ uint32, groupCountX uint32, groupCountY uint32, groupCountZ uint32) {

	execTrampoline(keyvkCmdDispatchBase, uintptr(commandBuffer), uintptr(baseGroupX), uintptr(baseGroupY), uintptr(baseGroupZ), uintptr(groupCountX), uintptr(groupCountY), uintptr(groupCountZ))

}

// CmdSetDeviceMask: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetDeviceMask.html
func CmdSetDeviceMask(commandBuffer CommandBuffer, deviceMask uint32) {

	execTrampoline(keyvkCmdSetDeviceMask, uintptr(commandBuffer), uintptr(deviceMask))

}

// CreateBuffer: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateBuffer.html
func CreateBuffer(device Device, createInfo *BufferCreateInfo, allocator *AllocationCallbacks) (r Result, buffer Buffer) {
	// Parameter is a singular input, requires translation - createInfo
	pCreateInfo := unsafe.Pointer(unsafe.Pointer(createInfo.Vulkanize()))

	// Parameter is a singular input, requires translation - allocator
	pAllocator := unsafe.Pointer(unsafe.Pointer(allocator.Vulkanize()))

	// buffer is a binding-allocated single return value and will be populated by Vulkan
	pBuffer := unsafe.Pointer(&buffer)

	r = Result(execTrampoline(keyvkCreateBuffer, uintptr(device), uintptr(pCreateInfo), uintptr(pAllocator), uintptr(pBuffer)))

	return
}

// CreateBufferView: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateBufferView.html
func CreateBufferView(device Device, createInfo *BufferViewCreateInfo, allocator *AllocationCallbacks) (r Result, view BufferView) {
	// Parameter is a singular input, requires translation - createInfo
	pCreateInfo := unsafe.Pointer(unsafe.Pointer(createInfo.Vulkanize()))

	// Parameter is a singular input, requires translation - allocator
	pAllocator := unsafe.Pointer(unsafe.Pointer(allocator.Vulkanize()))

	// view is a binding-allocated single return value and will be populated by Vulkan
	pView := unsafe.Pointer(&view)

	r = Result(execTrampoline(keyvkCreateBufferView, uintptr(device), uintptr(pCreateInfo), uintptr(pAllocator), uintptr(pView)))

	return
}

// CreateCommandPool: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateCommandPool.html
func CreateCommandPool(device Device, createInfo *CommandPoolCreateInfo, allocator *AllocationCallbacks) (r Result, commandPool CommandPool) {
	// Parameter is a singular input, requires translation - createInfo
	pCreateInfo := unsafe.Pointer(unsafe.Pointer(createInfo.Vulkanize()))

	// Parameter is a singular input, requires translation - allocator
	pAllocator := unsafe.Pointer(unsafe.Pointer(allocator.Vulkanize()))

	// commandPool is a binding-allocated single return value and will be populated by Vulkan
	pCommandPool := unsafe.Pointer(&commandPool)

	r = Result(execTrampoline(keyvkCreateCommandPool, uintptr(device), uintptr(pCreateInfo), uintptr(pAllocator), uintptr(pCommandPool)))

	return
}

// CreateComputePipelines: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateComputePipelines.html
func CreateComputePipelines(device Device, pipelineCache PipelineCache, createInfos []ComputePipelineCreateInfo, allocator *AllocationCallbacks) (r Result, pipelines []Pipeline) {
	createInfoCount := len(createInfos)
	// createInfos is an input slice that requires translation to an internal type
	sl_createInfos := make([]_vkComputePipelineCreateInfo, createInfoCount)
	for i, v := range createInfos {
		sl_createInfos[i] = *(v.Vulkanize())
	}
	pCreateInfos := unsafe.Pointer(&sl_createInfos[0])

	// Parameter is a singular input, requires translation - allocator
	pAllocator := unsafe.Pointer(unsafe.Pointer(allocator.Vulkanize()))

	// pipelines is an output array that will be allocated by the binding, len is from createInfoCount
	pipelines = make([]Pipeline, createInfoCount)
	pPipelines := unsafe.Pointer(&pipelines[0])

	r = Result(execTrampoline(keyvkCreateComputePipelines, uintptr(device), uintptr(pipelineCache), uintptr(createInfoCount), uintptr(pCreateInfos), uintptr(pAllocator), uintptr(pPipelines)))

	return
}

// CreateDescriptorPool: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateDescriptorPool.html
func CreateDescriptorPool(device Device, createInfo *DescriptorPoolCreateInfo, allocator *AllocationCallbacks) (r Result, descriptorPool DescriptorPool) {
	// Parameter is a singular input, requires translation - createInfo
	pCreateInfo := unsafe.Pointer(unsafe.Pointer(createInfo.Vulkanize()))

	// Parameter is a singular input, requires translation - allocator
	pAllocator := unsafe.Pointer(unsafe.Pointer(allocator.Vulkanize()))

	// descriptorPool is a binding-allocated single return value and will be populated by Vulkan
	pDescriptorPool := unsafe.Pointer(&descriptorPool)

	r = Result(execTrampoline(keyvkCreateDescriptorPool, uintptr(device), uintptr(pCreateInfo), uintptr(pAllocator), uintptr(pDescriptorPool)))

	return
}

// CreateDescriptorSetLayout: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateDescriptorSetLayout.html
func CreateDescriptorSetLayout(device Device, createInfo *DescriptorSetLayoutCreateInfo, allocator *AllocationCallbacks) (r Result, setLayout DescriptorSetLayout) {
	// Parameter is a singular input, requires translation - createInfo
	pCreateInfo := unsafe.Pointer(unsafe.Pointer(createInfo.Vulkanize()))

	// Parameter is a singular input, requires translation - allocator
	pAllocator := unsafe.Pointer(unsafe.Pointer(allocator.Vulkanize()))

	// setLayout is a binding-allocated single return value and will be populated by Vulkan
	pSetLayout := unsafe.Pointer(&setLayout)

	r = Result(execTrampoline(keyvkCreateDescriptorSetLayout, uintptr(device), uintptr(pCreateInfo), uintptr(pAllocator), uintptr(pSetLayout)))

	return
}

// CreateDescriptorUpdateTemplate: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateDescriptorUpdateTemplate.html
func CreateDescriptorUpdateTemplate(device Device, createInfo *DescriptorUpdateTemplateCreateInfo, allocator *AllocationCallbacks) (r Result, descriptorUpdateTemplate DescriptorUpdateTemplate) {
	// Parameter is a singular input, requires translation - createInfo
	pCreateInfo := unsafe.Pointer(unsafe.Pointer(createInfo.Vulkanize()))

	// Parameter is a singular input, requires translation - allocator
	pAllocator := unsafe.Pointer(unsafe.Pointer(allocator.Vulkanize()))

	// descriptorUpdateTemplate is a binding-allocated single return value and will be populated by Vulkan
	pDescriptorUpdateTemplate := unsafe.Pointer(&descriptorUpdateTemplate)

	r = Result(execTrampoline(keyvkCreateDescriptorUpdateTemplate, uintptr(device), uintptr(pCreateInfo), uintptr(pAllocator), uintptr(pDescriptorUpdateTemplate)))

	return
}

// CreateDevice: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateDevice.html
func CreateDevice(physicalDevice PhysicalDevice, createInfo *DeviceCreateInfo, allocator *AllocationCallbacks) (r Result, device Device) {
	// Parameter is a singular input, requires translation - createInfo
	pCreateInfo := unsafe.Pointer(unsafe.Pointer(createInfo.Vulkanize()))

	// Parameter is a singular input, requires translation - allocator
	pAllocator := unsafe.Pointer(unsafe.Pointer(allocator.Vulkanize()))

	// device is a binding-allocated single return value and will be populated by Vulkan
	pDevice := unsafe.Pointer(&device)

	r = Result(execTrampoline(keyvkCreateDevice, uintptr(physicalDevice), uintptr(pCreateInfo), uintptr(pAllocator), uintptr(pDevice)))

	return
}

// CreateEvent: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateEvent.html
func CreateEvent(device Device, createInfo *EventCreateInfo, allocator *AllocationCallbacks) (r Result, event Event) {
	// Parameter is a singular input, requires translation - createInfo
	pCreateInfo := unsafe.Pointer(unsafe.Pointer(createInfo.Vulkanize()))

	// Parameter is a singular input, requires translation - allocator
	pAllocator := unsafe.Pointer(unsafe.Pointer(allocator.Vulkanize()))

	// event is a binding-allocated single return value and will be populated by Vulkan
	pEvent := unsafe.Pointer(&event)

	r = Result(execTrampoline(keyvkCreateEvent, uintptr(device), uintptr(pCreateInfo), uintptr(pAllocator), uintptr(pEvent)))

	return
}

// CreateFence: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateFence.html
func CreateFence(device Device, createInfo *FenceCreateInfo, allocator *AllocationCallbacks) (r Result, fence Fence) {
	// Parameter is a singular input, requires translation - createInfo
	pCreateInfo := unsafe.Pointer(unsafe.Pointer(createInfo.Vulkanize()))

	// Parameter is a singular input, requires translation - allocator
	pAllocator := unsafe.Pointer(unsafe.Pointer(allocator.Vulkanize()))

	// fence is a binding-allocated single return value and will be populated by Vulkan
	pFence := unsafe.Pointer(&fence)

	r = Result(execTrampoline(keyvkCreateFence, uintptr(device), uintptr(pCreateInfo), uintptr(pAllocator), uintptr(pFence)))

	return
}

// CreateFramebuffer: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateFramebuffer.html
func CreateFramebuffer(device Device, createInfo *FramebufferCreateInfo, allocator *AllocationCallbacks) (r Result, framebuffer Framebuffer) {
	// Parameter is a singular input, requires translation - createInfo
	pCreateInfo := unsafe.Pointer(unsafe.Pointer(createInfo.Vulkanize()))

	// Parameter is a singular input, requires translation - allocator
	pAllocator := unsafe.Pointer(unsafe.Pointer(allocator.Vulkanize()))

	// framebuffer is a binding-allocated single return value and will be populated by Vulkan
	pFramebuffer := unsafe.Pointer(&framebuffer)

	r = Result(execTrampoline(keyvkCreateFramebuffer, uintptr(device), uintptr(pCreateInfo), uintptr(pAllocator), uintptr(pFramebuffer)))

	return
}

// CreateGraphicsPipelines: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateGraphicsPipelines.html
func CreateGraphicsPipelines(device Device, pipelineCache PipelineCache, createInfos []GraphicsPipelineCreateInfo, allocator *AllocationCallbacks) (r Result, pipelines []Pipeline) {
	createInfoCount := len(createInfos)
	// createInfos is an input slice that requires translation to an internal type
	sl_createInfos := make([]_vkGraphicsPipelineCreateInfo, createInfoCount)
	for i, v := range createInfos {
		sl_createInfos[i] = *(v.Vulkanize())
	}
	pCreateInfos := unsafe.Pointer(&sl_createInfos[0])

	// Parameter is a singular input, requires translation - allocator
	pAllocator := unsafe.Pointer(unsafe.Pointer(allocator.Vulkanize()))

	// pipelines is an output array that will be allocated by the binding, len is from createInfoCount
	pipelines = make([]Pipeline, createInfoCount)
	pPipelines := unsafe.Pointer(&pipelines[0])

	r = Result(execTrampoline(keyvkCreateGraphicsPipelines, uintptr(device), uintptr(pipelineCache), uintptr(createInfoCount), uintptr(pCreateInfos), uintptr(pAllocator), uintptr(pPipelines)))

	return
}

// CreateImage: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateImage.html
func CreateImage(device Device, createInfo *ImageCreateInfo, allocator *AllocationCallbacks) (r Result, image Image) {
	// Parameter is a singular input, requires translation - createInfo
	pCreateInfo := unsafe.Pointer(unsafe.Pointer(createInfo.Vulkanize()))

	// Parameter is a singular input, requires translation - allocator
	pAllocator := unsafe.Pointer(unsafe.Pointer(allocator.Vulkanize()))

	// image is a binding-allocated single return value and will be populated by Vulkan
	pImage := unsafe.Pointer(&image)

	r = Result(execTrampoline(keyvkCreateImage, uintptr(device), uintptr(pCreateInfo), uintptr(pAllocator), uintptr(pImage)))

	return
}

// CreateImageView: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateImageView.html
func CreateImageView(device Device, createInfo *ImageViewCreateInfo, allocator *AllocationCallbacks) (r Result, view ImageView) {
	// Parameter is a singular input, requires translation - createInfo
	pCreateInfo := unsafe.Pointer(unsafe.Pointer(createInfo.Vulkanize()))

	// Parameter is a singular input, requires translation - allocator
	pAllocator := unsafe.Pointer(unsafe.Pointer(allocator.Vulkanize()))

	// view is a binding-allocated single return value and will be populated by Vulkan
	pView := unsafe.Pointer(&view)

	r = Result(execTrampoline(keyvkCreateImageView, uintptr(device), uintptr(pCreateInfo), uintptr(pAllocator), uintptr(pView)))

	return
}

// CreateInstance: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateInstance.html
func CreateInstance(createInfo *InstanceCreateInfo, allocator *AllocationCallbacks) (r Result, instance Instance) {
	// Parameter is a singular input, requires translation - createInfo
	pCreateInfo := unsafe.Pointer(unsafe.Pointer(createInfo.Vulkanize()))

	// Parameter is a singular input, requires translation - allocator
	pAllocator := unsafe.Pointer(unsafe.Pointer(allocator.Vulkanize()))

	// instance is a binding-allocated single return value and will be populated by Vulkan
	pInstance := unsafe.Pointer(&instance)

	r = Result(execTrampoline(keyvkCreateInstance, uintptr(pCreateInfo), uintptr(pAllocator), uintptr(pInstance)))

	return
}

// CreatePipelineCache: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreatePipelineCache.html
func CreatePipelineCache(device Device, createInfo *PipelineCacheCreateInfo, allocator *AllocationCallbacks) (r Result, pipelineCache PipelineCache) {
	// Parameter is a singular input, requires translation - createInfo
	pCreateInfo := unsafe.Pointer(unsafe.Pointer(createInfo.Vulkanize()))

	// Parameter is a singular input, requires translation - allocator
	pAllocator := unsafe.Pointer(unsafe.Pointer(allocator.Vulkanize()))

	// pipelineCache is a binding-allocated single return value and will be populated by Vulkan
	pPipelineCache := unsafe.Pointer(&pipelineCache)

	r = Result(execTrampoline(keyvkCreatePipelineCache, uintptr(device), uintptr(pCreateInfo), uintptr(pAllocator), uintptr(pPipelineCache)))

	return
}

// CreatePipelineLayout: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreatePipelineLayout.html
func CreatePipelineLayout(device Device, createInfo *PipelineLayoutCreateInfo, allocator *AllocationCallbacks) (r Result, pipelineLayout PipelineLayout) {
	// Parameter is a singular input, requires translation - createInfo
	pCreateInfo := unsafe.Pointer(unsafe.Pointer(createInfo.Vulkanize()))

	// Parameter is a singular input, requires translation - allocator
	pAllocator := unsafe.Pointer(unsafe.Pointer(allocator.Vulkanize()))

	// pipelineLayout is a binding-allocated single return value and will be populated by Vulkan
	pPipelineLayout := unsafe.Pointer(&pipelineLayout)

	r = Result(execTrampoline(keyvkCreatePipelineLayout, uintptr(device), uintptr(pCreateInfo), uintptr(pAllocator), uintptr(pPipelineLayout)))

	return
}

// CreateQueryPool: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateQueryPool.html
func CreateQueryPool(device Device, createInfo *QueryPoolCreateInfo, allocator *AllocationCallbacks) (r Result, queryPool QueryPool) {
	// Parameter is a singular input, requires translation - createInfo
	pCreateInfo := unsafe.Pointer(unsafe.Pointer(createInfo.Vulkanize()))

	// Parameter is a singular input, requires translation - allocator
	pAllocator := unsafe.Pointer(unsafe.Pointer(allocator.Vulkanize()))

	// queryPool is a binding-allocated single return value and will be populated by Vulkan
	pQueryPool := unsafe.Pointer(&queryPool)

	r = Result(execTrampoline(keyvkCreateQueryPool, uintptr(device), uintptr(pCreateInfo), uintptr(pAllocator), uintptr(pQueryPool)))

	return
}

// CreateRenderPass: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateRenderPass.html
func CreateRenderPass(device Device, createInfo *RenderPassCreateInfo, allocator *AllocationCallbacks) (r Result, renderPass RenderPass) {
	// Parameter is a singular input, requires translation - createInfo
	pCreateInfo := unsafe.Pointer(unsafe.Pointer(createInfo.Vulkanize()))

	// Parameter is a singular input, requires translation - allocator
	pAllocator := unsafe.Pointer(unsafe.Pointer(allocator.Vulkanize()))

	// renderPass is a binding-allocated single return value and will be populated by Vulkan
	pRenderPass := unsafe.Pointer(&renderPass)

	r = Result(execTrampoline(keyvkCreateRenderPass, uintptr(device), uintptr(pCreateInfo), uintptr(pAllocator), uintptr(pRenderPass)))

	return
}

// CreateSampler: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateSampler.html
func CreateSampler(device Device, createInfo *SamplerCreateInfo, allocator *AllocationCallbacks) (r Result, sampler Sampler) {
	// Parameter is a singular input, requires translation - createInfo
	pCreateInfo := unsafe.Pointer(unsafe.Pointer(createInfo.Vulkanize()))

	// Parameter is a singular input, requires translation - allocator
	pAllocator := unsafe.Pointer(unsafe.Pointer(allocator.Vulkanize()))

	// sampler is a binding-allocated single return value and will be populated by Vulkan
	pSampler := unsafe.Pointer(&sampler)

	r = Result(execTrampoline(keyvkCreateSampler, uintptr(device), uintptr(pCreateInfo), uintptr(pAllocator), uintptr(pSampler)))

	return
}

// CreateSamplerYcbcrConversion: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateSamplerYcbcrConversion.html
func CreateSamplerYcbcrConversion(device Device, createInfo *SamplerYcbcrConversionCreateInfo, allocator *AllocationCallbacks) (r Result, ycbcrConversion SamplerYcbcrConversion) {
	// Parameter is a singular input, requires translation - createInfo
	pCreateInfo := unsafe.Pointer(unsafe.Pointer(createInfo.Vulkanize()))

	// Parameter is a singular input, requires translation - allocator
	pAllocator := unsafe.Pointer(unsafe.Pointer(allocator.Vulkanize()))

	// ycbcrConversion is a binding-allocated single return value and will be populated by Vulkan
	pYcbcrConversion := unsafe.Pointer(&ycbcrConversion)

	r = Result(execTrampoline(keyvkCreateSamplerYcbcrConversion, uintptr(device), uintptr(pCreateInfo), uintptr(pAllocator), uintptr(pYcbcrConversion)))

	return
}

// CreateSemaphore: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateSemaphore.html
func CreateSemaphore(device Device, createInfo *SemaphoreCreateInfo, allocator *AllocationCallbacks) (r Result, semaphore Semaphore) {
	// Parameter is a singular input, requires translation - createInfo
	pCreateInfo := unsafe.Pointer(unsafe.Pointer(createInfo.Vulkanize()))

	// Parameter is a singular input, requires translation - allocator
	pAllocator := unsafe.Pointer(unsafe.Pointer(allocator.Vulkanize()))

	// semaphore is a binding-allocated single return value and will be populated by Vulkan
	pSemaphore := unsafe.Pointer(&semaphore)

	r = Result(execTrampoline(keyvkCreateSemaphore, uintptr(device), uintptr(pCreateInfo), uintptr(pAllocator), uintptr(pSemaphore)))

	return
}

// CreateShaderModule: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateShaderModule.html
func CreateShaderModule(device Device, createInfo *ShaderModuleCreateInfo, allocator *AllocationCallbacks) (r Result, shaderModule ShaderModule) {
	// Parameter is a singular input, requires translation - createInfo
	pCreateInfo := unsafe.Pointer(unsafe.Pointer(createInfo.Vulkanize()))

	// Parameter is a singular input, requires translation - allocator
	pAllocator := unsafe.Pointer(unsafe.Pointer(allocator.Vulkanize()))

	// shaderModule is a binding-allocated single return value and will be populated by Vulkan
	pShaderModule := unsafe.Pointer(&shaderModule)

	r = Result(execTrampoline(keyvkCreateShaderModule, uintptr(device), uintptr(pCreateInfo), uintptr(pAllocator), uintptr(pShaderModule)))

	return
}

// DestroyBuffer: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyBuffer.html
func DestroyBuffer(device Device, buffer Buffer, allocator *AllocationCallbacks) {
	// Parameter is a singular input, requires translation - allocator
	pAllocator := unsafe.Pointer(unsafe.Pointer(allocator.Vulkanize()))

	execTrampoline(keyvkDestroyBuffer, uintptr(device), uintptr(buffer), uintptr(pAllocator))

}

// DestroyBufferView: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyBufferView.html
func DestroyBufferView(device Device, bufferView BufferView, allocator *AllocationCallbacks) {
	// Parameter is a singular input, requires translation - allocator
	pAllocator := unsafe.Pointer(unsafe.Pointer(allocator.Vulkanize()))

	execTrampoline(keyvkDestroyBufferView, uintptr(device), uintptr(bufferView), uintptr(pAllocator))

}

// DestroyCommandPool: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyCommandPool.html
func DestroyCommandPool(device Device, commandPool CommandPool, allocator *AllocationCallbacks) {
	// Parameter is a singular input, requires translation - allocator
	pAllocator := unsafe.Pointer(unsafe.Pointer(allocator.Vulkanize()))

	execTrampoline(keyvkDestroyCommandPool, uintptr(device), uintptr(commandPool), uintptr(pAllocator))

}

// DestroyDescriptorPool: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyDescriptorPool.html
func DestroyDescriptorPool(device Device, descriptorPool DescriptorPool, allocator *AllocationCallbacks) {
	// Parameter is a singular input, requires translation - allocator
	pAllocator := unsafe.Pointer(unsafe.Pointer(allocator.Vulkanize()))

	execTrampoline(keyvkDestroyDescriptorPool, uintptr(device), uintptr(descriptorPool), uintptr(pAllocator))

}

// DestroyDescriptorSetLayout: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyDescriptorSetLayout.html
func DestroyDescriptorSetLayout(device Device, descriptorSetLayout DescriptorSetLayout, allocator *AllocationCallbacks) {
	// Parameter is a singular input, requires translation - allocator
	pAllocator := unsafe.Pointer(unsafe.Pointer(allocator.Vulkanize()))

	execTrampoline(keyvkDestroyDescriptorSetLayout, uintptr(device), uintptr(descriptorSetLayout), uintptr(pAllocator))

}

// DestroyDescriptorUpdateTemplate: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyDescriptorUpdateTemplate.html
func DestroyDescriptorUpdateTemplate(device Device, descriptorUpdateTemplate DescriptorUpdateTemplate, allocator *AllocationCallbacks) {
	// Parameter is a singular input, requires translation - allocator
	pAllocator := unsafe.Pointer(unsafe.Pointer(allocator.Vulkanize()))

	execTrampoline(keyvkDestroyDescriptorUpdateTemplate, uintptr(device), uintptr(descriptorUpdateTemplate), uintptr(pAllocator))

}

// DestroyDevice: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyDevice.html
func DestroyDevice(device Device, allocator *AllocationCallbacks) {
	// Parameter is a singular input, requires translation - allocator
	pAllocator := unsafe.Pointer(unsafe.Pointer(allocator.Vulkanize()))

	execTrampoline(keyvkDestroyDevice, uintptr(device), uintptr(pAllocator))

}

// DestroyEvent: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyEvent.html
func DestroyEvent(device Device, event Event, allocator *AllocationCallbacks) {
	// Parameter is a singular input, requires translation - allocator
	pAllocator := unsafe.Pointer(unsafe.Pointer(allocator.Vulkanize()))

	execTrampoline(keyvkDestroyEvent, uintptr(device), uintptr(event), uintptr(pAllocator))

}

// DestroyFence: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyFence.html
func DestroyFence(device Device, fence Fence, allocator *AllocationCallbacks) {
	// Parameter is a singular input, requires translation - allocator
	pAllocator := unsafe.Pointer(unsafe.Pointer(allocator.Vulkanize()))

	execTrampoline(keyvkDestroyFence, uintptr(device), uintptr(fence), uintptr(pAllocator))

}

// DestroyFramebuffer: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyFramebuffer.html
func DestroyFramebuffer(device Device, framebuffer Framebuffer, allocator *AllocationCallbacks) {
	// Parameter is a singular input, requires translation - allocator
	pAllocator := unsafe.Pointer(unsafe.Pointer(allocator.Vulkanize()))

	execTrampoline(keyvkDestroyFramebuffer, uintptr(device), uintptr(framebuffer), uintptr(pAllocator))

}

// DestroyImage: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyImage.html
func DestroyImage(device Device, image Image, allocator *AllocationCallbacks) {
	// Parameter is a singular input, requires translation - allocator
	pAllocator := unsafe.Pointer(unsafe.Pointer(allocator.Vulkanize()))

	execTrampoline(keyvkDestroyImage, uintptr(device), uintptr(image), uintptr(pAllocator))

}

// DestroyImageView: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyImageView.html
func DestroyImageView(device Device, imageView ImageView, allocator *AllocationCallbacks) {
	// Parameter is a singular input, requires translation - allocator
	pAllocator := unsafe.Pointer(unsafe.Pointer(allocator.Vulkanize()))

	execTrampoline(keyvkDestroyImageView, uintptr(device), uintptr(imageView), uintptr(pAllocator))

}

// DestroyInstance: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyInstance.html
func DestroyInstance(instance Instance, allocator *AllocationCallbacks) {
	// Parameter is a singular input, requires translation - allocator
	pAllocator := unsafe.Pointer(unsafe.Pointer(allocator.Vulkanize()))

	execTrampoline(keyvkDestroyInstance, uintptr(instance), uintptr(pAllocator))

}

// DestroyPipeline: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyPipeline.html
func DestroyPipeline(device Device, pipeline Pipeline, allocator *AllocationCallbacks) {
	// Parameter is a singular input, requires translation - allocator
	pAllocator := unsafe.Pointer(unsafe.Pointer(allocator.Vulkanize()))

	execTrampoline(keyvkDestroyPipeline, uintptr(device), uintptr(pipeline), uintptr(pAllocator))

}

// DestroyPipelineCache: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyPipelineCache.html
func DestroyPipelineCache(device Device, pipelineCache PipelineCache, allocator *AllocationCallbacks) {
	// Parameter is a singular input, requires translation - allocator
	pAllocator := unsafe.Pointer(unsafe.Pointer(allocator.Vulkanize()))

	execTrampoline(keyvkDestroyPipelineCache, uintptr(device), uintptr(pipelineCache), uintptr(pAllocator))

}

// DestroyPipelineLayout: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyPipelineLayout.html
func DestroyPipelineLayout(device Device, pipelineLayout PipelineLayout, allocator *AllocationCallbacks) {
	// Parameter is a singular input, requires translation - allocator
	pAllocator := unsafe.Pointer(unsafe.Pointer(allocator.Vulkanize()))

	execTrampoline(keyvkDestroyPipelineLayout, uintptr(device), uintptr(pipelineLayout), uintptr(pAllocator))

}

// DestroyQueryPool: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyQueryPool.html
func DestroyQueryPool(device Device, queryPool QueryPool, allocator *AllocationCallbacks) {
	// Parameter is a singular input, requires translation - allocator
	pAllocator := unsafe.Pointer(unsafe.Pointer(allocator.Vulkanize()))

	execTrampoline(keyvkDestroyQueryPool, uintptr(device), uintptr(queryPool), uintptr(pAllocator))

}

// DestroyRenderPass: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyRenderPass.html
func DestroyRenderPass(device Device, renderPass RenderPass, allocator *AllocationCallbacks) {
	// Parameter is a singular input, requires translation - allocator
	pAllocator := unsafe.Pointer(unsafe.Pointer(allocator.Vulkanize()))

	execTrampoline(keyvkDestroyRenderPass, uintptr(device), uintptr(renderPass), uintptr(pAllocator))

}

// DestroySampler: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroySampler.html
func DestroySampler(device Device, sampler Sampler, allocator *AllocationCallbacks) {
	// Parameter is a singular input, requires translation - allocator
	pAllocator := unsafe.Pointer(unsafe.Pointer(allocator.Vulkanize()))

	execTrampoline(keyvkDestroySampler, uintptr(device), uintptr(sampler), uintptr(pAllocator))

}

// DestroySamplerYcbcrConversion: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroySamplerYcbcrConversion.html
func DestroySamplerYcbcrConversion(device Device, ycbcrConversion SamplerYcbcrConversion, allocator *AllocationCallbacks) {
	// Parameter is a singular input, requires translation - allocator
	pAllocator := unsafe.Pointer(unsafe.Pointer(allocator.Vulkanize()))

	execTrampoline(keyvkDestroySamplerYcbcrConversion, uintptr(device), uintptr(ycbcrConversion), uintptr(pAllocator))

}

// DestroySemaphore: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroySemaphore.html
func DestroySemaphore(device Device, semaphore Semaphore, allocator *AllocationCallbacks) {
	// Parameter is a singular input, requires translation - allocator
	pAllocator := unsafe.Pointer(unsafe.Pointer(allocator.Vulkanize()))

	execTrampoline(keyvkDestroySemaphore, uintptr(device), uintptr(semaphore), uintptr(pAllocator))

}

// DestroyShaderModule: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyShaderModule.html
func DestroyShaderModule(device Device, shaderModule ShaderModule, allocator *AllocationCallbacks) {
	// Parameter is a singular input, requires translation - allocator
	pAllocator := unsafe.Pointer(unsafe.Pointer(allocator.Vulkanize()))

	execTrampoline(keyvkDestroyShaderModule, uintptr(device), uintptr(shaderModule), uintptr(pAllocator))

}

// DestroySurfaceKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroySurfaceKHR.html
func DestroySurfaceKHR(instance Instance, surface SurfaceKHR, allocator *AllocationCallbacks) {
	// Parameter is a singular input, requires translation - allocator
	pAllocator := unsafe.Pointer(unsafe.Pointer(allocator.Vulkanize()))

	execTrampoline(keyvkDestroySurfaceKHR, uintptr(instance), uintptr(surface), uintptr(pAllocator))

}

// DeviceWaitIdle: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDeviceWaitIdle.html
func DeviceWaitIdle(device Device) (r Result) {

	r = Result(execTrampoline(keyvkDeviceWaitIdle, uintptr(device)))

	return
}

// EndCommandBuffer: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkEndCommandBuffer.html
func EndCommandBuffer(commandBuffer CommandBuffer) (r Result) {

	r = Result(execTrampoline(keyvkEndCommandBuffer, uintptr(commandBuffer)))

	return
}

// EnumerateDeviceExtensionProperties: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkEnumerateDeviceExtensionProperties.html
func EnumerateDeviceExtensionProperties(physicalDevice PhysicalDevice, layerName string) (r Result, properties []ExtensionProperties) {
	// Parameter is a singular input, requires translation - layerName
	pLayerName := unsafe.Pointer(sys_stringToBytePointer(layerName))

	// properties is a double-call array output
	var propertyCount uint32
	pPropertyCount := unsafe.Pointer(&propertyCount)
	var pProperties unsafe.Pointer
	// first trampoline happens here; also, check returned Result value

	r = Result(execTrampoline(keyvkEnumerateDeviceExtensionProperties, uintptr(physicalDevice), uintptr(pLayerName), uintptr(pPropertyCount), uintptr(pProperties)))

	properties = make([]ExtensionProperties, propertyCount)
	pProperties = unsafe.Pointer(&properties[0])

	r = Result(execTrampoline(keyvkEnumerateDeviceExtensionProperties, uintptr(physicalDevice), uintptr(pLayerName), uintptr(pPropertyCount), uintptr(pProperties)))

	return
}

// EnumerateDeviceLayerProperties: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkEnumerateDeviceLayerProperties.html
func EnumerateDeviceLayerProperties(physicalDevice PhysicalDevice) (r Result, properties []LayerProperties) {
	// properties is a double-call array output
	var propertyCount uint32
	pPropertyCount := unsafe.Pointer(&propertyCount)
	var pProperties unsafe.Pointer
	// first trampoline happens here; also, check returned Result value

	r = Result(execTrampoline(keyvkEnumerateDeviceLayerProperties, uintptr(physicalDevice), uintptr(pPropertyCount), uintptr(pProperties)))

	properties = make([]LayerProperties, propertyCount)
	pProperties = unsafe.Pointer(&properties[0])

	r = Result(execTrampoline(keyvkEnumerateDeviceLayerProperties, uintptr(physicalDevice), uintptr(pPropertyCount), uintptr(pProperties)))

	return
}

// EnumerateInstanceExtensionProperties: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkEnumerateInstanceExtensionProperties.html
func EnumerateInstanceExtensionProperties(layerName string) (r Result, properties []ExtensionProperties) {
	// Parameter is a singular input, requires translation - layerName
	pLayerName := unsafe.Pointer(sys_stringToBytePointer(layerName))

	// properties is a double-call array output
	var propertyCount uint32
	pPropertyCount := unsafe.Pointer(&propertyCount)
	var pProperties unsafe.Pointer
	// first trampoline happens here; also, check returned Result value

	r = Result(execTrampoline(keyvkEnumerateInstanceExtensionProperties, uintptr(pLayerName), uintptr(pPropertyCount), uintptr(pProperties)))

	properties = make([]ExtensionProperties, propertyCount)
	pProperties = unsafe.Pointer(&properties[0])

	r = Result(execTrampoline(keyvkEnumerateInstanceExtensionProperties, uintptr(pLayerName), uintptr(pPropertyCount), uintptr(pProperties)))

	return
}

// EnumerateInstanceLayerProperties: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkEnumerateInstanceLayerProperties.html
func EnumerateInstanceLayerProperties() (r Result, properties []LayerProperties) {
	// properties is a double-call array output
	var propertyCount uint32
	pPropertyCount := unsafe.Pointer(&propertyCount)
	var pProperties unsafe.Pointer
	// first trampoline happens here; also, check returned Result value

	r = Result(execTrampoline(keyvkEnumerateInstanceLayerProperties, uintptr(pPropertyCount), uintptr(pProperties)))

	properties = make([]LayerProperties, propertyCount)
	pProperties = unsafe.Pointer(&properties[0])

	r = Result(execTrampoline(keyvkEnumerateInstanceLayerProperties, uintptr(pPropertyCount), uintptr(pProperties)))

	return
}

// EnumerateInstanceVersion: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkEnumerateInstanceVersion.html
func EnumerateInstanceVersion() (r Result, apiVersion uint32) {
	// apiVersion is a binding-allocated single return value and will be populated by Vulkan
	pApiVersion := unsafe.Pointer(&apiVersion)

	r = Result(execTrampoline(keyvkEnumerateInstanceVersion, uintptr(pApiVersion)))

	return
}

// EnumeratePhysicalDeviceGroups: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkEnumeratePhysicalDeviceGroups.html
func EnumeratePhysicalDeviceGroups(instance Instance) (r Result, physicalDeviceGroupProperties []PhysicalDeviceGroupProperties) {
	// physicalDeviceGroupProperties is a double-call array output
	var physicalDeviceGroupCount uint32
	pPhysicalDeviceGroupCount := unsafe.Pointer(&physicalDeviceGroupCount)
	var pPhysicalDeviceGroupProperties unsafe.Pointer
	// first trampoline happens here; also, check returned Result value

	r = Result(execTrampoline(keyvkEnumeratePhysicalDeviceGroups, uintptr(instance), uintptr(pPhysicalDeviceGroupCount), uintptr(pPhysicalDeviceGroupProperties)))

	physicalDeviceGroupProperties = make([]PhysicalDeviceGroupProperties, physicalDeviceGroupCount)
	pPhysicalDeviceGroupProperties = unsafe.Pointer(&physicalDeviceGroupProperties[0])

	r = Result(execTrampoline(keyvkEnumeratePhysicalDeviceGroups, uintptr(instance), uintptr(pPhysicalDeviceGroupCount), uintptr(pPhysicalDeviceGroupProperties)))

	return
}

// EnumeratePhysicalDevices: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkEnumeratePhysicalDevices.html
func EnumeratePhysicalDevices(instance Instance) (r Result, physicalDevices []PhysicalDevice) {
	// physicalDevices is a double-call array output
	var physicalDeviceCount uint32
	pPhysicalDeviceCount := unsafe.Pointer(&physicalDeviceCount)
	var pPhysicalDevices unsafe.Pointer
	// first trampoline happens here; also, check returned Result value

	r = Result(execTrampoline(keyvkEnumeratePhysicalDevices, uintptr(instance), uintptr(pPhysicalDeviceCount), uintptr(pPhysicalDevices)))

	physicalDevices = make([]PhysicalDevice, physicalDeviceCount)
	pPhysicalDevices = unsafe.Pointer(&physicalDevices[0])

	r = Result(execTrampoline(keyvkEnumeratePhysicalDevices, uintptr(instance), uintptr(pPhysicalDeviceCount), uintptr(pPhysicalDevices)))

	return
}

// FlushMappedMemoryRanges: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkFlushMappedMemoryRanges.html
func FlushMappedMemoryRanges(device Device, memoryRanges []MappedMemoryRange) (r Result) {
	memoryRangeCount := len(memoryRanges)
	// memoryRanges is an input slice that requires translation to an internal type
	sl_memoryRanges := make([]_vkMappedMemoryRange, memoryRangeCount)
	for i, v := range memoryRanges {
		sl_memoryRanges[i] = *(v.Vulkanize())
	}
	pMemoryRanges := unsafe.Pointer(&sl_memoryRanges[0])

	r = Result(execTrampoline(keyvkFlushMappedMemoryRanges, uintptr(device), uintptr(memoryRangeCount), uintptr(pMemoryRanges)))

	return
}

// FreeCommandBuffers: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkFreeCommandBuffers.html
func FreeCommandBuffers(device Device, commandPool CommandPool, commandBuffers []CommandBuffer) {
	commandBufferCount := len(commandBuffers)
	// commandBuffers is an input slice of values that do not need translation used
	pCommandBuffers := unsafe.Pointer(&commandBuffers[0])

	execTrampoline(keyvkFreeCommandBuffers, uintptr(device), uintptr(commandPool), uintptr(commandBufferCount), uintptr(pCommandBuffers))

}

// FreeDescriptorSets: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkFreeDescriptorSets.html
func FreeDescriptorSets(device Device, descriptorPool DescriptorPool, descriptorSets []DescriptorSet) (r Result) {
	descriptorSetCount := len(descriptorSets)
	// descriptorSets is an input slice of values that do not need translation used
	pDescriptorSets := unsafe.Pointer(&descriptorSets[0])

	r = Result(execTrampoline(keyvkFreeDescriptorSets, uintptr(device), uintptr(descriptorPool), uintptr(descriptorSetCount), uintptr(pDescriptorSets)))

	return
}

// FreeMemory: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkFreeMemory.html
func FreeMemory(device Device, memory DeviceMemory, allocator *AllocationCallbacks) {
	// Parameter is a singular input, requires translation - allocator
	pAllocator := unsafe.Pointer(unsafe.Pointer(allocator.Vulkanize()))

	execTrampoline(keyvkFreeMemory, uintptr(device), uintptr(memory), uintptr(pAllocator))

}

// GetBufferMemoryRequirements: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetBufferMemoryRequirements.html
func GetBufferMemoryRequirements(device Device, buffer Buffer) (memoryRequirements MemoryRequirements) {
	// memoryRequirements is a binding-allocated single return value and will be populated by Vulkan
	pMemoryRequirements := unsafe.Pointer(&memoryRequirements)

	execTrampoline(keyvkGetBufferMemoryRequirements, uintptr(device), uintptr(buffer), uintptr(pMemoryRequirements))

	return
}

// GetBufferMemoryRequirements2: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetBufferMemoryRequirements2.html
func GetBufferMemoryRequirements2(device Device, info *BufferMemoryRequirementsInfo2) (memoryRequirements MemoryRequirements2) {
	// Parameter is a singular input, requires translation - info
	pInfo := unsafe.Pointer(unsafe.Pointer(info.Vulkanize()))

	// memoryRequirements is a binding-allocated single return value and will be populated by Vulkan
	pMemoryRequirements := unsafe.Pointer(&memoryRequirements)

	execTrampoline(keyvkGetBufferMemoryRequirements2, uintptr(device), uintptr(pInfo), uintptr(pMemoryRequirements))

	return
}

// GetDescriptorSetLayoutSupport: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDescriptorSetLayoutSupport.html
func GetDescriptorSetLayoutSupport(device Device, createInfo *DescriptorSetLayoutCreateInfo) (support DescriptorSetLayoutSupport) {
	// Parameter is a singular input, requires translation - createInfo
	pCreateInfo := unsafe.Pointer(unsafe.Pointer(createInfo.Vulkanize()))

	// support is a binding-allocated single return value and will be populated by Vulkan
	pSupport := unsafe.Pointer(&support)

	execTrampoline(keyvkGetDescriptorSetLayoutSupport, uintptr(device), uintptr(pCreateInfo), uintptr(pSupport))

	return
}

// GetDeviceGroupPeerMemoryFeatures: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeviceGroupPeerMemoryFeatures.html
func GetDeviceGroupPeerMemoryFeatures(device Device, heapIndex uint32, localDeviceIndex uint32, remoteDeviceIndex uint32) (peerMemoryFeatures PeerMemoryFeatureFlags) {
	// peerMemoryFeatures is a binding-allocated single return value and will be populated by Vulkan
	pPeerMemoryFeatures := unsafe.Pointer(&peerMemoryFeatures)

	execTrampoline(keyvkGetDeviceGroupPeerMemoryFeatures, uintptr(device), uintptr(heapIndex), uintptr(localDeviceIndex), uintptr(remoteDeviceIndex), uintptr(pPeerMemoryFeatures))

	return
}

// GetDeviceMemoryCommitment: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeviceMemoryCommitment.html
func GetDeviceMemoryCommitment(device Device, memory DeviceMemory) (committedMemoryInBytes DeviceSize) {
	// committedMemoryInBytes is a binding-allocated single return value and will be populated by Vulkan
	pCommittedMemoryInBytes := unsafe.Pointer(&committedMemoryInBytes)

	execTrampoline(keyvkGetDeviceMemoryCommitment, uintptr(device), uintptr(memory), uintptr(pCommittedMemoryInBytes))

	return
}

// GetDeviceProcAddr: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeviceProcAddr.html
func GetDeviceProcAddr(device Device, name string) (fn PFN_vkVoidFunction) {
	// Parameter is a singular input, requires translation - name
	pName := unsafe.Pointer(sys_stringToBytePointer(name))

	fn = PFN_vkVoidFunction(execTrampoline(keyvkGetDeviceProcAddr, uintptr(device), uintptr(pName)))

	return
}

// GetDeviceQueue: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeviceQueue.html
func GetDeviceQueue(device Device, queueFamilyIndex uint32, queueIndex uint32) (queue Queue) {
	// queue is a binding-allocated single return value and will be populated by Vulkan
	pQueue := unsafe.Pointer(&queue)

	execTrampoline(keyvkGetDeviceQueue, uintptr(device), uintptr(queueFamilyIndex), uintptr(queueIndex), uintptr(pQueue))

	return
}

// GetDeviceQueue2: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeviceQueue2.html
func GetDeviceQueue2(device Device, queueInfo *DeviceQueueInfo2) (queue Queue) {
	// Parameter is a singular input, requires translation - queueInfo
	pQueueInfo := unsafe.Pointer(unsafe.Pointer(queueInfo.Vulkanize()))

	// queue is a binding-allocated single return value and will be populated by Vulkan
	pQueue := unsafe.Pointer(&queue)

	execTrampoline(keyvkGetDeviceQueue2, uintptr(device), uintptr(pQueueInfo), uintptr(pQueue))

	return
}

// GetEventStatus: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetEventStatus.html
func GetEventStatus(device Device, event Event) (r Result) {

	r = Result(execTrampoline(keyvkGetEventStatus, uintptr(device), uintptr(event)))

	return
}

// GetFenceStatus: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetFenceStatus.html
func GetFenceStatus(device Device, fence Fence) (r Result) {

	r = Result(execTrampoline(keyvkGetFenceStatus, uintptr(device), uintptr(fence)))

	return
}

// GetImageMemoryRequirements: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetImageMemoryRequirements.html
func GetImageMemoryRequirements(device Device, image Image) (memoryRequirements MemoryRequirements) {
	// memoryRequirements is a binding-allocated single return value and will be populated by Vulkan
	pMemoryRequirements := unsafe.Pointer(&memoryRequirements)

	execTrampoline(keyvkGetImageMemoryRequirements, uintptr(device), uintptr(image), uintptr(pMemoryRequirements))

	return
}

// GetImageMemoryRequirements2: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetImageMemoryRequirements2.html
func GetImageMemoryRequirements2(device Device, info *ImageMemoryRequirementsInfo2) (memoryRequirements MemoryRequirements2) {
	// Parameter is a singular input, requires translation - info
	pInfo := unsafe.Pointer(unsafe.Pointer(info.Vulkanize()))

	// memoryRequirements is a binding-allocated single return value and will be populated by Vulkan
	pMemoryRequirements := unsafe.Pointer(&memoryRequirements)

	execTrampoline(keyvkGetImageMemoryRequirements2, uintptr(device), uintptr(pInfo), uintptr(pMemoryRequirements))

	return
}

// GetImageSparseMemoryRequirements: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetImageSparseMemoryRequirements.html
func GetImageSparseMemoryRequirements(device Device, image Image) (sparseMemoryRequirements []SparseImageMemoryRequirements) {
	// sparseMemoryRequirements is a double-call array output
	var sparseMemoryRequirementCount uint32
	pSparseMemoryRequirementCount := unsafe.Pointer(&sparseMemoryRequirementCount)
	var pSparseMemoryRequirements unsafe.Pointer
	// first trampoline happens here; also, check returned Result value

	execTrampoline(keyvkGetImageSparseMemoryRequirements, uintptr(device), uintptr(image), uintptr(pSparseMemoryRequirementCount), uintptr(pSparseMemoryRequirements))

	sparseMemoryRequirements = make([]SparseImageMemoryRequirements, sparseMemoryRequirementCount)
	pSparseMemoryRequirements = unsafe.Pointer(&sparseMemoryRequirements[0])

	execTrampoline(keyvkGetImageSparseMemoryRequirements, uintptr(device), uintptr(image), uintptr(pSparseMemoryRequirementCount), uintptr(pSparseMemoryRequirements))

	return
}

// GetImageSparseMemoryRequirements2: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetImageSparseMemoryRequirements2.html
func GetImageSparseMemoryRequirements2(device Device, info *ImageSparseMemoryRequirementsInfo2) (sparseMemoryRequirements []SparseImageMemoryRequirements2) {
	// Parameter is a singular input, requires translation - info
	pInfo := unsafe.Pointer(unsafe.Pointer(info.Vulkanize()))

	// sparseMemoryRequirements is a double-call array output
	var sparseMemoryRequirementCount uint32
	pSparseMemoryRequirementCount := unsafe.Pointer(&sparseMemoryRequirementCount)
	var pSparseMemoryRequirements unsafe.Pointer
	// first trampoline happens here; also, check returned Result value

	execTrampoline(keyvkGetImageSparseMemoryRequirements2, uintptr(device), uintptr(pInfo), uintptr(pSparseMemoryRequirementCount), uintptr(pSparseMemoryRequirements))

	sparseMemoryRequirements = make([]SparseImageMemoryRequirements2, sparseMemoryRequirementCount)
	pSparseMemoryRequirements = unsafe.Pointer(&sparseMemoryRequirements[0])

	execTrampoline(keyvkGetImageSparseMemoryRequirements2, uintptr(device), uintptr(pInfo), uintptr(pSparseMemoryRequirementCount), uintptr(pSparseMemoryRequirements))

	return
}

// GetImageSubresourceLayout: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetImageSubresourceLayout.html
func GetImageSubresourceLayout(device Device, image Image, subresource *ImageSubresource) (layout SubresourceLayout) {
	// Parameter is a singular input, pass direct - subresource
	pSubresource := unsafe.Pointer(subresource)

	// layout is a binding-allocated single return value and will be populated by Vulkan
	pLayout := unsafe.Pointer(&layout)

	execTrampoline(keyvkGetImageSubresourceLayout, uintptr(device), uintptr(image), uintptr(pSubresource), uintptr(pLayout))

	return
}

// GetInstanceProcAddr: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetInstanceProcAddr.html
func GetInstanceProcAddr(instance Instance, name string) (fn PFN_vkVoidFunction) {
	// Parameter is a singular input, requires translation - name
	pName := unsafe.Pointer(sys_stringToBytePointer(name))

	fn = PFN_vkVoidFunction(execTrampoline(keyvkGetInstanceProcAddr, uintptr(instance), uintptr(pName)))

	return
}

// GetPhysicalDeviceExternalBufferProperties: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceExternalBufferProperties.html
func GetPhysicalDeviceExternalBufferProperties(physicalDevice PhysicalDevice, externalBufferInfo *PhysicalDeviceExternalBufferInfo) (externalBufferProperties ExternalBufferProperties) {
	// Parameter is a singular input, requires translation - externalBufferInfo
	pExternalBufferInfo := unsafe.Pointer(unsafe.Pointer(externalBufferInfo.Vulkanize()))

	// externalBufferProperties is a binding-allocated single return value and will be populated by Vulkan
	pExternalBufferProperties := unsafe.Pointer(&externalBufferProperties)

	execTrampoline(keyvkGetPhysicalDeviceExternalBufferProperties, uintptr(physicalDevice), uintptr(pExternalBufferInfo), uintptr(pExternalBufferProperties))

	return
}

// GetPhysicalDeviceExternalFenceProperties: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceExternalFenceProperties.html
func GetPhysicalDeviceExternalFenceProperties(physicalDevice PhysicalDevice, externalFenceInfo *PhysicalDeviceExternalFenceInfo) (externalFenceProperties ExternalFenceProperties) {
	// Parameter is a singular input, requires translation - externalFenceInfo
	pExternalFenceInfo := unsafe.Pointer(unsafe.Pointer(externalFenceInfo.Vulkanize()))

	// externalFenceProperties is a binding-allocated single return value and will be populated by Vulkan
	pExternalFenceProperties := unsafe.Pointer(&externalFenceProperties)

	execTrampoline(keyvkGetPhysicalDeviceExternalFenceProperties, uintptr(physicalDevice), uintptr(pExternalFenceInfo), uintptr(pExternalFenceProperties))

	return
}

// GetPhysicalDeviceExternalSemaphoreProperties: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceExternalSemaphoreProperties.html
func GetPhysicalDeviceExternalSemaphoreProperties(physicalDevice PhysicalDevice, externalSemaphoreInfo *PhysicalDeviceExternalSemaphoreInfo) (externalSemaphoreProperties ExternalSemaphoreProperties) {
	// Parameter is a singular input, requires translation - externalSemaphoreInfo
	pExternalSemaphoreInfo := unsafe.Pointer(unsafe.Pointer(externalSemaphoreInfo.Vulkanize()))

	// externalSemaphoreProperties is a binding-allocated single return value and will be populated by Vulkan
	pExternalSemaphoreProperties := unsafe.Pointer(&externalSemaphoreProperties)

	execTrampoline(keyvkGetPhysicalDeviceExternalSemaphoreProperties, uintptr(physicalDevice), uintptr(pExternalSemaphoreInfo), uintptr(pExternalSemaphoreProperties))

	return
}

// GetPhysicalDeviceFeatures: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceFeatures.html
func GetPhysicalDeviceFeatures(physicalDevice PhysicalDevice) (features PhysicalDeviceFeatures) {
	// features is a binding-allocated single return value and will be populated by Vulkan
	pFeatures := unsafe.Pointer(&features)

	execTrampoline(keyvkGetPhysicalDeviceFeatures, uintptr(physicalDevice), uintptr(pFeatures))

	return
}

// GetPhysicalDeviceFeatures2: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceFeatures2.html
func GetPhysicalDeviceFeatures2(physicalDevice PhysicalDevice) (features PhysicalDeviceFeatures2) {
	// features is a binding-allocated single return value and will be populated by Vulkan
	pFeatures := unsafe.Pointer(&features)

	execTrampoline(keyvkGetPhysicalDeviceFeatures2, uintptr(physicalDevice), uintptr(pFeatures))

	return
}

// GetPhysicalDeviceFormatProperties: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceFormatProperties.html
func GetPhysicalDeviceFormatProperties(physicalDevice PhysicalDevice, format Format) (formatProperties FormatProperties) {
	// formatProperties is a binding-allocated single return value and will be populated by Vulkan
	pFormatProperties := unsafe.Pointer(&formatProperties)

	execTrampoline(keyvkGetPhysicalDeviceFormatProperties, uintptr(physicalDevice), uintptr(format), uintptr(pFormatProperties))

	return
}

// GetPhysicalDeviceFormatProperties2: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceFormatProperties2.html
func GetPhysicalDeviceFormatProperties2(physicalDevice PhysicalDevice, format Format) (formatProperties FormatProperties2) {
	// formatProperties is a binding-allocated single return value and will be populated by Vulkan
	pFormatProperties := unsafe.Pointer(&formatProperties)

	execTrampoline(keyvkGetPhysicalDeviceFormatProperties2, uintptr(physicalDevice), uintptr(format), uintptr(pFormatProperties))

	return
}

// GetPhysicalDeviceImageFormatProperties: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceImageFormatProperties.html
func GetPhysicalDeviceImageFormatProperties(physicalDevice PhysicalDevice, format Format, typ ImageType, tiling ImageTiling, usage ImageUsageFlags, flags ImageCreateFlags) (r Result, imageFormatProperties ImageFormatProperties) {
	// imageFormatProperties is a binding-allocated single return value and will be populated by Vulkan
	pImageFormatProperties := unsafe.Pointer(&imageFormatProperties)

	r = Result(execTrampoline(keyvkGetPhysicalDeviceImageFormatProperties, uintptr(physicalDevice), uintptr(format), uintptr(typ), uintptr(tiling), uintptr(usage), uintptr(flags), uintptr(pImageFormatProperties)))

	return
}

// GetPhysicalDeviceImageFormatProperties2: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceImageFormatProperties2.html
func GetPhysicalDeviceImageFormatProperties2(physicalDevice PhysicalDevice, imageFormatInfo *PhysicalDeviceImageFormatInfo2) (r Result, imageFormatProperties ImageFormatProperties2) {
	// Parameter is a singular input, requires translation - imageFormatInfo
	pImageFormatInfo := unsafe.Pointer(unsafe.Pointer(imageFormatInfo.Vulkanize()))

	// imageFormatProperties is a binding-allocated single return value and will be populated by Vulkan
	pImageFormatProperties := unsafe.Pointer(&imageFormatProperties)

	r = Result(execTrampoline(keyvkGetPhysicalDeviceImageFormatProperties2, uintptr(physicalDevice), uintptr(pImageFormatInfo), uintptr(pImageFormatProperties)))

	return
}

// GetPhysicalDeviceMemoryProperties: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceMemoryProperties.html
func GetPhysicalDeviceMemoryProperties(physicalDevice PhysicalDevice) (memoryProperties PhysicalDeviceMemoryProperties) {
	// memoryProperties is a binding-allocated single return value and will be populated by Vulkan
	pMemoryProperties := unsafe.Pointer(&memoryProperties)

	execTrampoline(keyvkGetPhysicalDeviceMemoryProperties, uintptr(physicalDevice), uintptr(pMemoryProperties))

	return
}

// GetPhysicalDeviceMemoryProperties2: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceMemoryProperties2.html
func GetPhysicalDeviceMemoryProperties2(physicalDevice PhysicalDevice) (memoryProperties PhysicalDeviceMemoryProperties2) {
	// memoryProperties is a binding-allocated single return value and will be populated by Vulkan
	pMemoryProperties := unsafe.Pointer(&memoryProperties)

	execTrampoline(keyvkGetPhysicalDeviceMemoryProperties2, uintptr(physicalDevice), uintptr(pMemoryProperties))

	return
}

// GetPhysicalDeviceProperties: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceProperties.html
func GetPhysicalDeviceProperties(physicalDevice PhysicalDevice) (properties PhysicalDeviceProperties) {
	// properties is a binding-allocated single return value and will be populated by Vulkan
	pProperties := unsafe.Pointer(&properties)

	execTrampoline(keyvkGetPhysicalDeviceProperties, uintptr(physicalDevice), uintptr(pProperties))

	return
}

// GetPhysicalDeviceProperties2: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceProperties2.html
func GetPhysicalDeviceProperties2(physicalDevice PhysicalDevice) (properties PhysicalDeviceProperties2) {
	// properties is a binding-allocated single return value and will be populated by Vulkan
	pProperties := unsafe.Pointer(&properties)

	execTrampoline(keyvkGetPhysicalDeviceProperties2, uintptr(physicalDevice), uintptr(pProperties))

	return
}

// GetPhysicalDeviceQueueFamilyProperties: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceQueueFamilyProperties.html
func GetPhysicalDeviceQueueFamilyProperties(physicalDevice PhysicalDevice) (queueFamilyProperties []QueueFamilyProperties) {
	// queueFamilyProperties is a double-call array output
	var queueFamilyPropertyCount uint32
	pQueueFamilyPropertyCount := unsafe.Pointer(&queueFamilyPropertyCount)
	var pQueueFamilyProperties unsafe.Pointer
	// first trampoline happens here; also, check returned Result value

	execTrampoline(keyvkGetPhysicalDeviceQueueFamilyProperties, uintptr(physicalDevice), uintptr(pQueueFamilyPropertyCount), uintptr(pQueueFamilyProperties))

	queueFamilyProperties = make([]QueueFamilyProperties, queueFamilyPropertyCount)
	pQueueFamilyProperties = unsafe.Pointer(&queueFamilyProperties[0])

	execTrampoline(keyvkGetPhysicalDeviceQueueFamilyProperties, uintptr(physicalDevice), uintptr(pQueueFamilyPropertyCount), uintptr(pQueueFamilyProperties))

	return
}

// GetPhysicalDeviceQueueFamilyProperties2: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceQueueFamilyProperties2.html
func GetPhysicalDeviceQueueFamilyProperties2(physicalDevice PhysicalDevice) (queueFamilyProperties []QueueFamilyProperties2) {
	// queueFamilyProperties is a double-call array output
	var queueFamilyPropertyCount uint32
	pQueueFamilyPropertyCount := unsafe.Pointer(&queueFamilyPropertyCount)
	var pQueueFamilyProperties unsafe.Pointer
	// first trampoline happens here; also, check returned Result value

	execTrampoline(keyvkGetPhysicalDeviceQueueFamilyProperties2, uintptr(physicalDevice), uintptr(pQueueFamilyPropertyCount), uintptr(pQueueFamilyProperties))

	queueFamilyProperties = make([]QueueFamilyProperties2, queueFamilyPropertyCount)
	pQueueFamilyProperties = unsafe.Pointer(&queueFamilyProperties[0])

	execTrampoline(keyvkGetPhysicalDeviceQueueFamilyProperties2, uintptr(physicalDevice), uintptr(pQueueFamilyPropertyCount), uintptr(pQueueFamilyProperties))

	return
}

// GetPhysicalDeviceSparseImageFormatProperties: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceSparseImageFormatProperties.html
func GetPhysicalDeviceSparseImageFormatProperties(physicalDevice PhysicalDevice, format Format, typ ImageType, samples SampleCountFlagBits, usage ImageUsageFlags, tiling ImageTiling) (properties []SparseImageFormatProperties) {
	// properties is a double-call array output
	var propertyCount uint32
	pPropertyCount := unsafe.Pointer(&propertyCount)
	var pProperties unsafe.Pointer
	// first trampoline happens here; also, check returned Result value

	execTrampoline(keyvkGetPhysicalDeviceSparseImageFormatProperties, uintptr(physicalDevice), uintptr(format), uintptr(typ), uintptr(samples), uintptr(usage), uintptr(tiling), uintptr(pPropertyCount), uintptr(pProperties))

	properties = make([]SparseImageFormatProperties, propertyCount)
	pProperties = unsafe.Pointer(&properties[0])

	execTrampoline(keyvkGetPhysicalDeviceSparseImageFormatProperties, uintptr(physicalDevice), uintptr(format), uintptr(typ), uintptr(samples), uintptr(usage), uintptr(tiling), uintptr(pPropertyCount), uintptr(pProperties))

	return
}

// GetPhysicalDeviceSparseImageFormatProperties2: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceSparseImageFormatProperties2.html
func GetPhysicalDeviceSparseImageFormatProperties2(physicalDevice PhysicalDevice, formatInfo *PhysicalDeviceSparseImageFormatInfo2) (properties []SparseImageFormatProperties2) {
	// Parameter is a singular input, requires translation - formatInfo
	pFormatInfo := unsafe.Pointer(unsafe.Pointer(formatInfo.Vulkanize()))

	// properties is a double-call array output
	var propertyCount uint32
	pPropertyCount := unsafe.Pointer(&propertyCount)
	var pProperties unsafe.Pointer
	// first trampoline happens here; also, check returned Result value

	execTrampoline(keyvkGetPhysicalDeviceSparseImageFormatProperties2, uintptr(physicalDevice), uintptr(pFormatInfo), uintptr(pPropertyCount), uintptr(pProperties))

	properties = make([]SparseImageFormatProperties2, propertyCount)
	pProperties = unsafe.Pointer(&properties[0])

	execTrampoline(keyvkGetPhysicalDeviceSparseImageFormatProperties2, uintptr(physicalDevice), uintptr(pFormatInfo), uintptr(pPropertyCount), uintptr(pProperties))

	return
}

// GetPhysicalDeviceSurfaceCapabilitiesKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceSurfaceCapabilitiesKHR.html
func GetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice PhysicalDevice, surface SurfaceKHR) (r Result, surfaceCapabilities SurfaceCapabilitiesKHR) {
	// surfaceCapabilities is a binding-allocated single return value and will be populated by Vulkan
	pSurfaceCapabilities := unsafe.Pointer(&surfaceCapabilities)

	r = Result(execTrampoline(keyvkGetPhysicalDeviceSurfaceCapabilitiesKHR, uintptr(physicalDevice), uintptr(surface), uintptr(pSurfaceCapabilities)))

	return
}

// GetPhysicalDeviceSurfaceFormatsKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceSurfaceFormatsKHR.html
func GetPhysicalDeviceSurfaceFormatsKHR(physicalDevice PhysicalDevice, surface SurfaceKHR) (r Result, surfaceFormats []SurfaceFormatKHR) {
	// surfaceFormats is a double-call array output
	var surfaceFormatCount uint32
	pSurfaceFormatCount := unsafe.Pointer(&surfaceFormatCount)
	var pSurfaceFormats unsafe.Pointer
	// first trampoline happens here; also, check returned Result value

	r = Result(execTrampoline(keyvkGetPhysicalDeviceSurfaceFormatsKHR, uintptr(physicalDevice), uintptr(surface), uintptr(pSurfaceFormatCount), uintptr(pSurfaceFormats)))

	surfaceFormats = make([]SurfaceFormatKHR, surfaceFormatCount)
	pSurfaceFormats = unsafe.Pointer(&surfaceFormats[0])

	r = Result(execTrampoline(keyvkGetPhysicalDeviceSurfaceFormatsKHR, uintptr(physicalDevice), uintptr(surface), uintptr(pSurfaceFormatCount), uintptr(pSurfaceFormats)))

	return
}

// GetPhysicalDeviceSurfacePresentModesKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceSurfacePresentModesKHR.html
func GetPhysicalDeviceSurfacePresentModesKHR(physicalDevice PhysicalDevice, surface SurfaceKHR) (r Result, presentModes []PresentModeKHR) {
	// presentModes is a double-call array output
	var presentModeCount uint32
	pPresentModeCount := unsafe.Pointer(&presentModeCount)
	var pPresentModes unsafe.Pointer
	// first trampoline happens here; also, check returned Result value

	r = Result(execTrampoline(keyvkGetPhysicalDeviceSurfacePresentModesKHR, uintptr(physicalDevice), uintptr(surface), uintptr(pPresentModeCount), uintptr(pPresentModes)))

	presentModes = make([]PresentModeKHR, presentModeCount)
	pPresentModes = unsafe.Pointer(&presentModes[0])

	r = Result(execTrampoline(keyvkGetPhysicalDeviceSurfacePresentModesKHR, uintptr(physicalDevice), uintptr(surface), uintptr(pPresentModeCount), uintptr(pPresentModes)))

	return
}

// GetPhysicalDeviceSurfaceSupportKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceSurfaceSupportKHR.html
func GetPhysicalDeviceSurfaceSupportKHR(physicalDevice PhysicalDevice, queueFamilyIndex uint32, surface SurfaceKHR) (r Result, supported bool) {
	// supported is a binding-allocated single return value and will be populated by Vulkan
	pSupported := unsafe.Pointer(&supported)

	r = Result(execTrampoline(keyvkGetPhysicalDeviceSurfaceSupportKHR, uintptr(physicalDevice), uintptr(queueFamilyIndex), uintptr(surface), uintptr(pSupported)))

	return
}

// GetPipelineCacheData: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPipelineCacheData.html
func GetPipelineCacheData(device Device, pipelineCache PipelineCache) (r Result, data []byte) {
	// data is a double-call array output
	var dataSize uintptr
	pDataSize := unsafe.Pointer(&dataSize)
	var pData unsafe.Pointer
	// first trampoline happens here; also, check returned Result value

	r = Result(execTrampoline(keyvkGetPipelineCacheData, uintptr(device), uintptr(pipelineCache), uintptr(pDataSize), uintptr(pData)))

	data = make([]byte, dataSize)
	pData = unsafe.Pointer(&data[0])

	r = Result(execTrampoline(keyvkGetPipelineCacheData, uintptr(device), uintptr(pipelineCache), uintptr(pDataSize), uintptr(pData)))

	return
}

// GetQueryPoolResults: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetQueryPoolResults.html
func GetQueryPoolResults(device Device, queryPool QueryPool, firstQuery uint32, queryCount uint32, data []byte, stride DeviceSize, flags QueryResultFlags) (r Result) {
	dataSize := len(data)
	// Parameter is a user-allocated array input that will be written to (?) - data
	pData := unsafe.Pointer(&data[0])

	r = Result(execTrampoline(keyvkGetQueryPoolResults, uintptr(device), uintptr(queryPool), uintptr(firstQuery), uintptr(queryCount), uintptr(dataSize), uintptr(pData), uintptr(stride), uintptr(flags)))

	return
}

// GetRenderAreaGranularity: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetRenderAreaGranularity.html
func GetRenderAreaGranularity(device Device, renderPass RenderPass) (granularity Extent2D) {
	// granularity is a binding-allocated single return value and will be populated by Vulkan
	pGranularity := unsafe.Pointer(&granularity)

	execTrampoline(keyvkGetRenderAreaGranularity, uintptr(device), uintptr(renderPass), uintptr(pGranularity))

	return
}

// InvalidateMappedMemoryRanges: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkInvalidateMappedMemoryRanges.html
func InvalidateMappedMemoryRanges(device Device, memoryRanges []MappedMemoryRange) (r Result) {
	memoryRangeCount := len(memoryRanges)
	// memoryRanges is an input slice that requires translation to an internal type
	sl_memoryRanges := make([]_vkMappedMemoryRange, memoryRangeCount)
	for i, v := range memoryRanges {
		sl_memoryRanges[i] = *(v.Vulkanize())
	}
	pMemoryRanges := unsafe.Pointer(&sl_memoryRanges[0])

	r = Result(execTrampoline(keyvkInvalidateMappedMemoryRanges, uintptr(device), uintptr(memoryRangeCount), uintptr(pMemoryRanges)))

	return
}

// MapMemory: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkMapMemory.html
func MapMemory(device Device, memory DeviceMemory, offset DeviceSize, size DeviceSize, flags MemoryMapFlags) (r Result, pData *byte) {
	// pData is a binding-allocated single return value and will be populated by Vulkan
	ppData := unsafe.Pointer(&pData)

	r = Result(execTrampoline(keyvkMapMemory, uintptr(device), uintptr(memory), uintptr(offset), uintptr(size), uintptr(flags), uintptr(ppData)))

	return
}

// MergePipelineCaches: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkMergePipelineCaches.html
func MergePipelineCaches(device Device, dstCache PipelineCache, srcCaches []PipelineCache) (r Result) {
	srcCacheCount := len(srcCaches)
	// srcCaches is an input slice of values that do not need translation used
	pSrcCaches := unsafe.Pointer(&srcCaches[0])

	r = Result(execTrampoline(keyvkMergePipelineCaches, uintptr(device), uintptr(dstCache), uintptr(srcCacheCount), uintptr(pSrcCaches)))

	return
}

// QueueBindSparse: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkQueueBindSparse.html
func QueueBindSparse(queue Queue, bindInfo []BindSparseInfo, fence Fence) (r Result) {
	bindInfoCount := len(bindInfo)
	// bindInfo is an input slice that requires translation to an internal type
	sl_bindInfo := make([]_vkBindSparseInfo, bindInfoCount)
	for i, v := range bindInfo {
		sl_bindInfo[i] = *(v.Vulkanize())
	}
	pBindInfo := unsafe.Pointer(&sl_bindInfo[0])

	r = Result(execTrampoline(keyvkQueueBindSparse, uintptr(queue), uintptr(bindInfoCount), uintptr(pBindInfo), uintptr(fence)))

	return
}

// QueueSubmit: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkQueueSubmit.html
func QueueSubmit(queue Queue, submits []SubmitInfo, fence Fence) (r Result) {
	submitCount := len(submits)
	// submits is an input slice that requires translation to an internal type
	sl_submits := make([]_vkSubmitInfo, submitCount)
	for i, v := range submits {
		sl_submits[i] = *(v.Vulkanize())
	}
	pSubmits := unsafe.Pointer(&sl_submits[0])

	r = Result(execTrampoline(keyvkQueueSubmit, uintptr(queue), uintptr(submitCount), uintptr(pSubmits), uintptr(fence)))

	return
}

// QueueWaitIdle: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkQueueWaitIdle.html
func QueueWaitIdle(queue Queue) (r Result) {

	r = Result(execTrampoline(keyvkQueueWaitIdle, uintptr(queue)))

	return
}

// ResetCommandBuffer: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkResetCommandBuffer.html
func ResetCommandBuffer(commandBuffer CommandBuffer, flags CommandBufferResetFlags) (r Result) {

	r = Result(execTrampoline(keyvkResetCommandBuffer, uintptr(commandBuffer), uintptr(flags)))

	return
}

// ResetCommandPool: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkResetCommandPool.html
func ResetCommandPool(device Device, commandPool CommandPool, flags CommandPoolResetFlags) (r Result) {

	r = Result(execTrampoline(keyvkResetCommandPool, uintptr(device), uintptr(commandPool), uintptr(flags)))

	return
}

// ResetDescriptorPool: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkResetDescriptorPool.html
func ResetDescriptorPool(device Device, descriptorPool DescriptorPool, flags DescriptorPoolResetFlags) (r Result) {

	r = Result(execTrampoline(keyvkResetDescriptorPool, uintptr(device), uintptr(descriptorPool), uintptr(flags)))

	return
}

// ResetEvent: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkResetEvent.html
func ResetEvent(device Device, event Event) (r Result) {

	r = Result(execTrampoline(keyvkResetEvent, uintptr(device), uintptr(event)))

	return
}

// ResetFences: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkResetFences.html
func ResetFences(device Device, fences []Fence) (r Result) {
	fenceCount := len(fences)
	// fences is an input slice of values that do not need translation used
	pFences := unsafe.Pointer(&fences[0])

	r = Result(execTrampoline(keyvkResetFences, uintptr(device), uintptr(fenceCount), uintptr(pFences)))

	return
}

// SetEvent: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkSetEvent.html
func SetEvent(device Device, event Event) (r Result) {

	r = Result(execTrampoline(keyvkSetEvent, uintptr(device), uintptr(event)))

	return
}

// TrimCommandPool: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkTrimCommandPool.html
func TrimCommandPool(device Device, commandPool CommandPool, flags CommandPoolTrimFlags) {

	execTrampoline(keyvkTrimCommandPool, uintptr(device), uintptr(commandPool), uintptr(flags))

}

// UnmapMemory: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkUnmapMemory.html
func UnmapMemory(device Device, memory DeviceMemory) {

	execTrampoline(keyvkUnmapMemory, uintptr(device), uintptr(memory))

}

// UpdateDescriptorSetWithTemplate: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkUpdateDescriptorSetWithTemplate.html
func UpdateDescriptorSetWithTemplate(device Device, descriptorSet DescriptorSet, descriptorUpdateTemplate DescriptorUpdateTemplate, data *byte) {
	// Parameter is a singular input, pass direct - data
	pData := unsafe.Pointer(data)

	execTrampoline(keyvkUpdateDescriptorSetWithTemplate, uintptr(device), uintptr(descriptorSet), uintptr(descriptorUpdateTemplate), uintptr(pData))

}

// UpdateDescriptorSets: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkUpdateDescriptorSets.html
func UpdateDescriptorSets(device Device, descriptorWrites []WriteDescriptorSet, descriptorCopies []CopyDescriptorSet) {
	descriptorWriteCount := len(descriptorWrites)
	// descriptorWrites is an input slice that requires translation to an internal type
	sl_descriptorWrites := make([]_vkWriteDescriptorSet, descriptorWriteCount)
	for i, v := range descriptorWrites {
		sl_descriptorWrites[i] = *(v.Vulkanize())
	}
	pDescriptorWrites := unsafe.Pointer(&sl_descriptorWrites[0])

	descriptorCopyCount := len(descriptorCopies)
	// descriptorCopies is an input slice that requires translation to an internal type
	sl_descriptorCopies := make([]_vkCopyDescriptorSet, descriptorCopyCount)
	for i, v := range descriptorCopies {
		sl_descriptorCopies[i] = *(v.Vulkanize())
	}
	pDescriptorCopies := unsafe.Pointer(&sl_descriptorCopies[0])

	execTrampoline(keyvkUpdateDescriptorSets, uintptr(device), uintptr(descriptorWriteCount), uintptr(pDescriptorWrites), uintptr(descriptorCopyCount), uintptr(pDescriptorCopies))

}

// WaitForFences: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkWaitForFences.html
func WaitForFences(device Device, fences []Fence, waitAll bool, timeout uint64) (r Result) {
	fenceCount := len(fences)
	// fences is an input slice of values that do not need translation used
	pFences := unsafe.Pointer(&fences[0])

	waitAll_Bool32 := translateInternal_Bool32(waitAll)

	r = Result(execTrampoline(keyvkWaitForFences, uintptr(device), uintptr(fenceCount), uintptr(pFences), uintptr(waitAll_Bool32), uintptr(timeout)))

	return
}
