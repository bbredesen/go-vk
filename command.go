// Code generated by go-vk from vk.xml at 2023-03-09 10:07:56.9046495 -0600 CST m=+2.313271201. DO NOT EDIT.

package vk

import "unsafe"

const (
	keyvkAcquireDrmDisplayEXT vkCommandKey = iota
	keyvkAcquireNextImage2KHR
	keyvkAcquireNextImageKHR
	keyvkAcquirePerformanceConfigurationINTEL
	keyvkAcquireProfilingLockKHR
	keyvkAllocateCommandBuffers
	keyvkAllocateDescriptorSets
	keyvkAllocateMemory
	keyvkBeginCommandBuffer
	keyvkBindAccelerationStructureMemoryNV
	keyvkBindBufferMemory
	keyvkBindBufferMemory2
	keyvkBindImageMemory
	keyvkBindImageMemory2
	keyvkBindOpticalFlowSessionImageNV
	keyvkBindVideoSessionMemoryKHR
	keyvkBuildAccelerationStructuresKHR
	keyvkBuildMicromapsEXT
	keyvkCmdBeginConditionalRenderingEXT
	keyvkCmdBeginDebugUtilsLabelEXT
	keyvkCmdBeginQuery
	keyvkCmdBeginQueryIndexedEXT
	keyvkCmdBeginRenderPass
	keyvkCmdBeginRenderPass2
	keyvkCmdBeginRendering
	keyvkCmdBeginTransformFeedbackEXT
	keyvkCmdBeginVideoCodingKHR
	keyvkCmdBindDescriptorBufferEmbeddedSamplersEXT
	keyvkCmdBindDescriptorBuffersEXT
	keyvkCmdBindDescriptorSets
	keyvkCmdBindIndexBuffer
	keyvkCmdBindInvocationMaskHUAWEI
	keyvkCmdBindPipeline
	keyvkCmdBindPipelineShaderGroupNV
	keyvkCmdBindShadingRateImageNV
	keyvkCmdBindTransformFeedbackBuffersEXT
	keyvkCmdBindVertexBuffers
	keyvkCmdBindVertexBuffers2
	keyvkCmdBlitImage
	keyvkCmdBlitImage2
	keyvkCmdBuildAccelerationStructureNV
	keyvkCmdBuildAccelerationStructuresIndirectKHR
	keyvkCmdBuildAccelerationStructuresKHR
	keyvkCmdBuildMicromapsEXT
	keyvkCmdClearAttachments
	keyvkCmdClearColorImage
	keyvkCmdClearDepthStencilImage
	keyvkCmdControlVideoCodingKHR
	keyvkCmdCopyAccelerationStructureKHR
	keyvkCmdCopyAccelerationStructureNV
	keyvkCmdCopyAccelerationStructureToMemoryKHR
	keyvkCmdCopyBuffer
	keyvkCmdCopyBuffer2
	keyvkCmdCopyBufferToImage
	keyvkCmdCopyBufferToImage2
	keyvkCmdCopyImage
	keyvkCmdCopyImage2
	keyvkCmdCopyImageToBuffer
	keyvkCmdCopyImageToBuffer2
	keyvkCmdCopyMemoryIndirectNV
	keyvkCmdCopyMemoryToAccelerationStructureKHR
	keyvkCmdCopyMemoryToImageIndirectNV
	keyvkCmdCopyMemoryToMicromapEXT
	keyvkCmdCopyMicromapEXT
	keyvkCmdCopyMicromapToMemoryEXT
	keyvkCmdCopyQueryPoolResults
	keyvkCmdCuLaunchKernelNVX
	keyvkCmdDebugMarkerBeginEXT
	keyvkCmdDebugMarkerEndEXT
	keyvkCmdDebugMarkerInsertEXT
	keyvkCmdDecodeVideoKHR
	keyvkCmdDecompressMemoryIndirectCountNV
	keyvkCmdDecompressMemoryNV
	keyvkCmdDispatch
	keyvkCmdDispatchBase
	keyvkCmdDispatchIndirect
	keyvkCmdDraw
	keyvkCmdDrawClusterHUAWEI
	keyvkCmdDrawClusterIndirectHUAWEI
	keyvkCmdDrawIndexed
	keyvkCmdDrawIndexedIndirect
	keyvkCmdDrawIndexedIndirectCount
	keyvkCmdDrawIndirect
	keyvkCmdDrawIndirectByteCountEXT
	keyvkCmdDrawIndirectCount
	keyvkCmdDrawMeshTasksEXT
	keyvkCmdDrawMeshTasksIndirectCountEXT
	keyvkCmdDrawMeshTasksIndirectCountNV
	keyvkCmdDrawMeshTasksIndirectEXT
	keyvkCmdDrawMeshTasksIndirectNV
	keyvkCmdDrawMeshTasksNV
	keyvkCmdDrawMultiEXT
	keyvkCmdDrawMultiIndexedEXT
	keyvkCmdEndConditionalRenderingEXT
	keyvkCmdEndDebugUtilsLabelEXT
	keyvkCmdEndQuery
	keyvkCmdEndQueryIndexedEXT
	keyvkCmdEndRenderPass
	keyvkCmdEndRenderPass2
	keyvkCmdEndRendering
	keyvkCmdEndTransformFeedbackEXT
	keyvkCmdEndVideoCodingKHR
	keyvkCmdExecuteCommands
	keyvkCmdExecuteGeneratedCommandsNV
	keyvkCmdFillBuffer
	keyvkCmdInsertDebugUtilsLabelEXT
	keyvkCmdNextSubpass
	keyvkCmdNextSubpass2
	keyvkCmdOpticalFlowExecuteNV
	keyvkCmdPipelineBarrier
	keyvkCmdPipelineBarrier2
	keyvkCmdPreprocessGeneratedCommandsNV
	keyvkCmdPushConstants
	keyvkCmdPushDescriptorSetKHR
	keyvkCmdPushDescriptorSetWithTemplateKHR
	keyvkCmdResetEvent
	keyvkCmdResetEvent2
	keyvkCmdResetQueryPool
	keyvkCmdResolveImage
	keyvkCmdResolveImage2
	keyvkCmdSetAlphaToCoverageEnableEXT
	keyvkCmdSetAlphaToOneEnableEXT
	keyvkCmdSetBlendConstants
	keyvkCmdSetCheckpointNV
	keyvkCmdSetCoarseSampleOrderNV
	keyvkCmdSetColorBlendAdvancedEXT
	keyvkCmdSetColorBlendEnableEXT
	keyvkCmdSetColorBlendEquationEXT
	keyvkCmdSetColorWriteEnableEXT
	keyvkCmdSetColorWriteMaskEXT
	keyvkCmdSetConservativeRasterizationModeEXT
	keyvkCmdSetCoverageModulationModeNV
	keyvkCmdSetCoverageModulationTableEnableNV
	keyvkCmdSetCoverageModulationTableNV
	keyvkCmdSetCoverageReductionModeNV
	keyvkCmdSetCoverageToColorEnableNV
	keyvkCmdSetCoverageToColorLocationNV
	keyvkCmdSetCullMode
	keyvkCmdSetDepthBias
	keyvkCmdSetDepthBiasEnable
	keyvkCmdSetDepthBounds
	keyvkCmdSetDepthBoundsTestEnable
	keyvkCmdSetDepthClampEnableEXT
	keyvkCmdSetDepthClipEnableEXT
	keyvkCmdSetDepthClipNegativeOneToOneEXT
	keyvkCmdSetDepthCompareOp
	keyvkCmdSetDepthTestEnable
	keyvkCmdSetDepthWriteEnable
	keyvkCmdSetDescriptorBufferOffsetsEXT
	keyvkCmdSetDeviceMask
	keyvkCmdSetDiscardRectangleEXT
	keyvkCmdSetEvent
	keyvkCmdSetEvent2
	keyvkCmdSetExclusiveScissorNV
	keyvkCmdSetExtraPrimitiveOverestimationSizeEXT
	keyvkCmdSetFragmentShadingRateEnumNV
	keyvkCmdSetFragmentShadingRateKHR
	keyvkCmdSetFrontFace
	keyvkCmdSetLineRasterizationModeEXT
	keyvkCmdSetLineStippleEXT
	keyvkCmdSetLineStippleEnableEXT
	keyvkCmdSetLineWidth
	keyvkCmdSetLogicOpEXT
	keyvkCmdSetLogicOpEnableEXT
	keyvkCmdSetPatchControlPointsEXT
	keyvkCmdSetPerformanceMarkerINTEL
	keyvkCmdSetPerformanceOverrideINTEL
	keyvkCmdSetPerformanceStreamMarkerINTEL
	keyvkCmdSetPolygonModeEXT
	keyvkCmdSetPrimitiveRestartEnable
	keyvkCmdSetPrimitiveTopology
	keyvkCmdSetProvokingVertexModeEXT
	keyvkCmdSetRasterizationSamplesEXT
	keyvkCmdSetRasterizationStreamEXT
	keyvkCmdSetRasterizerDiscardEnable
	keyvkCmdSetRayTracingPipelineStackSizeKHR
	keyvkCmdSetRepresentativeFragmentTestEnableNV
	keyvkCmdSetSampleLocationsEXT
	keyvkCmdSetSampleLocationsEnableEXT
	keyvkCmdSetSampleMaskEXT
	keyvkCmdSetScissor
	keyvkCmdSetScissorWithCount
	keyvkCmdSetShadingRateImageEnableNV
	keyvkCmdSetStencilCompareMask
	keyvkCmdSetStencilOp
	keyvkCmdSetStencilReference
	keyvkCmdSetStencilTestEnable
	keyvkCmdSetStencilWriteMask
	keyvkCmdSetTessellationDomainOriginEXT
	keyvkCmdSetVertexInputEXT
	keyvkCmdSetViewport
	keyvkCmdSetViewportShadingRatePaletteNV
	keyvkCmdSetViewportSwizzleNV
	keyvkCmdSetViewportWScalingEnableNV
	keyvkCmdSetViewportWScalingNV
	keyvkCmdSetViewportWithCount
	keyvkCmdSubpassShadingHUAWEI
	keyvkCmdTraceRaysIndirect2KHR
	keyvkCmdTraceRaysIndirectKHR
	keyvkCmdTraceRaysKHR
	keyvkCmdTraceRaysNV
	keyvkCmdUpdateBuffer
	keyvkCmdWaitEvents
	keyvkCmdWaitEvents2
	keyvkCmdWriteAccelerationStructuresPropertiesKHR
	keyvkCmdWriteAccelerationStructuresPropertiesNV
	keyvkCmdWriteBufferMarker2AMD
	keyvkCmdWriteBufferMarkerAMD
	keyvkCmdWriteMicromapsPropertiesEXT
	keyvkCmdWriteTimestamp
	keyvkCmdWriteTimestamp2
	keyvkCompileDeferredNV
	keyvkCopyAccelerationStructureKHR
	keyvkCopyAccelerationStructureToMemoryKHR
	keyvkCopyMemoryToAccelerationStructureKHR
	keyvkCopyMemoryToMicromapEXT
	keyvkCopyMicromapEXT
	keyvkCopyMicromapToMemoryEXT
	keyvkCreateAccelerationStructureKHR
	keyvkCreateAccelerationStructureNV
	keyvkCreateBuffer
	keyvkCreateBufferView
	keyvkCreateCommandPool
	keyvkCreateComputePipelines
	keyvkCreateCuFunctionNVX
	keyvkCreateCuModuleNVX
	keyvkCreateDebugReportCallbackEXT
	keyvkCreateDebugUtilsMessengerEXT
	keyvkCreateDeferredOperationKHR
	keyvkCreateDescriptorPool
	keyvkCreateDescriptorSetLayout
	keyvkCreateDescriptorUpdateTemplate
	keyvkCreateDevice
	keyvkCreateDisplayModeKHR
	keyvkCreateDisplayPlaneSurfaceKHR
	keyvkCreateEvent
	keyvkCreateFence
	keyvkCreateFramebuffer
	keyvkCreateGraphicsPipelines
	keyvkCreateHeadlessSurfaceEXT
	keyvkCreateImage
	keyvkCreateImageView
	keyvkCreateIndirectCommandsLayoutNV
	keyvkCreateInstance
	keyvkCreateMicromapEXT
	keyvkCreateOpticalFlowSessionNV
	keyvkCreatePipelineCache
	keyvkCreatePipelineLayout
	keyvkCreatePrivateDataSlot
	keyvkCreateQueryPool
	keyvkCreateRayTracingPipelinesKHR
	keyvkCreateRayTracingPipelinesNV
	keyvkCreateRenderPass
	keyvkCreateRenderPass2
	keyvkCreateSampler
	keyvkCreateSamplerYcbcrConversion
	keyvkCreateSemaphore
	keyvkCreateShaderModule
	keyvkCreateSharedSwapchainsKHR
	keyvkCreateSwapchainKHR
	keyvkCreateValidationCacheEXT
	keyvkCreateVideoSessionKHR
	keyvkCreateVideoSessionParametersKHR
	keyvkDebugMarkerSetObjectNameEXT
	keyvkDebugMarkerSetObjectTagEXT
	keyvkDebugReportMessageEXT
	keyvkDeferredOperationJoinKHR
	keyvkDestroyAccelerationStructureKHR
	keyvkDestroyAccelerationStructureNV
	keyvkDestroyBuffer
	keyvkDestroyBufferView
	keyvkDestroyCommandPool
	keyvkDestroyCuFunctionNVX
	keyvkDestroyCuModuleNVX
	keyvkDestroyDebugReportCallbackEXT
	keyvkDestroyDebugUtilsMessengerEXT
	keyvkDestroyDeferredOperationKHR
	keyvkDestroyDescriptorPool
	keyvkDestroyDescriptorSetLayout
	keyvkDestroyDescriptorUpdateTemplate
	keyvkDestroyDevice
	keyvkDestroyEvent
	keyvkDestroyFence
	keyvkDestroyFramebuffer
	keyvkDestroyImage
	keyvkDestroyImageView
	keyvkDestroyIndirectCommandsLayoutNV
	keyvkDestroyInstance
	keyvkDestroyMicromapEXT
	keyvkDestroyOpticalFlowSessionNV
	keyvkDestroyPipeline
	keyvkDestroyPipelineCache
	keyvkDestroyPipelineLayout
	keyvkDestroyPrivateDataSlot
	keyvkDestroyQueryPool
	keyvkDestroyRenderPass
	keyvkDestroySampler
	keyvkDestroySamplerYcbcrConversion
	keyvkDestroySemaphore
	keyvkDestroyShaderModule
	keyvkDestroySurfaceKHR
	keyvkDestroySwapchainKHR
	keyvkDestroyValidationCacheEXT
	keyvkDestroyVideoSessionKHR
	keyvkDestroyVideoSessionParametersKHR
	keyvkDeviceWaitIdle
	keyvkDisplayPowerControlEXT
	keyvkEndCommandBuffer
	keyvkEnumerateDeviceExtensionProperties
	keyvkEnumerateDeviceLayerProperties
	keyvkEnumerateInstanceExtensionProperties
	keyvkEnumerateInstanceLayerProperties
	keyvkEnumerateInstanceVersion
	keyvkEnumeratePhysicalDeviceGroups
	keyvkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR
	keyvkEnumeratePhysicalDevices
	keyvkFlushMappedMemoryRanges
	keyvkFreeCommandBuffers
	keyvkFreeDescriptorSets
	keyvkFreeMemory
	keyvkGetAccelerationStructureBuildSizesKHR
	keyvkGetAccelerationStructureDeviceAddressKHR
	keyvkGetAccelerationStructureHandleNV
	keyvkGetAccelerationStructureMemoryRequirementsNV
	keyvkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT
	keyvkGetBufferDeviceAddress
	keyvkGetBufferMemoryRequirements
	keyvkGetBufferMemoryRequirements2
	keyvkGetBufferOpaqueCaptureAddress
	keyvkGetBufferOpaqueCaptureDescriptorDataEXT
	keyvkGetCalibratedTimestampsEXT
	keyvkGetDeferredOperationMaxConcurrencyKHR
	keyvkGetDeferredOperationResultKHR
	keyvkGetDescriptorEXT
	keyvkGetDescriptorSetHostMappingVALVE
	keyvkGetDescriptorSetLayoutBindingOffsetEXT
	keyvkGetDescriptorSetLayoutHostMappingInfoVALVE
	keyvkGetDescriptorSetLayoutSizeEXT
	keyvkGetDescriptorSetLayoutSupport
	keyvkGetDeviceAccelerationStructureCompatibilityKHR
	keyvkGetDeviceBufferMemoryRequirements
	keyvkGetDeviceFaultInfoEXT
	keyvkGetDeviceGroupPeerMemoryFeatures
	keyvkGetDeviceGroupPresentCapabilitiesKHR
	keyvkGetDeviceGroupSurfacePresentModesKHR
	keyvkGetDeviceImageMemoryRequirements
	keyvkGetDeviceImageSparseMemoryRequirements
	keyvkGetDeviceMemoryCommitment
	keyvkGetDeviceMemoryOpaqueCaptureAddress
	keyvkGetDeviceMicromapCompatibilityEXT
	keyvkGetDeviceProcAddr
	keyvkGetDeviceQueue
	keyvkGetDeviceQueue2
	keyvkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI
	keyvkGetDisplayModeProperties2KHR
	keyvkGetDisplayModePropertiesKHR
	keyvkGetDisplayPlaneCapabilities2KHR
	keyvkGetDisplayPlaneCapabilitiesKHR
	keyvkGetDisplayPlaneSupportedDisplaysKHR
	keyvkGetDrmDisplayEXT
	keyvkGetDynamicRenderingTilePropertiesQCOM
	keyvkGetEventStatus
	keyvkGetFenceFdKHR
	keyvkGetFenceStatus
	keyvkGetFramebufferTilePropertiesQCOM
	keyvkGetGeneratedCommandsMemoryRequirementsNV
	keyvkGetImageDrmFormatModifierPropertiesEXT
	keyvkGetImageMemoryRequirements
	keyvkGetImageMemoryRequirements2
	keyvkGetImageOpaqueCaptureDescriptorDataEXT
	keyvkGetImageSparseMemoryRequirements
	keyvkGetImageSparseMemoryRequirements2
	keyvkGetImageSubresourceLayout
	keyvkGetImageSubresourceLayout2EXT
	keyvkGetImageViewAddressNVX
	keyvkGetImageViewHandleNVX
	keyvkGetImageViewOpaqueCaptureDescriptorDataEXT
	keyvkGetInstanceProcAddr
	keyvkGetMemoryFdKHR
	keyvkGetMemoryFdPropertiesKHR
	keyvkGetMemoryHostPointerPropertiesEXT
	keyvkGetMemoryRemoteAddressNV
	keyvkGetMicromapBuildSizesEXT
	keyvkGetPastPresentationTimingGOOGLE
	keyvkGetPerformanceParameterINTEL
	keyvkGetPhysicalDeviceCalibrateableTimeDomainsEXT
	keyvkGetPhysicalDeviceCooperativeMatrixPropertiesNV
	keyvkGetPhysicalDeviceDisplayPlaneProperties2KHR
	keyvkGetPhysicalDeviceDisplayPlanePropertiesKHR
	keyvkGetPhysicalDeviceDisplayProperties2KHR
	keyvkGetPhysicalDeviceDisplayPropertiesKHR
	keyvkGetPhysicalDeviceExternalBufferProperties
	keyvkGetPhysicalDeviceExternalFenceProperties
	keyvkGetPhysicalDeviceExternalImageFormatPropertiesNV
	keyvkGetPhysicalDeviceExternalSemaphoreProperties
	keyvkGetPhysicalDeviceFeatures
	keyvkGetPhysicalDeviceFeatures2
	keyvkGetPhysicalDeviceFormatProperties
	keyvkGetPhysicalDeviceFormatProperties2
	keyvkGetPhysicalDeviceFragmentShadingRatesKHR
	keyvkGetPhysicalDeviceImageFormatProperties
	keyvkGetPhysicalDeviceImageFormatProperties2
	keyvkGetPhysicalDeviceMemoryProperties
	keyvkGetPhysicalDeviceMemoryProperties2
	keyvkGetPhysicalDeviceMultisamplePropertiesEXT
	keyvkGetPhysicalDeviceOpticalFlowImageFormatsNV
	keyvkGetPhysicalDevicePresentRectanglesKHR
	keyvkGetPhysicalDeviceProperties
	keyvkGetPhysicalDeviceProperties2
	keyvkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR
	keyvkGetPhysicalDeviceQueueFamilyProperties
	keyvkGetPhysicalDeviceQueueFamilyProperties2
	keyvkGetPhysicalDeviceSparseImageFormatProperties
	keyvkGetPhysicalDeviceSparseImageFormatProperties2
	keyvkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV
	keyvkGetPhysicalDeviceSurfaceCapabilities2EXT
	keyvkGetPhysicalDeviceSurfaceCapabilities2KHR
	keyvkGetPhysicalDeviceSurfaceCapabilitiesKHR
	keyvkGetPhysicalDeviceSurfaceFormats2KHR
	keyvkGetPhysicalDeviceSurfaceFormatsKHR
	keyvkGetPhysicalDeviceSurfacePresentModesKHR
	keyvkGetPhysicalDeviceSurfaceSupportKHR
	keyvkGetPhysicalDeviceToolProperties
	keyvkGetPhysicalDeviceVideoCapabilitiesKHR
	keyvkGetPhysicalDeviceVideoFormatPropertiesKHR
	keyvkGetPipelineCacheData
	keyvkGetPipelineExecutableInternalRepresentationsKHR
	keyvkGetPipelineExecutablePropertiesKHR
	keyvkGetPipelineExecutableStatisticsKHR
	keyvkGetPipelinePropertiesEXT
	keyvkGetPrivateData
	keyvkGetQueryPoolResults
	keyvkGetQueueCheckpointData2NV
	keyvkGetQueueCheckpointDataNV
	keyvkGetRayTracingCaptureReplayShaderGroupHandlesKHR
	keyvkGetRayTracingShaderGroupHandlesKHR
	keyvkGetRayTracingShaderGroupStackSizeKHR
	keyvkGetRefreshCycleDurationGOOGLE
	keyvkGetRenderAreaGranularity
	keyvkGetSamplerOpaqueCaptureDescriptorDataEXT
	keyvkGetSemaphoreCounterValue
	keyvkGetSemaphoreFdKHR
	keyvkGetShaderInfoAMD
	keyvkGetShaderModuleCreateInfoIdentifierEXT
	keyvkGetShaderModuleIdentifierEXT
	keyvkGetSwapchainCounterEXT
	keyvkGetSwapchainImagesKHR
	keyvkGetSwapchainStatusKHR
	keyvkGetValidationCacheDataEXT
	keyvkGetVideoSessionMemoryRequirementsKHR
	keyvkImportFenceFdKHR
	keyvkImportSemaphoreFdKHR
	keyvkInitializePerformanceApiINTEL
	keyvkInvalidateMappedMemoryRanges
	keyvkMapMemory
	keyvkMergePipelineCaches
	keyvkMergeValidationCachesEXT
	keyvkQueueBeginDebugUtilsLabelEXT
	keyvkQueueBindSparse
	keyvkQueueEndDebugUtilsLabelEXT
	keyvkQueueInsertDebugUtilsLabelEXT
	keyvkQueuePresentKHR
	keyvkQueueSetPerformanceConfigurationINTEL
	keyvkQueueSubmit
	keyvkQueueSubmit2
	keyvkQueueWaitIdle
	keyvkRegisterDeviceEventEXT
	keyvkRegisterDisplayEventEXT
	keyvkReleaseDisplayEXT
	keyvkReleasePerformanceConfigurationINTEL
	keyvkReleaseProfilingLockKHR
	keyvkReleaseSwapchainImagesEXT
	keyvkResetCommandBuffer
	keyvkResetCommandPool
	keyvkResetDescriptorPool
	keyvkResetEvent
	keyvkResetFences
	keyvkResetQueryPool
	keyvkSetDebugUtilsObjectNameEXT
	keyvkSetDebugUtilsObjectTagEXT
	keyvkSetDeviceMemoryPriorityEXT
	keyvkSetEvent
	keyvkSetHdrMetadataEXT
	keyvkSetLocalDimmingAMD
	keyvkSetPrivateData
	keyvkSignalSemaphore
	keyvkSubmitDebugUtilsMessageEXT
	keyvkTrimCommandPool
	keyvkUninitializePerformanceApiINTEL
	keyvkUnmapMemory
	keyvkUpdateDescriptorSetWithTemplate
	keyvkUpdateDescriptorSets
	keyvkUpdateVideoSessionParametersKHR
	keyvkWaitForFences
	keyvkWaitForPresentKHR
	keyvkWaitSemaphores
	keyvkWriteAccelerationStructuresPropertiesKHR
	keyvkWriteMicromapsPropertiesEXT
)

func init() {
	lazyCommands[keyvkAcquireDrmDisplayEXT] = vkCommand{"vkAcquireDrmDisplayEXT", 3, true, nil}
	lazyCommands[keyvkAcquireNextImage2KHR] = vkCommand{"vkAcquireNextImage2KHR", 3, true, nil}
	lazyCommands[keyvkAcquireNextImageKHR] = vkCommand{"vkAcquireNextImageKHR", 6, true, nil}
	lazyCommands[keyvkAcquirePerformanceConfigurationINTEL] = vkCommand{"vkAcquirePerformanceConfigurationINTEL", 3, true, nil}
	lazyCommands[keyvkAcquireProfilingLockKHR] = vkCommand{"vkAcquireProfilingLockKHR", 2, true, nil}
	lazyCommands[keyvkAllocateCommandBuffers] = vkCommand{"vkAllocateCommandBuffers", 3, true, nil}
	lazyCommands[keyvkAllocateDescriptorSets] = vkCommand{"vkAllocateDescriptorSets", 3, true, nil}
	lazyCommands[keyvkAllocateMemory] = vkCommand{"vkAllocateMemory", 4, true, nil}
	lazyCommands[keyvkBeginCommandBuffer] = vkCommand{"vkBeginCommandBuffer", 2, true, nil}
	lazyCommands[keyvkBindAccelerationStructureMemoryNV] = vkCommand{"vkBindAccelerationStructureMemoryNV", 3, true, nil}
	lazyCommands[keyvkBindBufferMemory] = vkCommand{"vkBindBufferMemory", 4, true, nil}
	lazyCommands[keyvkBindBufferMemory2] = vkCommand{"vkBindBufferMemory2", 3, true, nil}
	lazyCommands[keyvkBindImageMemory] = vkCommand{"vkBindImageMemory", 4, true, nil}
	lazyCommands[keyvkBindImageMemory2] = vkCommand{"vkBindImageMemory2", 3, true, nil}
	lazyCommands[keyvkBindOpticalFlowSessionImageNV] = vkCommand{"vkBindOpticalFlowSessionImageNV", 5, true, nil}
	lazyCommands[keyvkBindVideoSessionMemoryKHR] = vkCommand{"vkBindVideoSessionMemoryKHR", 4, true, nil}
	lazyCommands[keyvkBuildAccelerationStructuresKHR] = vkCommand{"vkBuildAccelerationStructuresKHR", 5, true, nil}
	lazyCommands[keyvkBuildMicromapsEXT] = vkCommand{"vkBuildMicromapsEXT", 4, true, nil}
	lazyCommands[keyvkCmdBeginConditionalRenderingEXT] = vkCommand{"vkCmdBeginConditionalRenderingEXT", 2, true, nil}
	lazyCommands[keyvkCmdBeginDebugUtilsLabelEXT] = vkCommand{"vkCmdBeginDebugUtilsLabelEXT", 2, true, nil}
	lazyCommands[keyvkCmdBeginQuery] = vkCommand{"vkCmdBeginQuery", 4, true, nil}
	lazyCommands[keyvkCmdBeginQueryIndexedEXT] = vkCommand{"vkCmdBeginQueryIndexedEXT", 5, true, nil}
	lazyCommands[keyvkCmdBeginRenderPass] = vkCommand{"vkCmdBeginRenderPass", 3, true, nil}
	lazyCommands[keyvkCmdBeginRenderPass2] = vkCommand{"vkCmdBeginRenderPass2", 3, true, nil}
	lazyCommands[keyvkCmdBeginRendering] = vkCommand{"vkCmdBeginRendering", 2, true, nil}
	lazyCommands[keyvkCmdBeginTransformFeedbackEXT] = vkCommand{"vkCmdBeginTransformFeedbackEXT", 5, true, nil}
	lazyCommands[keyvkCmdBeginVideoCodingKHR] = vkCommand{"vkCmdBeginVideoCodingKHR", 2, true, nil}
	lazyCommands[keyvkCmdBindDescriptorBufferEmbeddedSamplersEXT] = vkCommand{"vkCmdBindDescriptorBufferEmbeddedSamplersEXT", 4, true, nil}
	lazyCommands[keyvkCmdBindDescriptorBuffersEXT] = vkCommand{"vkCmdBindDescriptorBuffersEXT", 3, true, nil}
	lazyCommands[keyvkCmdBindDescriptorSets] = vkCommand{"vkCmdBindDescriptorSets", 8, true, nil}
	lazyCommands[keyvkCmdBindIndexBuffer] = vkCommand{"vkCmdBindIndexBuffer", 4, true, nil}
	lazyCommands[keyvkCmdBindInvocationMaskHUAWEI] = vkCommand{"vkCmdBindInvocationMaskHUAWEI", 3, true, nil}
	lazyCommands[keyvkCmdBindPipeline] = vkCommand{"vkCmdBindPipeline", 3, true, nil}
	lazyCommands[keyvkCmdBindPipelineShaderGroupNV] = vkCommand{"vkCmdBindPipelineShaderGroupNV", 4, true, nil}
	lazyCommands[keyvkCmdBindShadingRateImageNV] = vkCommand{"vkCmdBindShadingRateImageNV", 3, true, nil}
	lazyCommands[keyvkCmdBindTransformFeedbackBuffersEXT] = vkCommand{"vkCmdBindTransformFeedbackBuffersEXT", 6, true, nil}
	lazyCommands[keyvkCmdBindVertexBuffers] = vkCommand{"vkCmdBindVertexBuffers", 5, true, nil}
	lazyCommands[keyvkCmdBindVertexBuffers2] = vkCommand{"vkCmdBindVertexBuffers2", 7, true, nil}
	lazyCommands[keyvkCmdBlitImage] = vkCommand{"vkCmdBlitImage", 8, true, nil}
	lazyCommands[keyvkCmdBlitImage2] = vkCommand{"vkCmdBlitImage2", 2, true, nil}
	lazyCommands[keyvkCmdBuildAccelerationStructureNV] = vkCommand{"vkCmdBuildAccelerationStructureNV", 9, true, nil}
	lazyCommands[keyvkCmdBuildAccelerationStructuresIndirectKHR] = vkCommand{"vkCmdBuildAccelerationStructuresIndirectKHR", 6, true, nil}
	lazyCommands[keyvkCmdBuildAccelerationStructuresKHR] = vkCommand{"vkCmdBuildAccelerationStructuresKHR", 4, true, nil}
	lazyCommands[keyvkCmdBuildMicromapsEXT] = vkCommand{"vkCmdBuildMicromapsEXT", 3, true, nil}
	lazyCommands[keyvkCmdClearAttachments] = vkCommand{"vkCmdClearAttachments", 5, true, nil}
	lazyCommands[keyvkCmdClearColorImage] = vkCommand{"vkCmdClearColorImage", 6, true, nil}
	lazyCommands[keyvkCmdClearDepthStencilImage] = vkCommand{"vkCmdClearDepthStencilImage", 6, true, nil}
	lazyCommands[keyvkCmdControlVideoCodingKHR] = vkCommand{"vkCmdControlVideoCodingKHR", 2, true, nil}
	lazyCommands[keyvkCmdCopyAccelerationStructureKHR] = vkCommand{"vkCmdCopyAccelerationStructureKHR", 2, true, nil}
	lazyCommands[keyvkCmdCopyAccelerationStructureNV] = vkCommand{"vkCmdCopyAccelerationStructureNV", 4, true, nil}
	lazyCommands[keyvkCmdCopyAccelerationStructureToMemoryKHR] = vkCommand{"vkCmdCopyAccelerationStructureToMemoryKHR", 2, true, nil}
	lazyCommands[keyvkCmdCopyBuffer] = vkCommand{"vkCmdCopyBuffer", 5, true, nil}
	lazyCommands[keyvkCmdCopyBuffer2] = vkCommand{"vkCmdCopyBuffer2", 2, true, nil}
	lazyCommands[keyvkCmdCopyBufferToImage] = vkCommand{"vkCmdCopyBufferToImage", 6, true, nil}
	lazyCommands[keyvkCmdCopyBufferToImage2] = vkCommand{"vkCmdCopyBufferToImage2", 2, true, nil}
	lazyCommands[keyvkCmdCopyImage] = vkCommand{"vkCmdCopyImage", 7, true, nil}
	lazyCommands[keyvkCmdCopyImage2] = vkCommand{"vkCmdCopyImage2", 2, true, nil}
	lazyCommands[keyvkCmdCopyImageToBuffer] = vkCommand{"vkCmdCopyImageToBuffer", 6, true, nil}
	lazyCommands[keyvkCmdCopyImageToBuffer2] = vkCommand{"vkCmdCopyImageToBuffer2", 2, true, nil}
	lazyCommands[keyvkCmdCopyMemoryIndirectNV] = vkCommand{"vkCmdCopyMemoryIndirectNV", 4, true, nil}
	lazyCommands[keyvkCmdCopyMemoryToAccelerationStructureKHR] = vkCommand{"vkCmdCopyMemoryToAccelerationStructureKHR", 2, true, nil}
	lazyCommands[keyvkCmdCopyMemoryToImageIndirectNV] = vkCommand{"vkCmdCopyMemoryToImageIndirectNV", 7, true, nil}
	lazyCommands[keyvkCmdCopyMemoryToMicromapEXT] = vkCommand{"vkCmdCopyMemoryToMicromapEXT", 2, true, nil}
	lazyCommands[keyvkCmdCopyMicromapEXT] = vkCommand{"vkCmdCopyMicromapEXT", 2, true, nil}
	lazyCommands[keyvkCmdCopyMicromapToMemoryEXT] = vkCommand{"vkCmdCopyMicromapToMemoryEXT", 2, true, nil}
	lazyCommands[keyvkCmdCopyQueryPoolResults] = vkCommand{"vkCmdCopyQueryPoolResults", 8, true, nil}
	lazyCommands[keyvkCmdCuLaunchKernelNVX] = vkCommand{"vkCmdCuLaunchKernelNVX", 2, true, nil}
	lazyCommands[keyvkCmdDebugMarkerBeginEXT] = vkCommand{"vkCmdDebugMarkerBeginEXT", 2, true, nil}
	lazyCommands[keyvkCmdDebugMarkerEndEXT] = vkCommand{"vkCmdDebugMarkerEndEXT", 1, true, nil}
	lazyCommands[keyvkCmdDebugMarkerInsertEXT] = vkCommand{"vkCmdDebugMarkerInsertEXT", 2, true, nil}
	lazyCommands[keyvkCmdDecodeVideoKHR] = vkCommand{"vkCmdDecodeVideoKHR", 2, true, nil}
	lazyCommands[keyvkCmdDecompressMemoryIndirectCountNV] = vkCommand{"vkCmdDecompressMemoryIndirectCountNV", 4, true, nil}
	lazyCommands[keyvkCmdDecompressMemoryNV] = vkCommand{"vkCmdDecompressMemoryNV", 3, true, nil}
	lazyCommands[keyvkCmdDispatch] = vkCommand{"vkCmdDispatch", 4, true, nil}
	lazyCommands[keyvkCmdDispatchBase] = vkCommand{"vkCmdDispatchBase", 7, true, nil}
	lazyCommands[keyvkCmdDispatchIndirect] = vkCommand{"vkCmdDispatchIndirect", 3, true, nil}
	lazyCommands[keyvkCmdDraw] = vkCommand{"vkCmdDraw", 5, true, nil}
	lazyCommands[keyvkCmdDrawClusterHUAWEI] = vkCommand{"vkCmdDrawClusterHUAWEI", 4, true, nil}
	lazyCommands[keyvkCmdDrawClusterIndirectHUAWEI] = vkCommand{"vkCmdDrawClusterIndirectHUAWEI", 3, true, nil}
	lazyCommands[keyvkCmdDrawIndexed] = vkCommand{"vkCmdDrawIndexed", 6, true, nil}
	lazyCommands[keyvkCmdDrawIndexedIndirect] = vkCommand{"vkCmdDrawIndexedIndirect", 5, true, nil}
	lazyCommands[keyvkCmdDrawIndexedIndirectCount] = vkCommand{"vkCmdDrawIndexedIndirectCount", 7, true, nil}
	lazyCommands[keyvkCmdDrawIndirect] = vkCommand{"vkCmdDrawIndirect", 5, true, nil}
	lazyCommands[keyvkCmdDrawIndirectByteCountEXT] = vkCommand{"vkCmdDrawIndirectByteCountEXT", 7, true, nil}
	lazyCommands[keyvkCmdDrawIndirectCount] = vkCommand{"vkCmdDrawIndirectCount", 7, true, nil}
	lazyCommands[keyvkCmdDrawMeshTasksEXT] = vkCommand{"vkCmdDrawMeshTasksEXT", 4, true, nil}
	lazyCommands[keyvkCmdDrawMeshTasksIndirectCountEXT] = vkCommand{"vkCmdDrawMeshTasksIndirectCountEXT", 7, true, nil}
	lazyCommands[keyvkCmdDrawMeshTasksIndirectCountNV] = vkCommand{"vkCmdDrawMeshTasksIndirectCountNV", 7, true, nil}
	lazyCommands[keyvkCmdDrawMeshTasksIndirectEXT] = vkCommand{"vkCmdDrawMeshTasksIndirectEXT", 5, true, nil}
	lazyCommands[keyvkCmdDrawMeshTasksIndirectNV] = vkCommand{"vkCmdDrawMeshTasksIndirectNV", 5, true, nil}
	lazyCommands[keyvkCmdDrawMeshTasksNV] = vkCommand{"vkCmdDrawMeshTasksNV", 3, true, nil}
	lazyCommands[keyvkCmdDrawMultiEXT] = vkCommand{"vkCmdDrawMultiEXT", 6, true, nil}
	lazyCommands[keyvkCmdDrawMultiIndexedEXT] = vkCommand{"vkCmdDrawMultiIndexedEXT", 7, true, nil}
	lazyCommands[keyvkCmdEndConditionalRenderingEXT] = vkCommand{"vkCmdEndConditionalRenderingEXT", 1, true, nil}
	lazyCommands[keyvkCmdEndDebugUtilsLabelEXT] = vkCommand{"vkCmdEndDebugUtilsLabelEXT", 1, true, nil}
	lazyCommands[keyvkCmdEndQuery] = vkCommand{"vkCmdEndQuery", 3, true, nil}
	lazyCommands[keyvkCmdEndQueryIndexedEXT] = vkCommand{"vkCmdEndQueryIndexedEXT", 4, true, nil}
	lazyCommands[keyvkCmdEndRenderPass] = vkCommand{"vkCmdEndRenderPass", 1, true, nil}
	lazyCommands[keyvkCmdEndRenderPass2] = vkCommand{"vkCmdEndRenderPass2", 2, true, nil}
	lazyCommands[keyvkCmdEndRendering] = vkCommand{"vkCmdEndRendering", 1, true, nil}
	lazyCommands[keyvkCmdEndTransformFeedbackEXT] = vkCommand{"vkCmdEndTransformFeedbackEXT", 5, true, nil}
	lazyCommands[keyvkCmdEndVideoCodingKHR] = vkCommand{"vkCmdEndVideoCodingKHR", 2, true, nil}
	lazyCommands[keyvkCmdExecuteCommands] = vkCommand{"vkCmdExecuteCommands", 3, true, nil}
	lazyCommands[keyvkCmdExecuteGeneratedCommandsNV] = vkCommand{"vkCmdExecuteGeneratedCommandsNV", 3, true, nil}
	lazyCommands[keyvkCmdFillBuffer] = vkCommand{"vkCmdFillBuffer", 5, true, nil}
	lazyCommands[keyvkCmdInsertDebugUtilsLabelEXT] = vkCommand{"vkCmdInsertDebugUtilsLabelEXT", 2, true, nil}
	lazyCommands[keyvkCmdNextSubpass] = vkCommand{"vkCmdNextSubpass", 2, true, nil}
	lazyCommands[keyvkCmdNextSubpass2] = vkCommand{"vkCmdNextSubpass2", 3, true, nil}
	lazyCommands[keyvkCmdOpticalFlowExecuteNV] = vkCommand{"vkCmdOpticalFlowExecuteNV", 3, true, nil}
	lazyCommands[keyvkCmdPipelineBarrier] = vkCommand{"vkCmdPipelineBarrier", 10, true, nil}
	lazyCommands[keyvkCmdPipelineBarrier2] = vkCommand{"vkCmdPipelineBarrier2", 2, true, nil}
	lazyCommands[keyvkCmdPreprocessGeneratedCommandsNV] = vkCommand{"vkCmdPreprocessGeneratedCommandsNV", 2, true, nil}
	lazyCommands[keyvkCmdPushConstants] = vkCommand{"vkCmdPushConstants", 6, true, nil}
	lazyCommands[keyvkCmdPushDescriptorSetKHR] = vkCommand{"vkCmdPushDescriptorSetKHR", 6, true, nil}
	lazyCommands[keyvkCmdPushDescriptorSetWithTemplateKHR] = vkCommand{"vkCmdPushDescriptorSetWithTemplateKHR", 5, true, nil}
	lazyCommands[keyvkCmdResetEvent] = vkCommand{"vkCmdResetEvent", 3, true, nil}
	lazyCommands[keyvkCmdResetEvent2] = vkCommand{"vkCmdResetEvent2", 3, true, nil}
	lazyCommands[keyvkCmdResetQueryPool] = vkCommand{"vkCmdResetQueryPool", 4, true, nil}
	lazyCommands[keyvkCmdResolveImage] = vkCommand{"vkCmdResolveImage", 7, true, nil}
	lazyCommands[keyvkCmdResolveImage2] = vkCommand{"vkCmdResolveImage2", 2, true, nil}
	lazyCommands[keyvkCmdSetAlphaToCoverageEnableEXT] = vkCommand{"vkCmdSetAlphaToCoverageEnableEXT", 2, true, nil}
	lazyCommands[keyvkCmdSetAlphaToOneEnableEXT] = vkCommand{"vkCmdSetAlphaToOneEnableEXT", 2, true, nil}
	lazyCommands[keyvkCmdSetBlendConstants] = vkCommand{"vkCmdSetBlendConstants", 2, true, nil}
	lazyCommands[keyvkCmdSetCheckpointNV] = vkCommand{"vkCmdSetCheckpointNV", 2, true, nil}
	lazyCommands[keyvkCmdSetCoarseSampleOrderNV] = vkCommand{"vkCmdSetCoarseSampleOrderNV", 4, true, nil}
	lazyCommands[keyvkCmdSetColorBlendAdvancedEXT] = vkCommand{"vkCmdSetColorBlendAdvancedEXT", 4, true, nil}
	lazyCommands[keyvkCmdSetColorBlendEnableEXT] = vkCommand{"vkCmdSetColorBlendEnableEXT", 4, true, nil}
	lazyCommands[keyvkCmdSetColorBlendEquationEXT] = vkCommand{"vkCmdSetColorBlendEquationEXT", 4, true, nil}
	lazyCommands[keyvkCmdSetColorWriteEnableEXT] = vkCommand{"vkCmdSetColorWriteEnableEXT", 3, true, nil}
	lazyCommands[keyvkCmdSetColorWriteMaskEXT] = vkCommand{"vkCmdSetColorWriteMaskEXT", 4, true, nil}
	lazyCommands[keyvkCmdSetConservativeRasterizationModeEXT] = vkCommand{"vkCmdSetConservativeRasterizationModeEXT", 2, true, nil}
	lazyCommands[keyvkCmdSetCoverageModulationModeNV] = vkCommand{"vkCmdSetCoverageModulationModeNV", 2, true, nil}
	lazyCommands[keyvkCmdSetCoverageModulationTableEnableNV] = vkCommand{"vkCmdSetCoverageModulationTableEnableNV", 2, true, nil}
	lazyCommands[keyvkCmdSetCoverageModulationTableNV] = vkCommand{"vkCmdSetCoverageModulationTableNV", 3, true, nil}
	lazyCommands[keyvkCmdSetCoverageReductionModeNV] = vkCommand{"vkCmdSetCoverageReductionModeNV", 2, true, nil}
	lazyCommands[keyvkCmdSetCoverageToColorEnableNV] = vkCommand{"vkCmdSetCoverageToColorEnableNV", 2, true, nil}
	lazyCommands[keyvkCmdSetCoverageToColorLocationNV] = vkCommand{"vkCmdSetCoverageToColorLocationNV", 2, true, nil}
	lazyCommands[keyvkCmdSetCullMode] = vkCommand{"vkCmdSetCullMode", 2, true, nil}
	lazyCommands[keyvkCmdSetDepthBias] = vkCommand{"vkCmdSetDepthBias", 4, true, nil}
	lazyCommands[keyvkCmdSetDepthBiasEnable] = vkCommand{"vkCmdSetDepthBiasEnable", 2, true, nil}
	lazyCommands[keyvkCmdSetDepthBounds] = vkCommand{"vkCmdSetDepthBounds", 3, true, nil}
	lazyCommands[keyvkCmdSetDepthBoundsTestEnable] = vkCommand{"vkCmdSetDepthBoundsTestEnable", 2, true, nil}
	lazyCommands[keyvkCmdSetDepthClampEnableEXT] = vkCommand{"vkCmdSetDepthClampEnableEXT", 2, true, nil}
	lazyCommands[keyvkCmdSetDepthClipEnableEXT] = vkCommand{"vkCmdSetDepthClipEnableEXT", 2, true, nil}
	lazyCommands[keyvkCmdSetDepthClipNegativeOneToOneEXT] = vkCommand{"vkCmdSetDepthClipNegativeOneToOneEXT", 2, true, nil}
	lazyCommands[keyvkCmdSetDepthCompareOp] = vkCommand{"vkCmdSetDepthCompareOp", 2, true, nil}
	lazyCommands[keyvkCmdSetDepthTestEnable] = vkCommand{"vkCmdSetDepthTestEnable", 2, true, nil}
	lazyCommands[keyvkCmdSetDepthWriteEnable] = vkCommand{"vkCmdSetDepthWriteEnable", 2, true, nil}
	lazyCommands[keyvkCmdSetDescriptorBufferOffsetsEXT] = vkCommand{"vkCmdSetDescriptorBufferOffsetsEXT", 7, true, nil}
	lazyCommands[keyvkCmdSetDeviceMask] = vkCommand{"vkCmdSetDeviceMask", 2, true, nil}
	lazyCommands[keyvkCmdSetDiscardRectangleEXT] = vkCommand{"vkCmdSetDiscardRectangleEXT", 4, true, nil}
	lazyCommands[keyvkCmdSetEvent] = vkCommand{"vkCmdSetEvent", 3, true, nil}
	lazyCommands[keyvkCmdSetEvent2] = vkCommand{"vkCmdSetEvent2", 3, true, nil}
	lazyCommands[keyvkCmdSetExclusiveScissorNV] = vkCommand{"vkCmdSetExclusiveScissorNV", 4, true, nil}
	lazyCommands[keyvkCmdSetExtraPrimitiveOverestimationSizeEXT] = vkCommand{"vkCmdSetExtraPrimitiveOverestimationSizeEXT", 2, true, nil}
	lazyCommands[keyvkCmdSetFragmentShadingRateEnumNV] = vkCommand{"vkCmdSetFragmentShadingRateEnumNV", 3, true, nil}
	lazyCommands[keyvkCmdSetFragmentShadingRateKHR] = vkCommand{"vkCmdSetFragmentShadingRateKHR", 3, true, nil}
	lazyCommands[keyvkCmdSetFrontFace] = vkCommand{"vkCmdSetFrontFace", 2, true, nil}
	lazyCommands[keyvkCmdSetLineRasterizationModeEXT] = vkCommand{"vkCmdSetLineRasterizationModeEXT", 2, true, nil}
	lazyCommands[keyvkCmdSetLineStippleEXT] = vkCommand{"vkCmdSetLineStippleEXT", 3, true, nil}
	lazyCommands[keyvkCmdSetLineStippleEnableEXT] = vkCommand{"vkCmdSetLineStippleEnableEXT", 2, true, nil}
	lazyCommands[keyvkCmdSetLineWidth] = vkCommand{"vkCmdSetLineWidth", 2, true, nil}
	lazyCommands[keyvkCmdSetLogicOpEXT] = vkCommand{"vkCmdSetLogicOpEXT", 2, true, nil}
	lazyCommands[keyvkCmdSetLogicOpEnableEXT] = vkCommand{"vkCmdSetLogicOpEnableEXT", 2, true, nil}
	lazyCommands[keyvkCmdSetPatchControlPointsEXT] = vkCommand{"vkCmdSetPatchControlPointsEXT", 2, true, nil}
	lazyCommands[keyvkCmdSetPerformanceMarkerINTEL] = vkCommand{"vkCmdSetPerformanceMarkerINTEL", 2, true, nil}
	lazyCommands[keyvkCmdSetPerformanceOverrideINTEL] = vkCommand{"vkCmdSetPerformanceOverrideINTEL", 2, true, nil}
	lazyCommands[keyvkCmdSetPerformanceStreamMarkerINTEL] = vkCommand{"vkCmdSetPerformanceStreamMarkerINTEL", 2, true, nil}
	lazyCommands[keyvkCmdSetPolygonModeEXT] = vkCommand{"vkCmdSetPolygonModeEXT", 2, true, nil}
	lazyCommands[keyvkCmdSetPrimitiveRestartEnable] = vkCommand{"vkCmdSetPrimitiveRestartEnable", 2, true, nil}
	lazyCommands[keyvkCmdSetPrimitiveTopology] = vkCommand{"vkCmdSetPrimitiveTopology", 2, true, nil}
	lazyCommands[keyvkCmdSetProvokingVertexModeEXT] = vkCommand{"vkCmdSetProvokingVertexModeEXT", 2, true, nil}
	lazyCommands[keyvkCmdSetRasterizationSamplesEXT] = vkCommand{"vkCmdSetRasterizationSamplesEXT", 2, true, nil}
	lazyCommands[keyvkCmdSetRasterizationStreamEXT] = vkCommand{"vkCmdSetRasterizationStreamEXT", 2, true, nil}
	lazyCommands[keyvkCmdSetRasterizerDiscardEnable] = vkCommand{"vkCmdSetRasterizerDiscardEnable", 2, true, nil}
	lazyCommands[keyvkCmdSetRayTracingPipelineStackSizeKHR] = vkCommand{"vkCmdSetRayTracingPipelineStackSizeKHR", 2, true, nil}
	lazyCommands[keyvkCmdSetRepresentativeFragmentTestEnableNV] = vkCommand{"vkCmdSetRepresentativeFragmentTestEnableNV", 2, true, nil}
	lazyCommands[keyvkCmdSetSampleLocationsEXT] = vkCommand{"vkCmdSetSampleLocationsEXT", 2, true, nil}
	lazyCommands[keyvkCmdSetSampleLocationsEnableEXT] = vkCommand{"vkCmdSetSampleLocationsEnableEXT", 2, true, nil}
	lazyCommands[keyvkCmdSetSampleMaskEXT] = vkCommand{"vkCmdSetSampleMaskEXT", 3, true, nil}
	lazyCommands[keyvkCmdSetScissor] = vkCommand{"vkCmdSetScissor", 4, true, nil}
	lazyCommands[keyvkCmdSetScissorWithCount] = vkCommand{"vkCmdSetScissorWithCount", 3, true, nil}
	lazyCommands[keyvkCmdSetShadingRateImageEnableNV] = vkCommand{"vkCmdSetShadingRateImageEnableNV", 2, true, nil}
	lazyCommands[keyvkCmdSetStencilCompareMask] = vkCommand{"vkCmdSetStencilCompareMask", 3, true, nil}
	lazyCommands[keyvkCmdSetStencilOp] = vkCommand{"vkCmdSetStencilOp", 6, true, nil}
	lazyCommands[keyvkCmdSetStencilReference] = vkCommand{"vkCmdSetStencilReference", 3, true, nil}
	lazyCommands[keyvkCmdSetStencilTestEnable] = vkCommand{"vkCmdSetStencilTestEnable", 2, true, nil}
	lazyCommands[keyvkCmdSetStencilWriteMask] = vkCommand{"vkCmdSetStencilWriteMask", 3, true, nil}
	lazyCommands[keyvkCmdSetTessellationDomainOriginEXT] = vkCommand{"vkCmdSetTessellationDomainOriginEXT", 2, true, nil}
	lazyCommands[keyvkCmdSetVertexInputEXT] = vkCommand{"vkCmdSetVertexInputEXT", 5, true, nil}
	lazyCommands[keyvkCmdSetViewport] = vkCommand{"vkCmdSetViewport", 4, true, nil}
	lazyCommands[keyvkCmdSetViewportShadingRatePaletteNV] = vkCommand{"vkCmdSetViewportShadingRatePaletteNV", 4, true, nil}
	lazyCommands[keyvkCmdSetViewportSwizzleNV] = vkCommand{"vkCmdSetViewportSwizzleNV", 4, true, nil}
	lazyCommands[keyvkCmdSetViewportWScalingEnableNV] = vkCommand{"vkCmdSetViewportWScalingEnableNV", 2, true, nil}
	lazyCommands[keyvkCmdSetViewportWScalingNV] = vkCommand{"vkCmdSetViewportWScalingNV", 4, true, nil}
	lazyCommands[keyvkCmdSetViewportWithCount] = vkCommand{"vkCmdSetViewportWithCount", 3, true, nil}
	lazyCommands[keyvkCmdSubpassShadingHUAWEI] = vkCommand{"vkCmdSubpassShadingHUAWEI", 1, true, nil}
	lazyCommands[keyvkCmdTraceRaysIndirect2KHR] = vkCommand{"vkCmdTraceRaysIndirect2KHR", 2, true, nil}
	lazyCommands[keyvkCmdTraceRaysIndirectKHR] = vkCommand{"vkCmdTraceRaysIndirectKHR", 6, true, nil}
	lazyCommands[keyvkCmdTraceRaysKHR] = vkCommand{"vkCmdTraceRaysKHR", 8, true, nil}
	lazyCommands[keyvkCmdTraceRaysNV] = vkCommand{"vkCmdTraceRaysNV", 15, true, nil}
	lazyCommands[keyvkCmdUpdateBuffer] = vkCommand{"vkCmdUpdateBuffer", 5, true, nil}
	lazyCommands[keyvkCmdWaitEvents] = vkCommand{"vkCmdWaitEvents", 11, true, nil}
	lazyCommands[keyvkCmdWaitEvents2] = vkCommand{"vkCmdWaitEvents2", 4, true, nil}
	lazyCommands[keyvkCmdWriteAccelerationStructuresPropertiesKHR] = vkCommand{"vkCmdWriteAccelerationStructuresPropertiesKHR", 6, true, nil}
	lazyCommands[keyvkCmdWriteAccelerationStructuresPropertiesNV] = vkCommand{"vkCmdWriteAccelerationStructuresPropertiesNV", 6, true, nil}
	lazyCommands[keyvkCmdWriteBufferMarker2AMD] = vkCommand{"vkCmdWriteBufferMarker2AMD", 5, true, nil}
	lazyCommands[keyvkCmdWriteBufferMarkerAMD] = vkCommand{"vkCmdWriteBufferMarkerAMD", 5, true, nil}
	lazyCommands[keyvkCmdWriteMicromapsPropertiesEXT] = vkCommand{"vkCmdWriteMicromapsPropertiesEXT", 6, true, nil}
	lazyCommands[keyvkCmdWriteTimestamp] = vkCommand{"vkCmdWriteTimestamp", 4, true, nil}
	lazyCommands[keyvkCmdWriteTimestamp2] = vkCommand{"vkCmdWriteTimestamp2", 4, true, nil}
	lazyCommands[keyvkCompileDeferredNV] = vkCommand{"vkCompileDeferredNV", 3, true, nil}
	lazyCommands[keyvkCopyAccelerationStructureKHR] = vkCommand{"vkCopyAccelerationStructureKHR", 3, true, nil}
	lazyCommands[keyvkCopyAccelerationStructureToMemoryKHR] = vkCommand{"vkCopyAccelerationStructureToMemoryKHR", 3, true, nil}
	lazyCommands[keyvkCopyMemoryToAccelerationStructureKHR] = vkCommand{"vkCopyMemoryToAccelerationStructureKHR", 3, true, nil}
	lazyCommands[keyvkCopyMemoryToMicromapEXT] = vkCommand{"vkCopyMemoryToMicromapEXT", 3, true, nil}
	lazyCommands[keyvkCopyMicromapEXT] = vkCommand{"vkCopyMicromapEXT", 3, true, nil}
	lazyCommands[keyvkCopyMicromapToMemoryEXT] = vkCommand{"vkCopyMicromapToMemoryEXT", 3, true, nil}
	lazyCommands[keyvkCreateAccelerationStructureKHR] = vkCommand{"vkCreateAccelerationStructureKHR", 4, true, nil}
	lazyCommands[keyvkCreateAccelerationStructureNV] = vkCommand{"vkCreateAccelerationStructureNV", 4, true, nil}
	lazyCommands[keyvkCreateBuffer] = vkCommand{"vkCreateBuffer", 4, true, nil}
	lazyCommands[keyvkCreateBufferView] = vkCommand{"vkCreateBufferView", 4, true, nil}
	lazyCommands[keyvkCreateCommandPool] = vkCommand{"vkCreateCommandPool", 4, true, nil}
	lazyCommands[keyvkCreateComputePipelines] = vkCommand{"vkCreateComputePipelines", 6, true, nil}
	lazyCommands[keyvkCreateCuFunctionNVX] = vkCommand{"vkCreateCuFunctionNVX", 4, true, nil}
	lazyCommands[keyvkCreateCuModuleNVX] = vkCommand{"vkCreateCuModuleNVX", 4, true, nil}
	lazyCommands[keyvkCreateDebugReportCallbackEXT] = vkCommand{"vkCreateDebugReportCallbackEXT", 4, true, nil}
	lazyCommands[keyvkCreateDebugUtilsMessengerEXT] = vkCommand{"vkCreateDebugUtilsMessengerEXT", 4, true, nil}
	lazyCommands[keyvkCreateDeferredOperationKHR] = vkCommand{"vkCreateDeferredOperationKHR", 3, true, nil}
	lazyCommands[keyvkCreateDescriptorPool] = vkCommand{"vkCreateDescriptorPool", 4, true, nil}
	lazyCommands[keyvkCreateDescriptorSetLayout] = vkCommand{"vkCreateDescriptorSetLayout", 4, true, nil}
	lazyCommands[keyvkCreateDescriptorUpdateTemplate] = vkCommand{"vkCreateDescriptorUpdateTemplate", 4, true, nil}
	lazyCommands[keyvkCreateDevice] = vkCommand{"vkCreateDevice", 4, true, nil}
	lazyCommands[keyvkCreateDisplayModeKHR] = vkCommand{"vkCreateDisplayModeKHR", 5, true, nil}
	lazyCommands[keyvkCreateDisplayPlaneSurfaceKHR] = vkCommand{"vkCreateDisplayPlaneSurfaceKHR", 4, true, nil}
	lazyCommands[keyvkCreateEvent] = vkCommand{"vkCreateEvent", 4, true, nil}
	lazyCommands[keyvkCreateFence] = vkCommand{"vkCreateFence", 4, true, nil}
	lazyCommands[keyvkCreateFramebuffer] = vkCommand{"vkCreateFramebuffer", 4, true, nil}
	lazyCommands[keyvkCreateGraphicsPipelines] = vkCommand{"vkCreateGraphicsPipelines", 6, true, nil}
	lazyCommands[keyvkCreateHeadlessSurfaceEXT] = vkCommand{"vkCreateHeadlessSurfaceEXT", 4, true, nil}
	lazyCommands[keyvkCreateImage] = vkCommand{"vkCreateImage", 4, true, nil}
	lazyCommands[keyvkCreateImageView] = vkCommand{"vkCreateImageView", 4, true, nil}
	lazyCommands[keyvkCreateIndirectCommandsLayoutNV] = vkCommand{"vkCreateIndirectCommandsLayoutNV", 4, true, nil}
	lazyCommands[keyvkCreateInstance] = vkCommand{"vkCreateInstance", 3, true, nil}
	lazyCommands[keyvkCreateMicromapEXT] = vkCommand{"vkCreateMicromapEXT", 4, true, nil}
	lazyCommands[keyvkCreateOpticalFlowSessionNV] = vkCommand{"vkCreateOpticalFlowSessionNV", 4, true, nil}
	lazyCommands[keyvkCreatePipelineCache] = vkCommand{"vkCreatePipelineCache", 4, true, nil}
	lazyCommands[keyvkCreatePipelineLayout] = vkCommand{"vkCreatePipelineLayout", 4, true, nil}
	lazyCommands[keyvkCreatePrivateDataSlot] = vkCommand{"vkCreatePrivateDataSlot", 4, true, nil}
	lazyCommands[keyvkCreateQueryPool] = vkCommand{"vkCreateQueryPool", 4, true, nil}
	lazyCommands[keyvkCreateRayTracingPipelinesKHR] = vkCommand{"vkCreateRayTracingPipelinesKHR", 7, true, nil}
	lazyCommands[keyvkCreateRayTracingPipelinesNV] = vkCommand{"vkCreateRayTracingPipelinesNV", 6, true, nil}
	lazyCommands[keyvkCreateRenderPass] = vkCommand{"vkCreateRenderPass", 4, true, nil}
	lazyCommands[keyvkCreateRenderPass2] = vkCommand{"vkCreateRenderPass2", 4, true, nil}
	lazyCommands[keyvkCreateSampler] = vkCommand{"vkCreateSampler", 4, true, nil}
	lazyCommands[keyvkCreateSamplerYcbcrConversion] = vkCommand{"vkCreateSamplerYcbcrConversion", 4, true, nil}
	lazyCommands[keyvkCreateSemaphore] = vkCommand{"vkCreateSemaphore", 4, true, nil}
	lazyCommands[keyvkCreateShaderModule] = vkCommand{"vkCreateShaderModule", 4, true, nil}
	lazyCommands[keyvkCreateSharedSwapchainsKHR] = vkCommand{"vkCreateSharedSwapchainsKHR", 5, true, nil}
	lazyCommands[keyvkCreateSwapchainKHR] = vkCommand{"vkCreateSwapchainKHR", 4, true, nil}
	lazyCommands[keyvkCreateValidationCacheEXT] = vkCommand{"vkCreateValidationCacheEXT", 4, true, nil}
	lazyCommands[keyvkCreateVideoSessionKHR] = vkCommand{"vkCreateVideoSessionKHR", 4, true, nil}
	lazyCommands[keyvkCreateVideoSessionParametersKHR] = vkCommand{"vkCreateVideoSessionParametersKHR", 4, true, nil}
	lazyCommands[keyvkDebugMarkerSetObjectNameEXT] = vkCommand{"vkDebugMarkerSetObjectNameEXT", 2, true, nil}
	lazyCommands[keyvkDebugMarkerSetObjectTagEXT] = vkCommand{"vkDebugMarkerSetObjectTagEXT", 2, true, nil}
	lazyCommands[keyvkDebugReportMessageEXT] = vkCommand{"vkDebugReportMessageEXT", 8, true, nil}
	lazyCommands[keyvkDeferredOperationJoinKHR] = vkCommand{"vkDeferredOperationJoinKHR", 2, true, nil}
	lazyCommands[keyvkDestroyAccelerationStructureKHR] = vkCommand{"vkDestroyAccelerationStructureKHR", 3, true, nil}
	lazyCommands[keyvkDestroyAccelerationStructureNV] = vkCommand{"vkDestroyAccelerationStructureNV", 3, true, nil}
	lazyCommands[keyvkDestroyBuffer] = vkCommand{"vkDestroyBuffer", 3, true, nil}
	lazyCommands[keyvkDestroyBufferView] = vkCommand{"vkDestroyBufferView", 3, true, nil}
	lazyCommands[keyvkDestroyCommandPool] = vkCommand{"vkDestroyCommandPool", 3, true, nil}
	lazyCommands[keyvkDestroyCuFunctionNVX] = vkCommand{"vkDestroyCuFunctionNVX", 3, true, nil}
	lazyCommands[keyvkDestroyCuModuleNVX] = vkCommand{"vkDestroyCuModuleNVX", 3, true, nil}
	lazyCommands[keyvkDestroyDebugReportCallbackEXT] = vkCommand{"vkDestroyDebugReportCallbackEXT", 3, true, nil}
	lazyCommands[keyvkDestroyDebugUtilsMessengerEXT] = vkCommand{"vkDestroyDebugUtilsMessengerEXT", 3, true, nil}
	lazyCommands[keyvkDestroyDeferredOperationKHR] = vkCommand{"vkDestroyDeferredOperationKHR", 3, true, nil}
	lazyCommands[keyvkDestroyDescriptorPool] = vkCommand{"vkDestroyDescriptorPool", 3, true, nil}
	lazyCommands[keyvkDestroyDescriptorSetLayout] = vkCommand{"vkDestroyDescriptorSetLayout", 3, true, nil}
	lazyCommands[keyvkDestroyDescriptorUpdateTemplate] = vkCommand{"vkDestroyDescriptorUpdateTemplate", 3, true, nil}
	lazyCommands[keyvkDestroyDevice] = vkCommand{"vkDestroyDevice", 2, true, nil}
	lazyCommands[keyvkDestroyEvent] = vkCommand{"vkDestroyEvent", 3, true, nil}
	lazyCommands[keyvkDestroyFence] = vkCommand{"vkDestroyFence", 3, true, nil}
	lazyCommands[keyvkDestroyFramebuffer] = vkCommand{"vkDestroyFramebuffer", 3, true, nil}
	lazyCommands[keyvkDestroyImage] = vkCommand{"vkDestroyImage", 3, true, nil}
	lazyCommands[keyvkDestroyImageView] = vkCommand{"vkDestroyImageView", 3, true, nil}
	lazyCommands[keyvkDestroyIndirectCommandsLayoutNV] = vkCommand{"vkDestroyIndirectCommandsLayoutNV", 3, true, nil}
	lazyCommands[keyvkDestroyInstance] = vkCommand{"vkDestroyInstance", 2, true, nil}
	lazyCommands[keyvkDestroyMicromapEXT] = vkCommand{"vkDestroyMicromapEXT", 3, true, nil}
	lazyCommands[keyvkDestroyOpticalFlowSessionNV] = vkCommand{"vkDestroyOpticalFlowSessionNV", 3, true, nil}
	lazyCommands[keyvkDestroyPipeline] = vkCommand{"vkDestroyPipeline", 3, true, nil}
	lazyCommands[keyvkDestroyPipelineCache] = vkCommand{"vkDestroyPipelineCache", 3, true, nil}
	lazyCommands[keyvkDestroyPipelineLayout] = vkCommand{"vkDestroyPipelineLayout", 3, true, nil}
	lazyCommands[keyvkDestroyPrivateDataSlot] = vkCommand{"vkDestroyPrivateDataSlot", 3, true, nil}
	lazyCommands[keyvkDestroyQueryPool] = vkCommand{"vkDestroyQueryPool", 3, true, nil}
	lazyCommands[keyvkDestroyRenderPass] = vkCommand{"vkDestroyRenderPass", 3, true, nil}
	lazyCommands[keyvkDestroySampler] = vkCommand{"vkDestroySampler", 3, true, nil}
	lazyCommands[keyvkDestroySamplerYcbcrConversion] = vkCommand{"vkDestroySamplerYcbcrConversion", 3, true, nil}
	lazyCommands[keyvkDestroySemaphore] = vkCommand{"vkDestroySemaphore", 3, true, nil}
	lazyCommands[keyvkDestroyShaderModule] = vkCommand{"vkDestroyShaderModule", 3, true, nil}
	lazyCommands[keyvkDestroySurfaceKHR] = vkCommand{"vkDestroySurfaceKHR", 3, true, nil}
	lazyCommands[keyvkDestroySwapchainKHR] = vkCommand{"vkDestroySwapchainKHR", 3, true, nil}
	lazyCommands[keyvkDestroyValidationCacheEXT] = vkCommand{"vkDestroyValidationCacheEXT", 3, true, nil}
	lazyCommands[keyvkDestroyVideoSessionKHR] = vkCommand{"vkDestroyVideoSessionKHR", 3, true, nil}
	lazyCommands[keyvkDestroyVideoSessionParametersKHR] = vkCommand{"vkDestroyVideoSessionParametersKHR", 3, true, nil}
	lazyCommands[keyvkDeviceWaitIdle] = vkCommand{"vkDeviceWaitIdle", 1, true, nil}
	lazyCommands[keyvkDisplayPowerControlEXT] = vkCommand{"vkDisplayPowerControlEXT", 3, true, nil}
	lazyCommands[keyvkEndCommandBuffer] = vkCommand{"vkEndCommandBuffer", 1, true, nil}
	lazyCommands[keyvkEnumerateDeviceExtensionProperties] = vkCommand{"vkEnumerateDeviceExtensionProperties", 4, true, nil}
	lazyCommands[keyvkEnumerateDeviceLayerProperties] = vkCommand{"vkEnumerateDeviceLayerProperties", 3, true, nil}
	lazyCommands[keyvkEnumerateInstanceExtensionProperties] = vkCommand{"vkEnumerateInstanceExtensionProperties", 3, true, nil}
	lazyCommands[keyvkEnumerateInstanceLayerProperties] = vkCommand{"vkEnumerateInstanceLayerProperties", 2, true, nil}
	lazyCommands[keyvkEnumerateInstanceVersion] = vkCommand{"vkEnumerateInstanceVersion", 1, true, nil}
	lazyCommands[keyvkEnumeratePhysicalDeviceGroups] = vkCommand{"vkEnumeratePhysicalDeviceGroups", 3, true, nil}
	lazyCommands[keyvkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR] = vkCommand{"vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR", 5, true, nil}
	lazyCommands[keyvkEnumeratePhysicalDevices] = vkCommand{"vkEnumeratePhysicalDevices", 3, true, nil}
	lazyCommands[keyvkFlushMappedMemoryRanges] = vkCommand{"vkFlushMappedMemoryRanges", 3, true, nil}
	lazyCommands[keyvkFreeCommandBuffers] = vkCommand{"vkFreeCommandBuffers", 4, true, nil}
	lazyCommands[keyvkFreeDescriptorSets] = vkCommand{"vkFreeDescriptorSets", 4, true, nil}
	lazyCommands[keyvkFreeMemory] = vkCommand{"vkFreeMemory", 3, true, nil}
	lazyCommands[keyvkGetAccelerationStructureBuildSizesKHR] = vkCommand{"vkGetAccelerationStructureBuildSizesKHR", 5, true, nil}
	lazyCommands[keyvkGetAccelerationStructureDeviceAddressKHR] = vkCommand{"vkGetAccelerationStructureDeviceAddressKHR", 2, true, nil}
	lazyCommands[keyvkGetAccelerationStructureHandleNV] = vkCommand{"vkGetAccelerationStructureHandleNV", 4, true, nil}
	lazyCommands[keyvkGetAccelerationStructureMemoryRequirementsNV] = vkCommand{"vkGetAccelerationStructureMemoryRequirementsNV", 3, true, nil}
	lazyCommands[keyvkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT] = vkCommand{"vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT", 3, true, nil}
	lazyCommands[keyvkGetBufferDeviceAddress] = vkCommand{"vkGetBufferDeviceAddress", 2, true, nil}
	lazyCommands[keyvkGetBufferMemoryRequirements] = vkCommand{"vkGetBufferMemoryRequirements", 3, true, nil}
	lazyCommands[keyvkGetBufferMemoryRequirements2] = vkCommand{"vkGetBufferMemoryRequirements2", 3, true, nil}
	lazyCommands[keyvkGetBufferOpaqueCaptureAddress] = vkCommand{"vkGetBufferOpaqueCaptureAddress", 2, true, nil}
	lazyCommands[keyvkGetBufferOpaqueCaptureDescriptorDataEXT] = vkCommand{"vkGetBufferOpaqueCaptureDescriptorDataEXT", 3, true, nil}
	lazyCommands[keyvkGetCalibratedTimestampsEXT] = vkCommand{"vkGetCalibratedTimestampsEXT", 5, true, nil}
	lazyCommands[keyvkGetDeferredOperationMaxConcurrencyKHR] = vkCommand{"vkGetDeferredOperationMaxConcurrencyKHR", 2, true, nil}
	lazyCommands[keyvkGetDeferredOperationResultKHR] = vkCommand{"vkGetDeferredOperationResultKHR", 2, true, nil}
	lazyCommands[keyvkGetDescriptorEXT] = vkCommand{"vkGetDescriptorEXT", 4, true, nil}
	lazyCommands[keyvkGetDescriptorSetHostMappingVALVE] = vkCommand{"vkGetDescriptorSetHostMappingVALVE", 3, true, nil}
	lazyCommands[keyvkGetDescriptorSetLayoutBindingOffsetEXT] = vkCommand{"vkGetDescriptorSetLayoutBindingOffsetEXT", 4, true, nil}
	lazyCommands[keyvkGetDescriptorSetLayoutHostMappingInfoVALVE] = vkCommand{"vkGetDescriptorSetLayoutHostMappingInfoVALVE", 3, true, nil}
	lazyCommands[keyvkGetDescriptorSetLayoutSizeEXT] = vkCommand{"vkGetDescriptorSetLayoutSizeEXT", 3, true, nil}
	lazyCommands[keyvkGetDescriptorSetLayoutSupport] = vkCommand{"vkGetDescriptorSetLayoutSupport", 3, true, nil}
	lazyCommands[keyvkGetDeviceAccelerationStructureCompatibilityKHR] = vkCommand{"vkGetDeviceAccelerationStructureCompatibilityKHR", 3, true, nil}
	lazyCommands[keyvkGetDeviceBufferMemoryRequirements] = vkCommand{"vkGetDeviceBufferMemoryRequirements", 3, true, nil}
	lazyCommands[keyvkGetDeviceFaultInfoEXT] = vkCommand{"vkGetDeviceFaultInfoEXT", 3, true, nil}
	lazyCommands[keyvkGetDeviceGroupPeerMemoryFeatures] = vkCommand{"vkGetDeviceGroupPeerMemoryFeatures", 5, true, nil}
	lazyCommands[keyvkGetDeviceGroupPresentCapabilitiesKHR] = vkCommand{"vkGetDeviceGroupPresentCapabilitiesKHR", 2, true, nil}
	lazyCommands[keyvkGetDeviceGroupSurfacePresentModesKHR] = vkCommand{"vkGetDeviceGroupSurfacePresentModesKHR", 3, true, nil}
	lazyCommands[keyvkGetDeviceImageMemoryRequirements] = vkCommand{"vkGetDeviceImageMemoryRequirements", 3, true, nil}
	lazyCommands[keyvkGetDeviceImageSparseMemoryRequirements] = vkCommand{"vkGetDeviceImageSparseMemoryRequirements", 4, true, nil}
	lazyCommands[keyvkGetDeviceMemoryCommitment] = vkCommand{"vkGetDeviceMemoryCommitment", 3, true, nil}
	lazyCommands[keyvkGetDeviceMemoryOpaqueCaptureAddress] = vkCommand{"vkGetDeviceMemoryOpaqueCaptureAddress", 2, true, nil}
	lazyCommands[keyvkGetDeviceMicromapCompatibilityEXT] = vkCommand{"vkGetDeviceMicromapCompatibilityEXT", 3, true, nil}
	lazyCommands[keyvkGetDeviceProcAddr] = vkCommand{"vkGetDeviceProcAddr", 2, true, nil}
	lazyCommands[keyvkGetDeviceQueue] = vkCommand{"vkGetDeviceQueue", 4, true, nil}
	lazyCommands[keyvkGetDeviceQueue2] = vkCommand{"vkGetDeviceQueue2", 3, true, nil}
	lazyCommands[keyvkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI] = vkCommand{"vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI", 3, true, nil}
	lazyCommands[keyvkGetDisplayModeProperties2KHR] = vkCommand{"vkGetDisplayModeProperties2KHR", 4, true, nil}
	lazyCommands[keyvkGetDisplayModePropertiesKHR] = vkCommand{"vkGetDisplayModePropertiesKHR", 4, true, nil}
	lazyCommands[keyvkGetDisplayPlaneCapabilities2KHR] = vkCommand{"vkGetDisplayPlaneCapabilities2KHR", 3, true, nil}
	lazyCommands[keyvkGetDisplayPlaneCapabilitiesKHR] = vkCommand{"vkGetDisplayPlaneCapabilitiesKHR", 4, true, nil}
	lazyCommands[keyvkGetDisplayPlaneSupportedDisplaysKHR] = vkCommand{"vkGetDisplayPlaneSupportedDisplaysKHR", 4, true, nil}
	lazyCommands[keyvkGetDrmDisplayEXT] = vkCommand{"vkGetDrmDisplayEXT", 4, true, nil}
	lazyCommands[keyvkGetDynamicRenderingTilePropertiesQCOM] = vkCommand{"vkGetDynamicRenderingTilePropertiesQCOM", 3, true, nil}
	lazyCommands[keyvkGetEventStatus] = vkCommand{"vkGetEventStatus", 2, true, nil}
	lazyCommands[keyvkGetFenceFdKHR] = vkCommand{"vkGetFenceFdKHR", 3, true, nil}
	lazyCommands[keyvkGetFenceStatus] = vkCommand{"vkGetFenceStatus", 2, true, nil}
	lazyCommands[keyvkGetFramebufferTilePropertiesQCOM] = vkCommand{"vkGetFramebufferTilePropertiesQCOM", 4, true, nil}
	lazyCommands[keyvkGetGeneratedCommandsMemoryRequirementsNV] = vkCommand{"vkGetGeneratedCommandsMemoryRequirementsNV", 3, true, nil}
	lazyCommands[keyvkGetImageDrmFormatModifierPropertiesEXT] = vkCommand{"vkGetImageDrmFormatModifierPropertiesEXT", 3, true, nil}
	lazyCommands[keyvkGetImageMemoryRequirements] = vkCommand{"vkGetImageMemoryRequirements", 3, true, nil}
	lazyCommands[keyvkGetImageMemoryRequirements2] = vkCommand{"vkGetImageMemoryRequirements2", 3, true, nil}
	lazyCommands[keyvkGetImageOpaqueCaptureDescriptorDataEXT] = vkCommand{"vkGetImageOpaqueCaptureDescriptorDataEXT", 3, true, nil}
	lazyCommands[keyvkGetImageSparseMemoryRequirements] = vkCommand{"vkGetImageSparseMemoryRequirements", 4, true, nil}
	lazyCommands[keyvkGetImageSparseMemoryRequirements2] = vkCommand{"vkGetImageSparseMemoryRequirements2", 4, true, nil}
	lazyCommands[keyvkGetImageSubresourceLayout] = vkCommand{"vkGetImageSubresourceLayout", 4, true, nil}
	lazyCommands[keyvkGetImageSubresourceLayout2EXT] = vkCommand{"vkGetImageSubresourceLayout2EXT", 4, true, nil}
	lazyCommands[keyvkGetImageViewAddressNVX] = vkCommand{"vkGetImageViewAddressNVX", 3, true, nil}
	lazyCommands[keyvkGetImageViewHandleNVX] = vkCommand{"vkGetImageViewHandleNVX", 2, true, nil}
	lazyCommands[keyvkGetImageViewOpaqueCaptureDescriptorDataEXT] = vkCommand{"vkGetImageViewOpaqueCaptureDescriptorDataEXT", 3, true, nil}
	lazyCommands[keyvkGetInstanceProcAddr] = vkCommand{"vkGetInstanceProcAddr", 2, true, nil}
	lazyCommands[keyvkGetMemoryFdKHR] = vkCommand{"vkGetMemoryFdKHR", 3, true, nil}
	lazyCommands[keyvkGetMemoryFdPropertiesKHR] = vkCommand{"vkGetMemoryFdPropertiesKHR", 4, true, nil}
	lazyCommands[keyvkGetMemoryHostPointerPropertiesEXT] = vkCommand{"vkGetMemoryHostPointerPropertiesEXT", 4, true, nil}
	lazyCommands[keyvkGetMemoryRemoteAddressNV] = vkCommand{"vkGetMemoryRemoteAddressNV", 3, true, nil}
	lazyCommands[keyvkGetMicromapBuildSizesEXT] = vkCommand{"vkGetMicromapBuildSizesEXT", 4, true, nil}
	lazyCommands[keyvkGetPastPresentationTimingGOOGLE] = vkCommand{"vkGetPastPresentationTimingGOOGLE", 4, true, nil}
	lazyCommands[keyvkGetPerformanceParameterINTEL] = vkCommand{"vkGetPerformanceParameterINTEL", 3, true, nil}
	lazyCommands[keyvkGetPhysicalDeviceCalibrateableTimeDomainsEXT] = vkCommand{"vkGetPhysicalDeviceCalibrateableTimeDomainsEXT", 3, true, nil}
	lazyCommands[keyvkGetPhysicalDeviceCooperativeMatrixPropertiesNV] = vkCommand{"vkGetPhysicalDeviceCooperativeMatrixPropertiesNV", 3, true, nil}
	lazyCommands[keyvkGetPhysicalDeviceDisplayPlaneProperties2KHR] = vkCommand{"vkGetPhysicalDeviceDisplayPlaneProperties2KHR", 3, true, nil}
	lazyCommands[keyvkGetPhysicalDeviceDisplayPlanePropertiesKHR] = vkCommand{"vkGetPhysicalDeviceDisplayPlanePropertiesKHR", 3, true, nil}
	lazyCommands[keyvkGetPhysicalDeviceDisplayProperties2KHR] = vkCommand{"vkGetPhysicalDeviceDisplayProperties2KHR", 3, true, nil}
	lazyCommands[keyvkGetPhysicalDeviceDisplayPropertiesKHR] = vkCommand{"vkGetPhysicalDeviceDisplayPropertiesKHR", 3, true, nil}
	lazyCommands[keyvkGetPhysicalDeviceExternalBufferProperties] = vkCommand{"vkGetPhysicalDeviceExternalBufferProperties", 3, true, nil}
	lazyCommands[keyvkGetPhysicalDeviceExternalFenceProperties] = vkCommand{"vkGetPhysicalDeviceExternalFenceProperties", 3, true, nil}
	lazyCommands[keyvkGetPhysicalDeviceExternalImageFormatPropertiesNV] = vkCommand{"vkGetPhysicalDeviceExternalImageFormatPropertiesNV", 8, true, nil}
	lazyCommands[keyvkGetPhysicalDeviceExternalSemaphoreProperties] = vkCommand{"vkGetPhysicalDeviceExternalSemaphoreProperties", 3, true, nil}
	lazyCommands[keyvkGetPhysicalDeviceFeatures] = vkCommand{"vkGetPhysicalDeviceFeatures", 2, true, nil}
	lazyCommands[keyvkGetPhysicalDeviceFeatures2] = vkCommand{"vkGetPhysicalDeviceFeatures2", 2, true, nil}
	lazyCommands[keyvkGetPhysicalDeviceFormatProperties] = vkCommand{"vkGetPhysicalDeviceFormatProperties", 3, true, nil}
	lazyCommands[keyvkGetPhysicalDeviceFormatProperties2] = vkCommand{"vkGetPhysicalDeviceFormatProperties2", 3, true, nil}
	lazyCommands[keyvkGetPhysicalDeviceFragmentShadingRatesKHR] = vkCommand{"vkGetPhysicalDeviceFragmentShadingRatesKHR", 3, true, nil}
	lazyCommands[keyvkGetPhysicalDeviceImageFormatProperties] = vkCommand{"vkGetPhysicalDeviceImageFormatProperties", 7, true, nil}
	lazyCommands[keyvkGetPhysicalDeviceImageFormatProperties2] = vkCommand{"vkGetPhysicalDeviceImageFormatProperties2", 3, true, nil}
	lazyCommands[keyvkGetPhysicalDeviceMemoryProperties] = vkCommand{"vkGetPhysicalDeviceMemoryProperties", 2, true, nil}
	lazyCommands[keyvkGetPhysicalDeviceMemoryProperties2] = vkCommand{"vkGetPhysicalDeviceMemoryProperties2", 2, true, nil}
	lazyCommands[keyvkGetPhysicalDeviceMultisamplePropertiesEXT] = vkCommand{"vkGetPhysicalDeviceMultisamplePropertiesEXT", 3, true, nil}
	lazyCommands[keyvkGetPhysicalDeviceOpticalFlowImageFormatsNV] = vkCommand{"vkGetPhysicalDeviceOpticalFlowImageFormatsNV", 4, true, nil}
	lazyCommands[keyvkGetPhysicalDevicePresentRectanglesKHR] = vkCommand{"vkGetPhysicalDevicePresentRectanglesKHR", 4, true, nil}
	lazyCommands[keyvkGetPhysicalDeviceProperties] = vkCommand{"vkGetPhysicalDeviceProperties", 2, true, nil}
	lazyCommands[keyvkGetPhysicalDeviceProperties2] = vkCommand{"vkGetPhysicalDeviceProperties2", 2, true, nil}
	lazyCommands[keyvkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR] = vkCommand{"vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR", 3, true, nil}
	lazyCommands[keyvkGetPhysicalDeviceQueueFamilyProperties] = vkCommand{"vkGetPhysicalDeviceQueueFamilyProperties", 3, true, nil}
	lazyCommands[keyvkGetPhysicalDeviceQueueFamilyProperties2] = vkCommand{"vkGetPhysicalDeviceQueueFamilyProperties2", 3, true, nil}
	lazyCommands[keyvkGetPhysicalDeviceSparseImageFormatProperties] = vkCommand{"vkGetPhysicalDeviceSparseImageFormatProperties", 8, true, nil}
	lazyCommands[keyvkGetPhysicalDeviceSparseImageFormatProperties2] = vkCommand{"vkGetPhysicalDeviceSparseImageFormatProperties2", 4, true, nil}
	lazyCommands[keyvkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV] = vkCommand{"vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV", 3, true, nil}
	lazyCommands[keyvkGetPhysicalDeviceSurfaceCapabilities2EXT] = vkCommand{"vkGetPhysicalDeviceSurfaceCapabilities2EXT", 3, true, nil}
	lazyCommands[keyvkGetPhysicalDeviceSurfaceCapabilities2KHR] = vkCommand{"vkGetPhysicalDeviceSurfaceCapabilities2KHR", 3, true, nil}
	lazyCommands[keyvkGetPhysicalDeviceSurfaceCapabilitiesKHR] = vkCommand{"vkGetPhysicalDeviceSurfaceCapabilitiesKHR", 3, true, nil}
	lazyCommands[keyvkGetPhysicalDeviceSurfaceFormats2KHR] = vkCommand{"vkGetPhysicalDeviceSurfaceFormats2KHR", 4, true, nil}
	lazyCommands[keyvkGetPhysicalDeviceSurfaceFormatsKHR] = vkCommand{"vkGetPhysicalDeviceSurfaceFormatsKHR", 4, true, nil}
	lazyCommands[keyvkGetPhysicalDeviceSurfacePresentModesKHR] = vkCommand{"vkGetPhysicalDeviceSurfacePresentModesKHR", 4, true, nil}
	lazyCommands[keyvkGetPhysicalDeviceSurfaceSupportKHR] = vkCommand{"vkGetPhysicalDeviceSurfaceSupportKHR", 4, true, nil}
	lazyCommands[keyvkGetPhysicalDeviceToolProperties] = vkCommand{"vkGetPhysicalDeviceToolProperties", 3, true, nil}
	lazyCommands[keyvkGetPhysicalDeviceVideoCapabilitiesKHR] = vkCommand{"vkGetPhysicalDeviceVideoCapabilitiesKHR", 3, true, nil}
	lazyCommands[keyvkGetPhysicalDeviceVideoFormatPropertiesKHR] = vkCommand{"vkGetPhysicalDeviceVideoFormatPropertiesKHR", 4, true, nil}
	lazyCommands[keyvkGetPipelineCacheData] = vkCommand{"vkGetPipelineCacheData", 4, true, nil}
	lazyCommands[keyvkGetPipelineExecutableInternalRepresentationsKHR] = vkCommand{"vkGetPipelineExecutableInternalRepresentationsKHR", 4, true, nil}
	lazyCommands[keyvkGetPipelineExecutablePropertiesKHR] = vkCommand{"vkGetPipelineExecutablePropertiesKHR", 4, true, nil}
	lazyCommands[keyvkGetPipelineExecutableStatisticsKHR] = vkCommand{"vkGetPipelineExecutableStatisticsKHR", 4, true, nil}
	lazyCommands[keyvkGetPipelinePropertiesEXT] = vkCommand{"vkGetPipelinePropertiesEXT", 3, true, nil}
	lazyCommands[keyvkGetPrivateData] = vkCommand{"vkGetPrivateData", 5, true, nil}
	lazyCommands[keyvkGetQueryPoolResults] = vkCommand{"vkGetQueryPoolResults", 8, true, nil}
	lazyCommands[keyvkGetQueueCheckpointData2NV] = vkCommand{"vkGetQueueCheckpointData2NV", 3, true, nil}
	lazyCommands[keyvkGetQueueCheckpointDataNV] = vkCommand{"vkGetQueueCheckpointDataNV", 3, true, nil}
	lazyCommands[keyvkGetRayTracingCaptureReplayShaderGroupHandlesKHR] = vkCommand{"vkGetRayTracingCaptureReplayShaderGroupHandlesKHR", 6, true, nil}
	lazyCommands[keyvkGetRayTracingShaderGroupHandlesKHR] = vkCommand{"vkGetRayTracingShaderGroupHandlesKHR", 6, true, nil}
	lazyCommands[keyvkGetRayTracingShaderGroupStackSizeKHR] = vkCommand{"vkGetRayTracingShaderGroupStackSizeKHR", 4, true, nil}
	lazyCommands[keyvkGetRefreshCycleDurationGOOGLE] = vkCommand{"vkGetRefreshCycleDurationGOOGLE", 3, true, nil}
	lazyCommands[keyvkGetRenderAreaGranularity] = vkCommand{"vkGetRenderAreaGranularity", 3, true, nil}
	lazyCommands[keyvkGetSamplerOpaqueCaptureDescriptorDataEXT] = vkCommand{"vkGetSamplerOpaqueCaptureDescriptorDataEXT", 3, true, nil}
	lazyCommands[keyvkGetSemaphoreCounterValue] = vkCommand{"vkGetSemaphoreCounterValue", 3, true, nil}
	lazyCommands[keyvkGetSemaphoreFdKHR] = vkCommand{"vkGetSemaphoreFdKHR", 3, true, nil}
	lazyCommands[keyvkGetShaderInfoAMD] = vkCommand{"vkGetShaderInfoAMD", 6, true, nil}
	lazyCommands[keyvkGetShaderModuleCreateInfoIdentifierEXT] = vkCommand{"vkGetShaderModuleCreateInfoIdentifierEXT", 3, true, nil}
	lazyCommands[keyvkGetShaderModuleIdentifierEXT] = vkCommand{"vkGetShaderModuleIdentifierEXT", 3, true, nil}
	lazyCommands[keyvkGetSwapchainCounterEXT] = vkCommand{"vkGetSwapchainCounterEXT", 4, true, nil}
	lazyCommands[keyvkGetSwapchainImagesKHR] = vkCommand{"vkGetSwapchainImagesKHR", 4, true, nil}
	lazyCommands[keyvkGetSwapchainStatusKHR] = vkCommand{"vkGetSwapchainStatusKHR", 2, true, nil}
	lazyCommands[keyvkGetValidationCacheDataEXT] = vkCommand{"vkGetValidationCacheDataEXT", 4, true, nil}
	lazyCommands[keyvkGetVideoSessionMemoryRequirementsKHR] = vkCommand{"vkGetVideoSessionMemoryRequirementsKHR", 4, true, nil}
	lazyCommands[keyvkImportFenceFdKHR] = vkCommand{"vkImportFenceFdKHR", 2, true, nil}
	lazyCommands[keyvkImportSemaphoreFdKHR] = vkCommand{"vkImportSemaphoreFdKHR", 2, true, nil}
	lazyCommands[keyvkInitializePerformanceApiINTEL] = vkCommand{"vkInitializePerformanceApiINTEL", 2, true, nil}
	lazyCommands[keyvkInvalidateMappedMemoryRanges] = vkCommand{"vkInvalidateMappedMemoryRanges", 3, true, nil}
	lazyCommands[keyvkMapMemory] = vkCommand{"vkMapMemory", 6, true, nil}
	lazyCommands[keyvkMergePipelineCaches] = vkCommand{"vkMergePipelineCaches", 4, true, nil}
	lazyCommands[keyvkMergeValidationCachesEXT] = vkCommand{"vkMergeValidationCachesEXT", 4, true, nil}
	lazyCommands[keyvkQueueBeginDebugUtilsLabelEXT] = vkCommand{"vkQueueBeginDebugUtilsLabelEXT", 2, true, nil}
	lazyCommands[keyvkQueueBindSparse] = vkCommand{"vkQueueBindSparse", 4, true, nil}
	lazyCommands[keyvkQueueEndDebugUtilsLabelEXT] = vkCommand{"vkQueueEndDebugUtilsLabelEXT", 1, true, nil}
	lazyCommands[keyvkQueueInsertDebugUtilsLabelEXT] = vkCommand{"vkQueueInsertDebugUtilsLabelEXT", 2, true, nil}
	lazyCommands[keyvkQueuePresentKHR] = vkCommand{"vkQueuePresentKHR", 2, true, nil}
	lazyCommands[keyvkQueueSetPerformanceConfigurationINTEL] = vkCommand{"vkQueueSetPerformanceConfigurationINTEL", 2, true, nil}
	lazyCommands[keyvkQueueSubmit] = vkCommand{"vkQueueSubmit", 4, true, nil}
	lazyCommands[keyvkQueueSubmit2] = vkCommand{"vkQueueSubmit2", 4, true, nil}
	lazyCommands[keyvkQueueWaitIdle] = vkCommand{"vkQueueWaitIdle", 1, true, nil}
	lazyCommands[keyvkRegisterDeviceEventEXT] = vkCommand{"vkRegisterDeviceEventEXT", 4, true, nil}
	lazyCommands[keyvkRegisterDisplayEventEXT] = vkCommand{"vkRegisterDisplayEventEXT", 5, true, nil}
	lazyCommands[keyvkReleaseDisplayEXT] = vkCommand{"vkReleaseDisplayEXT", 2, true, nil}
	lazyCommands[keyvkReleasePerformanceConfigurationINTEL] = vkCommand{"vkReleasePerformanceConfigurationINTEL", 2, true, nil}
	lazyCommands[keyvkReleaseProfilingLockKHR] = vkCommand{"vkReleaseProfilingLockKHR", 1, true, nil}
	lazyCommands[keyvkReleaseSwapchainImagesEXT] = vkCommand{"vkReleaseSwapchainImagesEXT", 2, true, nil}
	lazyCommands[keyvkResetCommandBuffer] = vkCommand{"vkResetCommandBuffer", 2, true, nil}
	lazyCommands[keyvkResetCommandPool] = vkCommand{"vkResetCommandPool", 3, true, nil}
	lazyCommands[keyvkResetDescriptorPool] = vkCommand{"vkResetDescriptorPool", 3, true, nil}
	lazyCommands[keyvkResetEvent] = vkCommand{"vkResetEvent", 2, true, nil}
	lazyCommands[keyvkResetFences] = vkCommand{"vkResetFences", 3, true, nil}
	lazyCommands[keyvkResetQueryPool] = vkCommand{"vkResetQueryPool", 4, true, nil}
	lazyCommands[keyvkSetDebugUtilsObjectNameEXT] = vkCommand{"vkSetDebugUtilsObjectNameEXT", 2, true, nil}
	lazyCommands[keyvkSetDebugUtilsObjectTagEXT] = vkCommand{"vkSetDebugUtilsObjectTagEXT", 2, true, nil}
	lazyCommands[keyvkSetDeviceMemoryPriorityEXT] = vkCommand{"vkSetDeviceMemoryPriorityEXT", 3, true, nil}
	lazyCommands[keyvkSetEvent] = vkCommand{"vkSetEvent", 2, true, nil}
	lazyCommands[keyvkSetHdrMetadataEXT] = vkCommand{"vkSetHdrMetadataEXT", 4, true, nil}
	lazyCommands[keyvkSetLocalDimmingAMD] = vkCommand{"vkSetLocalDimmingAMD", 3, true, nil}
	lazyCommands[keyvkSetPrivateData] = vkCommand{"vkSetPrivateData", 5, true, nil}
	lazyCommands[keyvkSignalSemaphore] = vkCommand{"vkSignalSemaphore", 2, true, nil}
	lazyCommands[keyvkSubmitDebugUtilsMessageEXT] = vkCommand{"vkSubmitDebugUtilsMessageEXT", 4, true, nil}
	lazyCommands[keyvkTrimCommandPool] = vkCommand{"vkTrimCommandPool", 3, true, nil}
	lazyCommands[keyvkUninitializePerformanceApiINTEL] = vkCommand{"vkUninitializePerformanceApiINTEL", 1, true, nil}
	lazyCommands[keyvkUnmapMemory] = vkCommand{"vkUnmapMemory", 2, true, nil}
	lazyCommands[keyvkUpdateDescriptorSetWithTemplate] = vkCommand{"vkUpdateDescriptorSetWithTemplate", 4, true, nil}
	lazyCommands[keyvkUpdateDescriptorSets] = vkCommand{"vkUpdateDescriptorSets", 5, true, nil}
	lazyCommands[keyvkUpdateVideoSessionParametersKHR] = vkCommand{"vkUpdateVideoSessionParametersKHR", 3, true, nil}
	lazyCommands[keyvkWaitForFences] = vkCommand{"vkWaitForFences", 5, true, nil}
	lazyCommands[keyvkWaitForPresentKHR] = vkCommand{"vkWaitForPresentKHR", 4, true, nil}
	lazyCommands[keyvkWaitSemaphores] = vkCommand{"vkWaitSemaphores", 3, true, nil}
	lazyCommands[keyvkWriteAccelerationStructuresPropertiesKHR] = vkCommand{"vkWriteAccelerationStructuresPropertiesKHR", 7, true, nil}
	lazyCommands[keyvkWriteMicromapsPropertiesEXT] = vkCommand{"vkWriteMicromapsPropertiesEXT", 7, true, nil}
}

// AcquireDrmDisplayEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkAcquireDrmDisplayEXT.html
func AcquireDrmDisplayEXT(physicalDevice PhysicalDevice, drmFd int32, display DisplayKHR) (r Result) {

	r = Result(execTrampoline(keyvkAcquireDrmDisplayEXT, uintptr(physicalDevice), uintptr(drmFd), uintptr(display)))

	return
}

// AcquireNextImage2KHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkAcquireNextImage2KHR.html
func AcquireNextImage2KHR(device Device, acquireInfo *AcquireNextImageInfoKHR) (r Result, imageIndex uint32) {
	// Parameter is a singular input, requires translation - acquireInfo
	var pAcquireInfo *_vkAcquireNextImageInfoKHR
	if acquireInfo != nil {
		pAcquireInfo = acquireInfo.Vulkanize()
	}

	// imageIndex is a binding-allocated single return value and will be populated by Vulkan
	ptr_pImageIndex := &imageIndex

	r = Result(execTrampoline(keyvkAcquireNextImage2KHR, uintptr(device), uintptr(unsafe.Pointer(pAcquireInfo)), uintptr(unsafe.Pointer(ptr_pImageIndex))))

	return
}

// AcquireNextImageKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkAcquireNextImageKHR.html
func AcquireNextImageKHR(device Device, swapchain SwapchainKHR, timeout uint64, semaphore Semaphore, fence Fence) (r Result, imageIndex uint32) {
	// imageIndex is a binding-allocated single return value and will be populated by Vulkan
	ptr_pImageIndex := &imageIndex

	r = Result(execTrampoline(keyvkAcquireNextImageKHR, uintptr(device), uintptr(swapchain), uintptr(timeout), uintptr(semaphore), uintptr(fence), uintptr(unsafe.Pointer(ptr_pImageIndex))))

	return
}

// AcquirePerformanceConfigurationINTEL: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkAcquirePerformanceConfigurationINTEL.html
func AcquirePerformanceConfigurationINTEL(device Device, acquireInfo *PerformanceConfigurationAcquireInfoINTEL) (r Result, configuration PerformanceConfigurationINTEL) {
	// Parameter is a singular input, requires translation - acquireInfo
	var pAcquireInfo *_vkPerformanceConfigurationAcquireInfoINTEL
	if acquireInfo != nil {
		pAcquireInfo = acquireInfo.Vulkanize()
	}

	// configuration is a binding-allocated single return value and will be populated by Vulkan
	ptr_pConfiguration := &configuration

	r = Result(execTrampoline(keyvkAcquirePerformanceConfigurationINTEL, uintptr(device), uintptr(unsafe.Pointer(pAcquireInfo)), uintptr(unsafe.Pointer(ptr_pConfiguration))))

	return
}

// AcquireProfilingLockKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkAcquireProfilingLockKHR.html
func AcquireProfilingLockKHR(device Device, info *AcquireProfilingLockInfoKHR) (r Result) {
	// Parameter is a singular input, requires translation - info
	var pInfo *_vkAcquireProfilingLockInfoKHR
	if info != nil {
		pInfo = info.Vulkanize()
	}

	r = Result(execTrampoline(keyvkAcquireProfilingLockKHR, uintptr(device), uintptr(unsafe.Pointer(pInfo))))

	return
}

// AllocateCommandBuffers: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkAllocateCommandBuffers.html
func AllocateCommandBuffers(device Device, allocateInfo *CommandBufferAllocateInfo) (r Result, commandBuffers []CommandBuffer) {
	// Parameter is a singular input, requires translation - allocateInfo
	var pAllocateInfo *_vkCommandBufferAllocateInfo
	if allocateInfo != nil {
		pAllocateInfo = allocateInfo.Vulkanize()
	}

	// Parameter is binding-allocated array populated by Vulkan; length is possibly embedded in a struct (pAllocateInfo->commandBufferCount) - commandBuffers
	commandBuffers = make([]CommandBuffer, pAllocateInfo.commandBufferCount)
	pCommandBuffers := &commandBuffers[0]

	r = Result(execTrampoline(keyvkAllocateCommandBuffers, uintptr(device), uintptr(unsafe.Pointer(pAllocateInfo)), uintptr(unsafe.Pointer(pCommandBuffers))))

	return
}

// AllocateDescriptorSets: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkAllocateDescriptorSets.html
func AllocateDescriptorSets(device Device, allocateInfo *DescriptorSetAllocateInfo) (r Result, descriptorSets []DescriptorSet) {
	// Parameter is a singular input, requires translation - allocateInfo
	var pAllocateInfo *_vkDescriptorSetAllocateInfo
	if allocateInfo != nil {
		pAllocateInfo = allocateInfo.Vulkanize()
	}

	// Parameter is binding-allocated array populated by Vulkan; length is possibly embedded in a struct (pAllocateInfo->descriptorSetCount) - descriptorSets
	descriptorSets = make([]DescriptorSet, pAllocateInfo.descriptorSetCount)
	pDescriptorSets := &descriptorSets[0]

	r = Result(execTrampoline(keyvkAllocateDescriptorSets, uintptr(device), uintptr(unsafe.Pointer(pAllocateInfo)), uintptr(unsafe.Pointer(pDescriptorSets))))

	return
}

// AllocateMemory: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkAllocateMemory.html
func AllocateMemory(device Device, allocateInfo *MemoryAllocateInfo, allocator *AllocationCallbacks) (r Result, memory DeviceMemory) {
	// Parameter is a singular input, requires translation - allocateInfo
	var pAllocateInfo *_vkMemoryAllocateInfo
	if allocateInfo != nil {
		pAllocateInfo = allocateInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// memory is a binding-allocated single return value and will be populated by Vulkan
	ptr_pMemory := &memory

	r = Result(execTrampoline(keyvkAllocateMemory, uintptr(device), uintptr(unsafe.Pointer(pAllocateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pMemory))))

	return
}

// BeginCommandBuffer: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkBeginCommandBuffer.html
func BeginCommandBuffer(commandBuffer CommandBuffer, beginInfo *CommandBufferBeginInfo) (r Result) {
	// Parameter is a singular input, requires translation - beginInfo
	var pBeginInfo *_vkCommandBufferBeginInfo
	if beginInfo != nil {
		pBeginInfo = beginInfo.Vulkanize()
	}

	r = Result(execTrampoline(keyvkBeginCommandBuffer, uintptr(commandBuffer), uintptr(unsafe.Pointer(pBeginInfo))))

	return
}

// BindAccelerationStructureMemoryNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkBindAccelerationStructureMemoryNV.html
func BindAccelerationStructureMemoryNV(device Device, bindInfos []BindAccelerationStructureMemoryInfoNV) (r Result) {
	bindInfoCount := len(bindInfos)
	// bindInfos is an input slice that requires translation to an internal type
	var pBindInfos unsafe.Pointer
	if len(bindInfos) > 0 {
		sl_bindInfos := make([]_vkBindAccelerationStructureMemoryInfoNV, bindInfoCount)
		for i, v := range bindInfos {
			sl_bindInfos[i] = *(v.Vulkanize())
		}
		pBindInfos = unsafe.Pointer(&sl_bindInfos[0])
	}

	r = Result(execTrampoline(keyvkBindAccelerationStructureMemoryNV, uintptr(device), uintptr(bindInfoCount), uintptr(unsafe.Pointer(pBindInfos))))

	return
}

// BindBufferMemory: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkBindBufferMemory.html
func BindBufferMemory(device Device, buffer Buffer, memory DeviceMemory, memoryOffset DeviceSize) (r Result) {

	r = Result(execTrampoline(keyvkBindBufferMemory, uintptr(device), uintptr(buffer), uintptr(memory), uintptr(memoryOffset)))

	return
}

// BindBufferMemory2: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkBindBufferMemory2.html
func BindBufferMemory2(device Device, bindInfos []BindBufferMemoryInfo) (r Result) {
	bindInfoCount := len(bindInfos)
	// bindInfos is an input slice that requires translation to an internal type
	var pBindInfos unsafe.Pointer
	if len(bindInfos) > 0 {
		sl_bindInfos := make([]_vkBindBufferMemoryInfo, bindInfoCount)
		for i, v := range bindInfos {
			sl_bindInfos[i] = *(v.Vulkanize())
		}
		pBindInfos = unsafe.Pointer(&sl_bindInfos[0])
	}

	r = Result(execTrampoline(keyvkBindBufferMemory2, uintptr(device), uintptr(bindInfoCount), uintptr(unsafe.Pointer(pBindInfos))))

	return
}

var BindBufferMemory2KHR = BindBufferMemory2

// BindImageMemory: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkBindImageMemory.html
func BindImageMemory(device Device, image Image, memory DeviceMemory, memoryOffset DeviceSize) (r Result) {

	r = Result(execTrampoline(keyvkBindImageMemory, uintptr(device), uintptr(image), uintptr(memory), uintptr(memoryOffset)))

	return
}

// BindImageMemory2: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkBindImageMemory2.html
func BindImageMemory2(device Device, bindInfos []BindImageMemoryInfo) (r Result) {
	bindInfoCount := len(bindInfos)
	// bindInfos is an input slice that requires translation to an internal type
	var pBindInfos unsafe.Pointer
	if len(bindInfos) > 0 {
		sl_bindInfos := make([]_vkBindImageMemoryInfo, bindInfoCount)
		for i, v := range bindInfos {
			sl_bindInfos[i] = *(v.Vulkanize())
		}
		pBindInfos = unsafe.Pointer(&sl_bindInfos[0])
	}

	r = Result(execTrampoline(keyvkBindImageMemory2, uintptr(device), uintptr(bindInfoCount), uintptr(unsafe.Pointer(pBindInfos))))

	return
}

var BindImageMemory2KHR = BindImageMemory2

// BindOpticalFlowSessionImageNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkBindOpticalFlowSessionImageNV.html
func BindOpticalFlowSessionImageNV(device Device, session OpticalFlowSessionNV, bindingPoint OpticalFlowSessionBindingPointNV, view ImageView, layout ImageLayout) (r Result) {

	r = Result(execTrampoline(keyvkBindOpticalFlowSessionImageNV, uintptr(device), uintptr(session), uintptr(bindingPoint), uintptr(view), uintptr(layout)))

	return
}

// BindVideoSessionMemoryKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkBindVideoSessionMemoryKHR.html
func BindVideoSessionMemoryKHR(device Device, videoSession VideoSessionKHR, bindSessionMemoryInfos []BindVideoSessionMemoryInfoKHR) (r Result) {
	bindSessionMemoryInfoCount := len(bindSessionMemoryInfos)
	// bindSessionMemoryInfos is an input slice that requires translation to an internal type
	var pBindSessionMemoryInfos unsafe.Pointer
	if len(bindSessionMemoryInfos) > 0 {
		sl_bindSessionMemoryInfos := make([]_vkBindVideoSessionMemoryInfoKHR, bindSessionMemoryInfoCount)
		for i, v := range bindSessionMemoryInfos {
			sl_bindSessionMemoryInfos[i] = *(v.Vulkanize())
		}
		pBindSessionMemoryInfos = unsafe.Pointer(&sl_bindSessionMemoryInfos[0])
	}

	r = Result(execTrampoline(keyvkBindVideoSessionMemoryKHR, uintptr(device), uintptr(videoSession), uintptr(bindSessionMemoryInfoCount), uintptr(unsafe.Pointer(pBindSessionMemoryInfos))))

	return
}

// BuildAccelerationStructuresKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkBuildAccelerationStructuresKHR.html
func BuildAccelerationStructuresKHR(device Device, deferredOperation DeferredOperationKHR, infos []AccelerationStructureBuildGeometryInfoKHR, pBuildRangeInfos []*AccelerationStructureBuildRangeInfoKHR) (r Result) {
	infoCount := len(infos)
	// infos is an input slice that requires translation to an internal type
	var pInfos unsafe.Pointer
	if len(infos) > 0 {
		sl_infos := make([]_vkAccelerationStructureBuildGeometryInfoKHR, infoCount)
		for i, v := range infos {
			sl_infos[i] = *(v.Vulkanize())
		}
		pInfos = unsafe.Pointer(&sl_infos[0])
	}

	// pBuildRangeInfos is an input slice of values that do not need translation used
	var ppBuildRangeInfos unsafe.Pointer
	if pBuildRangeInfos != nil {
		ppBuildRangeInfos = unsafe.Pointer(&pBuildRangeInfos[0])
	}

	r = Result(execTrampoline(keyvkBuildAccelerationStructuresKHR, uintptr(device), uintptr(deferredOperation), uintptr(infoCount), uintptr(unsafe.Pointer(pInfos)), uintptr(unsafe.Pointer(ppBuildRangeInfos))))

	return
}

// BuildMicromapsEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkBuildMicromapsEXT.html
func BuildMicromapsEXT(device Device, deferredOperation DeferredOperationKHR, infos []MicromapBuildInfoEXT) (r Result) {
	infoCount := len(infos)
	// infos is an input slice that requires translation to an internal type
	var pInfos unsafe.Pointer
	if len(infos) > 0 {
		sl_infos := make([]_vkMicromapBuildInfoEXT, infoCount)
		for i, v := range infos {
			sl_infos[i] = *(v.Vulkanize())
		}
		pInfos = unsafe.Pointer(&sl_infos[0])
	}

	r = Result(execTrampoline(keyvkBuildMicromapsEXT, uintptr(device), uintptr(deferredOperation), uintptr(infoCount), uintptr(unsafe.Pointer(pInfos))))

	return
}

// CmdBeginConditionalRenderingEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBeginConditionalRenderingEXT.html
func CmdBeginConditionalRenderingEXT(commandBuffer CommandBuffer, conditionalRenderingBegin *ConditionalRenderingBeginInfoEXT) {
	// Parameter is a singular input, requires translation - conditionalRenderingBegin
	var pConditionalRenderingBegin *_vkConditionalRenderingBeginInfoEXT
	if conditionalRenderingBegin != nil {
		pConditionalRenderingBegin = conditionalRenderingBegin.Vulkanize()
	}

	execTrampoline(keyvkCmdBeginConditionalRenderingEXT, uintptr(commandBuffer), uintptr(unsafe.Pointer(pConditionalRenderingBegin)))

}

// CmdBeginDebugUtilsLabelEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBeginDebugUtilsLabelEXT.html
func CmdBeginDebugUtilsLabelEXT(commandBuffer CommandBuffer, labelInfo *DebugUtilsLabelEXT) {
	// Parameter is a singular input, requires translation - labelInfo
	var pLabelInfo *_vkDebugUtilsLabelEXT
	if labelInfo != nil {
		pLabelInfo = labelInfo.Vulkanize()
	}

	execTrampoline(keyvkCmdBeginDebugUtilsLabelEXT, uintptr(commandBuffer), uintptr(unsafe.Pointer(pLabelInfo)))

}

// CmdBeginQuery: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBeginQuery.html
func CmdBeginQuery(commandBuffer CommandBuffer, queryPool QueryPool, query uint32, flags QueryControlFlags) {

	execTrampoline(keyvkCmdBeginQuery, uintptr(commandBuffer), uintptr(queryPool), uintptr(query), uintptr(flags))

}

// CmdBeginQueryIndexedEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBeginQueryIndexedEXT.html
func CmdBeginQueryIndexedEXT(commandBuffer CommandBuffer, queryPool QueryPool, query uint32, flags QueryControlFlags, index uint32) {

	execTrampoline(keyvkCmdBeginQueryIndexedEXT, uintptr(commandBuffer), uintptr(queryPool), uintptr(query), uintptr(flags), uintptr(index))

}

// CmdBeginRenderPass: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBeginRenderPass.html
func CmdBeginRenderPass(commandBuffer CommandBuffer, renderPassBegin *RenderPassBeginInfo, contents SubpassContents) {
	// Parameter is a singular input, requires translation - renderPassBegin
	var pRenderPassBegin *_vkRenderPassBeginInfo
	if renderPassBegin != nil {
		pRenderPassBegin = renderPassBegin.Vulkanize()
	}

	execTrampoline(keyvkCmdBeginRenderPass, uintptr(commandBuffer), uintptr(unsafe.Pointer(pRenderPassBegin)), uintptr(contents))

}

// CmdBeginRenderPass2: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBeginRenderPass2.html
func CmdBeginRenderPass2(commandBuffer CommandBuffer, renderPassBegin *RenderPassBeginInfo, subpassBeginInfo *SubpassBeginInfo) {
	// Parameter is a singular input, requires translation - renderPassBegin
	var pRenderPassBegin *_vkRenderPassBeginInfo
	if renderPassBegin != nil {
		pRenderPassBegin = renderPassBegin.Vulkanize()
	}

	// Parameter is a singular input, requires translation - subpassBeginInfo
	var pSubpassBeginInfo *_vkSubpassBeginInfo
	if subpassBeginInfo != nil {
		pSubpassBeginInfo = subpassBeginInfo.Vulkanize()
	}

	execTrampoline(keyvkCmdBeginRenderPass2, uintptr(commandBuffer), uintptr(unsafe.Pointer(pRenderPassBegin)), uintptr(unsafe.Pointer(pSubpassBeginInfo)))

}

var CmdBeginRenderPass2KHR = CmdBeginRenderPass2

// CmdBeginRendering: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBeginRendering.html
func CmdBeginRendering(commandBuffer CommandBuffer, renderingInfo *RenderingInfo) {
	// Parameter is a singular input, requires translation - renderingInfo
	var pRenderingInfo *_vkRenderingInfo
	if renderingInfo != nil {
		pRenderingInfo = renderingInfo.Vulkanize()
	}

	execTrampoline(keyvkCmdBeginRendering, uintptr(commandBuffer), uintptr(unsafe.Pointer(pRenderingInfo)))

}

var CmdBeginRenderingKHR = CmdBeginRendering

// CmdBeginTransformFeedbackEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBeginTransformFeedbackEXT.html
func CmdBeginTransformFeedbackEXT(commandBuffer CommandBuffer, firstCounterBuffer uint32, counterBuffers []Buffer, counterBufferOffsets []DeviceSize) {
	counterBufferCount := len(counterBuffers)
	// counterBuffers is an input slice of values that do not need translation used
	var pCounterBuffers unsafe.Pointer
	if counterBuffers != nil {
		pCounterBuffers = unsafe.Pointer(&counterBuffers[0])
	}

	// counterBufferOffsets is an input slice of values that do not need translation used
	var pCounterBufferOffsets unsafe.Pointer
	if counterBufferOffsets != nil {
		pCounterBufferOffsets = unsafe.Pointer(&counterBufferOffsets[0])
	}

	execTrampoline(keyvkCmdBeginTransformFeedbackEXT, uintptr(commandBuffer), uintptr(firstCounterBuffer), uintptr(counterBufferCount), uintptr(unsafe.Pointer(pCounterBuffers)), uintptr(unsafe.Pointer(pCounterBufferOffsets)))

}

// CmdBeginVideoCodingKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBeginVideoCodingKHR.html
func CmdBeginVideoCodingKHR(commandBuffer CommandBuffer, beginInfo *VideoBeginCodingInfoKHR) {
	// Parameter is a singular input, requires translation - beginInfo
	var pBeginInfo *_vkVideoBeginCodingInfoKHR
	if beginInfo != nil {
		pBeginInfo = beginInfo.Vulkanize()
	}

	execTrampoline(keyvkCmdBeginVideoCodingKHR, uintptr(commandBuffer), uintptr(unsafe.Pointer(pBeginInfo)))

}

// CmdBindDescriptorBufferEmbeddedSamplersEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBindDescriptorBufferEmbeddedSamplersEXT.html
func CmdBindDescriptorBufferEmbeddedSamplersEXT(commandBuffer CommandBuffer, pipelineBindPoint PipelineBindPoint, layout PipelineLayout, set uint32) {

	execTrampoline(keyvkCmdBindDescriptorBufferEmbeddedSamplersEXT, uintptr(commandBuffer), uintptr(pipelineBindPoint), uintptr(layout), uintptr(set))

}

// CmdBindDescriptorBuffersEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBindDescriptorBuffersEXT.html
func CmdBindDescriptorBuffersEXT(commandBuffer CommandBuffer, bindingInfos []DescriptorBufferBindingInfoEXT) {
	bufferCount := len(bindingInfos)
	// bindingInfos is an input slice that requires translation to an internal type
	var pBindingInfos unsafe.Pointer
	if len(bindingInfos) > 0 {
		sl_bindingInfos := make([]_vkDescriptorBufferBindingInfoEXT, bufferCount)
		for i, v := range bindingInfos {
			sl_bindingInfos[i] = *(v.Vulkanize())
		}
		pBindingInfos = unsafe.Pointer(&sl_bindingInfos[0])
	}

	execTrampoline(keyvkCmdBindDescriptorBuffersEXT, uintptr(commandBuffer), uintptr(bufferCount), uintptr(unsafe.Pointer(pBindingInfos)))

}

// CmdBindDescriptorSets: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBindDescriptorSets.html
func CmdBindDescriptorSets(commandBuffer CommandBuffer, pipelineBindPoint PipelineBindPoint, layout PipelineLayout, firstSet uint32, descriptorSets []DescriptorSet, dynamicOffsets []uint32) {
	descriptorSetCount := len(descriptorSets)
	// descriptorSets is an input slice of values that do not need translation used
	var pDescriptorSets unsafe.Pointer
	if descriptorSets != nil {
		pDescriptorSets = unsafe.Pointer(&descriptorSets[0])
	}

	dynamicOffsetCount := len(dynamicOffsets)
	// dynamicOffsets is an input slice of values that do not need translation used
	var pDynamicOffsets unsafe.Pointer
	if dynamicOffsets != nil {
		pDynamicOffsets = unsafe.Pointer(&dynamicOffsets[0])
	}

	execTrampoline(keyvkCmdBindDescriptorSets, uintptr(commandBuffer), uintptr(pipelineBindPoint), uintptr(layout), uintptr(firstSet), uintptr(descriptorSetCount), uintptr(unsafe.Pointer(pDescriptorSets)), uintptr(dynamicOffsetCount), uintptr(unsafe.Pointer(pDynamicOffsets)))

}

// CmdBindIndexBuffer: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBindIndexBuffer.html
func CmdBindIndexBuffer(commandBuffer CommandBuffer, buffer Buffer, offset DeviceSize, indexType IndexType) {

	execTrampoline(keyvkCmdBindIndexBuffer, uintptr(commandBuffer), uintptr(buffer), uintptr(offset), uintptr(indexType))

}

// CmdBindInvocationMaskHUAWEI: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBindInvocationMaskHUAWEI.html
func CmdBindInvocationMaskHUAWEI(commandBuffer CommandBuffer, imageView ImageView, imageLayout ImageLayout) {

	execTrampoline(keyvkCmdBindInvocationMaskHUAWEI, uintptr(commandBuffer), uintptr(imageView), uintptr(imageLayout))

}

// CmdBindPipeline: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBindPipeline.html
func CmdBindPipeline(commandBuffer CommandBuffer, pipelineBindPoint PipelineBindPoint, pipeline Pipeline) {

	execTrampoline(keyvkCmdBindPipeline, uintptr(commandBuffer), uintptr(pipelineBindPoint), uintptr(pipeline))

}

// CmdBindPipelineShaderGroupNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBindPipelineShaderGroupNV.html
func CmdBindPipelineShaderGroupNV(commandBuffer CommandBuffer, pipelineBindPoint PipelineBindPoint, pipeline Pipeline, groupIndex uint32) {

	execTrampoline(keyvkCmdBindPipelineShaderGroupNV, uintptr(commandBuffer), uintptr(pipelineBindPoint), uintptr(pipeline), uintptr(groupIndex))

}

// CmdBindShadingRateImageNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBindShadingRateImageNV.html
func CmdBindShadingRateImageNV(commandBuffer CommandBuffer, imageView ImageView, imageLayout ImageLayout) {

	execTrampoline(keyvkCmdBindShadingRateImageNV, uintptr(commandBuffer), uintptr(imageView), uintptr(imageLayout))

}

// CmdBindTransformFeedbackBuffersEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBindTransformFeedbackBuffersEXT.html
func CmdBindTransformFeedbackBuffersEXT(commandBuffer CommandBuffer, firstBinding uint32, buffers []Buffer, offsets []DeviceSize, sizes []DeviceSize) {
	bindingCount := len(buffers)
	// buffers is an input slice of values that do not need translation used
	var pBuffers unsafe.Pointer
	if buffers != nil {
		pBuffers = unsafe.Pointer(&buffers[0])
	}

	// offsets is an input slice of values that do not need translation used
	var pOffsets unsafe.Pointer
	if offsets != nil {
		pOffsets = unsafe.Pointer(&offsets[0])
	}

	// sizes is an input slice of values that do not need translation used
	var pSizes unsafe.Pointer
	if sizes != nil {
		pSizes = unsafe.Pointer(&sizes[0])
	}

	execTrampoline(keyvkCmdBindTransformFeedbackBuffersEXT, uintptr(commandBuffer), uintptr(firstBinding), uintptr(bindingCount), uintptr(unsafe.Pointer(pBuffers)), uintptr(unsafe.Pointer(pOffsets)), uintptr(unsafe.Pointer(pSizes)))

}

// CmdBindVertexBuffers: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBindVertexBuffers.html
func CmdBindVertexBuffers(commandBuffer CommandBuffer, firstBinding uint32, buffers []Buffer, offsets []DeviceSize) {
	bindingCount := len(buffers)
	// buffers is an input slice of values that do not need translation used
	var pBuffers unsafe.Pointer
	if buffers != nil {
		pBuffers = unsafe.Pointer(&buffers[0])
	}

	// offsets is an input slice of values that do not need translation used
	var pOffsets unsafe.Pointer
	if offsets != nil {
		pOffsets = unsafe.Pointer(&offsets[0])
	}

	execTrampoline(keyvkCmdBindVertexBuffers, uintptr(commandBuffer), uintptr(firstBinding), uintptr(bindingCount), uintptr(unsafe.Pointer(pBuffers)), uintptr(unsafe.Pointer(pOffsets)))

}

// CmdBindVertexBuffers2: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBindVertexBuffers2.html
func CmdBindVertexBuffers2(commandBuffer CommandBuffer, firstBinding uint32, buffers []Buffer, offsets []DeviceSize, sizes []DeviceSize, strides []DeviceSize) {
	bindingCount := len(buffers)
	// buffers is an input slice of values that do not need translation used
	var pBuffers unsafe.Pointer
	if buffers != nil {
		pBuffers = unsafe.Pointer(&buffers[0])
	}

	// offsets is an input slice of values that do not need translation used
	var pOffsets unsafe.Pointer
	if offsets != nil {
		pOffsets = unsafe.Pointer(&offsets[0])
	}

	// sizes is an input slice of values that do not need translation used
	var pSizes unsafe.Pointer
	if sizes != nil {
		pSizes = unsafe.Pointer(&sizes[0])
	}

	// strides is an input slice of values that do not need translation used
	var pStrides unsafe.Pointer
	if strides != nil {
		pStrides = unsafe.Pointer(&strides[0])
	}

	execTrampoline(keyvkCmdBindVertexBuffers2, uintptr(commandBuffer), uintptr(firstBinding), uintptr(bindingCount), uintptr(unsafe.Pointer(pBuffers)), uintptr(unsafe.Pointer(pOffsets)), uintptr(unsafe.Pointer(pSizes)), uintptr(unsafe.Pointer(pStrides)))

}

var CmdBindVertexBuffers2EXT = CmdBindVertexBuffers2

// CmdBlitImage: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBlitImage.html
func CmdBlitImage(commandBuffer CommandBuffer, srcImage Image, srcImageLayout ImageLayout, dstImage Image, dstImageLayout ImageLayout, regions []ImageBlit, filter Filter) {
	regionCount := len(regions)
	// regions is an input slice that requires translation to an internal type
	var pRegions unsafe.Pointer
	if len(regions) > 0 {
		sl_regions := make([]_vkImageBlit, regionCount)
		for i, v := range regions {
			sl_regions[i] = *(v.Vulkanize())
		}
		pRegions = unsafe.Pointer(&sl_regions[0])
	}

	execTrampoline(keyvkCmdBlitImage, uintptr(commandBuffer), uintptr(srcImage), uintptr(srcImageLayout), uintptr(dstImage), uintptr(dstImageLayout), uintptr(regionCount), uintptr(unsafe.Pointer(pRegions)), uintptr(filter))

}

// CmdBlitImage2: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBlitImage2.html
func CmdBlitImage2(commandBuffer CommandBuffer, blitImageInfo *BlitImageInfo2) {
	// Parameter is a singular input, requires translation - blitImageInfo
	var pBlitImageInfo *_vkBlitImageInfo2
	if blitImageInfo != nil {
		pBlitImageInfo = blitImageInfo.Vulkanize()
	}

	execTrampoline(keyvkCmdBlitImage2, uintptr(commandBuffer), uintptr(unsafe.Pointer(pBlitImageInfo)))

}

var CmdBlitImage2KHR = CmdBlitImage2

// CmdBuildAccelerationStructureNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBuildAccelerationStructureNV.html
func CmdBuildAccelerationStructureNV(commandBuffer CommandBuffer, info *AccelerationStructureInfoNV, instanceData Buffer, instanceOffset DeviceSize, update bool, dst AccelerationStructureNV, src AccelerationStructureNV, scratch Buffer, scratchOffset DeviceSize) {
	// Parameter is a singular input, requires translation - info
	var pInfo *_vkAccelerationStructureInfoNV
	if info != nil {
		pInfo = info.Vulkanize()
	}

	update_Bool32 := translateInternal_Bool32(update)

	execTrampoline(keyvkCmdBuildAccelerationStructureNV, uintptr(commandBuffer), uintptr(unsafe.Pointer(pInfo)), uintptr(instanceData), uintptr(instanceOffset), uintptr(update_Bool32), uintptr(dst), uintptr(src), uintptr(scratch), uintptr(scratchOffset))

}

// CmdBuildAccelerationStructuresIndirectKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBuildAccelerationStructuresIndirectKHR.html
func CmdBuildAccelerationStructuresIndirectKHR(commandBuffer CommandBuffer, infos []AccelerationStructureBuildGeometryInfoKHR, indirectDeviceAddresses []DeviceAddress, indirectStrides []uint32, pMaxPrimitiveCounts []*uint32) {
	infoCount := len(infos)
	// infos is an input slice that requires translation to an internal type
	var pInfos unsafe.Pointer
	if len(infos) > 0 {
		sl_infos := make([]_vkAccelerationStructureBuildGeometryInfoKHR, infoCount)
		for i, v := range infos {
			sl_infos[i] = *(v.Vulkanize())
		}
		pInfos = unsafe.Pointer(&sl_infos[0])
	}

	// indirectDeviceAddresses is an input slice of values that do not need translation used
	var pIndirectDeviceAddresses unsafe.Pointer
	if indirectDeviceAddresses != nil {
		pIndirectDeviceAddresses = unsafe.Pointer(&indirectDeviceAddresses[0])
	}

	// indirectStrides is an input slice of values that do not need translation used
	var pIndirectStrides unsafe.Pointer
	if indirectStrides != nil {
		pIndirectStrides = unsafe.Pointer(&indirectStrides[0])
	}

	// pMaxPrimitiveCounts is an input slice of values that do not need translation used
	var ppMaxPrimitiveCounts unsafe.Pointer
	if pMaxPrimitiveCounts != nil {
		ppMaxPrimitiveCounts = unsafe.Pointer(&pMaxPrimitiveCounts[0])
	}

	execTrampoline(keyvkCmdBuildAccelerationStructuresIndirectKHR, uintptr(commandBuffer), uintptr(infoCount), uintptr(unsafe.Pointer(pInfos)), uintptr(unsafe.Pointer(pIndirectDeviceAddresses)), uintptr(unsafe.Pointer(pIndirectStrides)), uintptr(unsafe.Pointer(ppMaxPrimitiveCounts)))

}

// CmdBuildAccelerationStructuresKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBuildAccelerationStructuresKHR.html
func CmdBuildAccelerationStructuresKHR(commandBuffer CommandBuffer, infos []AccelerationStructureBuildGeometryInfoKHR, pBuildRangeInfos []*AccelerationStructureBuildRangeInfoKHR) {
	infoCount := len(infos)
	// infos is an input slice that requires translation to an internal type
	var pInfos unsafe.Pointer
	if len(infos) > 0 {
		sl_infos := make([]_vkAccelerationStructureBuildGeometryInfoKHR, infoCount)
		for i, v := range infos {
			sl_infos[i] = *(v.Vulkanize())
		}
		pInfos = unsafe.Pointer(&sl_infos[0])
	}

	// pBuildRangeInfos is an input slice of values that do not need translation used
	var ppBuildRangeInfos unsafe.Pointer
	if pBuildRangeInfos != nil {
		ppBuildRangeInfos = unsafe.Pointer(&pBuildRangeInfos[0])
	}

	execTrampoline(keyvkCmdBuildAccelerationStructuresKHR, uintptr(commandBuffer), uintptr(infoCount), uintptr(unsafe.Pointer(pInfos)), uintptr(unsafe.Pointer(ppBuildRangeInfos)))

}

// CmdBuildMicromapsEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdBuildMicromapsEXT.html
func CmdBuildMicromapsEXT(commandBuffer CommandBuffer, infos []MicromapBuildInfoEXT) {
	infoCount := len(infos)
	// infos is an input slice that requires translation to an internal type
	var pInfos unsafe.Pointer
	if len(infos) > 0 {
		sl_infos := make([]_vkMicromapBuildInfoEXT, infoCount)
		for i, v := range infos {
			sl_infos[i] = *(v.Vulkanize())
		}
		pInfos = unsafe.Pointer(&sl_infos[0])
	}

	execTrampoline(keyvkCmdBuildMicromapsEXT, uintptr(commandBuffer), uintptr(infoCount), uintptr(unsafe.Pointer(pInfos)))

}

// CmdClearAttachments: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdClearAttachments.html
func CmdClearAttachments(commandBuffer CommandBuffer, attachments []ClearAttachment, rects []ClearRect) {
	attachmentCount := len(attachments)
	// attachments is an input slice that requires translation to an internal type
	var pAttachments unsafe.Pointer
	if len(attachments) > 0 {
		sl_attachments := make([]_vkClearAttachment, attachmentCount)
		for i, v := range attachments {
			sl_attachments[i] = *(v.Vulkanize())
		}
		pAttachments = unsafe.Pointer(&sl_attachments[0])
	}

	rectCount := len(rects)
	// rects is an input slice that requires translation to an internal type
	var pRects unsafe.Pointer
	if len(rects) > 0 {
		sl_rects := make([]_vkClearRect, rectCount)
		for i, v := range rects {
			sl_rects[i] = *(v.Vulkanize())
		}
		pRects = unsafe.Pointer(&sl_rects[0])
	}

	execTrampoline(keyvkCmdClearAttachments, uintptr(commandBuffer), uintptr(attachmentCount), uintptr(unsafe.Pointer(pAttachments)), uintptr(rectCount), uintptr(unsafe.Pointer(pRects)))

}

// CmdClearColorImage: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdClearColorImage.html
func CmdClearColorImage(commandBuffer CommandBuffer, image Image, imageLayout ImageLayout, color *ClearColorValue, ranges []ImageSubresourceRange) {
	// Parameter is a singular input, requires translation - color
	var pColor *_vkClearColorValue
	if color != nil {
		pColor = color.Vulkanize()
	}

	rangeCount := len(ranges)
	// ranges is an input slice of values that do not need translation used
	var pRanges unsafe.Pointer
	if ranges != nil {
		pRanges = unsafe.Pointer(&ranges[0])
	}

	execTrampoline(keyvkCmdClearColorImage, uintptr(commandBuffer), uintptr(image), uintptr(imageLayout), uintptr(unsafe.Pointer(pColor)), uintptr(rangeCount), uintptr(unsafe.Pointer(pRanges)))

}

// CmdClearDepthStencilImage: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdClearDepthStencilImage.html
func CmdClearDepthStencilImage(commandBuffer CommandBuffer, image Image, imageLayout ImageLayout, depthStencil *ClearDepthStencilValue, ranges []ImageSubresourceRange) {
	// Parameter is a singular input, pass direct - depthStencil
	var pDepthStencil unsafe.Pointer
	if depthStencil != nil {
		pDepthStencil = unsafe.Pointer(depthStencil)
	}

	rangeCount := len(ranges)
	// ranges is an input slice of values that do not need translation used
	var pRanges unsafe.Pointer
	if ranges != nil {
		pRanges = unsafe.Pointer(&ranges[0])
	}

	execTrampoline(keyvkCmdClearDepthStencilImage, uintptr(commandBuffer), uintptr(image), uintptr(imageLayout), uintptr(unsafe.Pointer(pDepthStencil)), uintptr(rangeCount), uintptr(unsafe.Pointer(pRanges)))

}

// CmdControlVideoCodingKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdControlVideoCodingKHR.html
func CmdControlVideoCodingKHR(commandBuffer CommandBuffer, codingControlInfo *VideoCodingControlInfoKHR) {
	// Parameter is a singular input, requires translation - codingControlInfo
	var pCodingControlInfo *_vkVideoCodingControlInfoKHR
	if codingControlInfo != nil {
		pCodingControlInfo = codingControlInfo.Vulkanize()
	}

	execTrampoline(keyvkCmdControlVideoCodingKHR, uintptr(commandBuffer), uintptr(unsafe.Pointer(pCodingControlInfo)))

}

// CmdCopyAccelerationStructureKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdCopyAccelerationStructureKHR.html
func CmdCopyAccelerationStructureKHR(commandBuffer CommandBuffer, info *CopyAccelerationStructureInfoKHR) {
	// Parameter is a singular input, requires translation - info
	var pInfo *_vkCopyAccelerationStructureInfoKHR
	if info != nil {
		pInfo = info.Vulkanize()
	}

	execTrampoline(keyvkCmdCopyAccelerationStructureKHR, uintptr(commandBuffer), uintptr(unsafe.Pointer(pInfo)))

}

// CmdCopyAccelerationStructureNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdCopyAccelerationStructureNV.html
func CmdCopyAccelerationStructureNV(commandBuffer CommandBuffer, dst AccelerationStructureNV, src AccelerationStructureNV, mode CopyAccelerationStructureModeKHR) {

	execTrampoline(keyvkCmdCopyAccelerationStructureNV, uintptr(commandBuffer), uintptr(dst), uintptr(src), uintptr(mode))

}

// CmdCopyAccelerationStructureToMemoryKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdCopyAccelerationStructureToMemoryKHR.html
func CmdCopyAccelerationStructureToMemoryKHR(commandBuffer CommandBuffer, info *CopyAccelerationStructureToMemoryInfoKHR) {
	// Parameter is a singular input, requires translation - info
	var pInfo *_vkCopyAccelerationStructureToMemoryInfoKHR
	if info != nil {
		pInfo = info.Vulkanize()
	}

	execTrampoline(keyvkCmdCopyAccelerationStructureToMemoryKHR, uintptr(commandBuffer), uintptr(unsafe.Pointer(pInfo)))

}

// CmdCopyBuffer: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdCopyBuffer.html
func CmdCopyBuffer(commandBuffer CommandBuffer, srcBuffer Buffer, dstBuffer Buffer, regions []BufferCopy) {
	regionCount := len(regions)
	// regions is an input slice of values that do not need translation used
	var pRegions unsafe.Pointer
	if regions != nil {
		pRegions = unsafe.Pointer(&regions[0])
	}

	execTrampoline(keyvkCmdCopyBuffer, uintptr(commandBuffer), uintptr(srcBuffer), uintptr(dstBuffer), uintptr(regionCount), uintptr(unsafe.Pointer(pRegions)))

}

// CmdCopyBuffer2: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdCopyBuffer2.html
func CmdCopyBuffer2(commandBuffer CommandBuffer, copyBufferInfo *CopyBufferInfo2) {
	// Parameter is a singular input, requires translation - copyBufferInfo
	var pCopyBufferInfo *_vkCopyBufferInfo2
	if copyBufferInfo != nil {
		pCopyBufferInfo = copyBufferInfo.Vulkanize()
	}

	execTrampoline(keyvkCmdCopyBuffer2, uintptr(commandBuffer), uintptr(unsafe.Pointer(pCopyBufferInfo)))

}

var CmdCopyBuffer2KHR = CmdCopyBuffer2

// CmdCopyBufferToImage: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdCopyBufferToImage.html
func CmdCopyBufferToImage(commandBuffer CommandBuffer, srcBuffer Buffer, dstImage Image, dstImageLayout ImageLayout, regions []BufferImageCopy) {
	regionCount := len(regions)
	// regions is an input slice that requires translation to an internal type
	var pRegions unsafe.Pointer
	if len(regions) > 0 {
		sl_regions := make([]_vkBufferImageCopy, regionCount)
		for i, v := range regions {
			sl_regions[i] = *(v.Vulkanize())
		}
		pRegions = unsafe.Pointer(&sl_regions[0])
	}

	execTrampoline(keyvkCmdCopyBufferToImage, uintptr(commandBuffer), uintptr(srcBuffer), uintptr(dstImage), uintptr(dstImageLayout), uintptr(regionCount), uintptr(unsafe.Pointer(pRegions)))

}

// CmdCopyBufferToImage2: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdCopyBufferToImage2.html
func CmdCopyBufferToImage2(commandBuffer CommandBuffer, copyBufferToImageInfo *CopyBufferToImageInfo2) {
	// Parameter is a singular input, requires translation - copyBufferToImageInfo
	var pCopyBufferToImageInfo *_vkCopyBufferToImageInfo2
	if copyBufferToImageInfo != nil {
		pCopyBufferToImageInfo = copyBufferToImageInfo.Vulkanize()
	}

	execTrampoline(keyvkCmdCopyBufferToImage2, uintptr(commandBuffer), uintptr(unsafe.Pointer(pCopyBufferToImageInfo)))

}

var CmdCopyBufferToImage2KHR = CmdCopyBufferToImage2

// CmdCopyImage: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdCopyImage.html
func CmdCopyImage(commandBuffer CommandBuffer, srcImage Image, srcImageLayout ImageLayout, dstImage Image, dstImageLayout ImageLayout, regions []ImageCopy) {
	regionCount := len(regions)
	// regions is an input slice that requires translation to an internal type
	var pRegions unsafe.Pointer
	if len(regions) > 0 {
		sl_regions := make([]_vkImageCopy, regionCount)
		for i, v := range regions {
			sl_regions[i] = *(v.Vulkanize())
		}
		pRegions = unsafe.Pointer(&sl_regions[0])
	}

	execTrampoline(keyvkCmdCopyImage, uintptr(commandBuffer), uintptr(srcImage), uintptr(srcImageLayout), uintptr(dstImage), uintptr(dstImageLayout), uintptr(regionCount), uintptr(unsafe.Pointer(pRegions)))

}

// CmdCopyImage2: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdCopyImage2.html
func CmdCopyImage2(commandBuffer CommandBuffer, copyImageInfo *CopyImageInfo2) {
	// Parameter is a singular input, requires translation - copyImageInfo
	var pCopyImageInfo *_vkCopyImageInfo2
	if copyImageInfo != nil {
		pCopyImageInfo = copyImageInfo.Vulkanize()
	}

	execTrampoline(keyvkCmdCopyImage2, uintptr(commandBuffer), uintptr(unsafe.Pointer(pCopyImageInfo)))

}

var CmdCopyImage2KHR = CmdCopyImage2

// CmdCopyImageToBuffer: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdCopyImageToBuffer.html
func CmdCopyImageToBuffer(commandBuffer CommandBuffer, srcImage Image, srcImageLayout ImageLayout, dstBuffer Buffer, regions []BufferImageCopy) {
	regionCount := len(regions)
	// regions is an input slice that requires translation to an internal type
	var pRegions unsafe.Pointer
	if len(regions) > 0 {
		sl_regions := make([]_vkBufferImageCopy, regionCount)
		for i, v := range regions {
			sl_regions[i] = *(v.Vulkanize())
		}
		pRegions = unsafe.Pointer(&sl_regions[0])
	}

	execTrampoline(keyvkCmdCopyImageToBuffer, uintptr(commandBuffer), uintptr(srcImage), uintptr(srcImageLayout), uintptr(dstBuffer), uintptr(regionCount), uintptr(unsafe.Pointer(pRegions)))

}

// CmdCopyImageToBuffer2: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdCopyImageToBuffer2.html
func CmdCopyImageToBuffer2(commandBuffer CommandBuffer, copyImageToBufferInfo *CopyImageToBufferInfo2) {
	// Parameter is a singular input, requires translation - copyImageToBufferInfo
	var pCopyImageToBufferInfo *_vkCopyImageToBufferInfo2
	if copyImageToBufferInfo != nil {
		pCopyImageToBufferInfo = copyImageToBufferInfo.Vulkanize()
	}

	execTrampoline(keyvkCmdCopyImageToBuffer2, uintptr(commandBuffer), uintptr(unsafe.Pointer(pCopyImageToBufferInfo)))

}

var CmdCopyImageToBuffer2KHR = CmdCopyImageToBuffer2

// CmdCopyMemoryIndirectNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdCopyMemoryIndirectNV.html
func CmdCopyMemoryIndirectNV(commandBuffer CommandBuffer, copyBufferAddress DeviceAddress, copyCount uint32, stride uint32) {

	execTrampoline(keyvkCmdCopyMemoryIndirectNV, uintptr(commandBuffer), uintptr(copyBufferAddress), uintptr(copyCount), uintptr(stride))

}

// CmdCopyMemoryToAccelerationStructureKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdCopyMemoryToAccelerationStructureKHR.html
func CmdCopyMemoryToAccelerationStructureKHR(commandBuffer CommandBuffer, info *CopyMemoryToAccelerationStructureInfoKHR) {
	// Parameter is a singular input, requires translation - info
	var pInfo *_vkCopyMemoryToAccelerationStructureInfoKHR
	if info != nil {
		pInfo = info.Vulkanize()
	}

	execTrampoline(keyvkCmdCopyMemoryToAccelerationStructureKHR, uintptr(commandBuffer), uintptr(unsafe.Pointer(pInfo)))

}

// CmdCopyMemoryToImageIndirectNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdCopyMemoryToImageIndirectNV.html
func CmdCopyMemoryToImageIndirectNV(commandBuffer CommandBuffer, copyBufferAddress DeviceAddress, stride uint32, dstImage Image, dstImageLayout ImageLayout, imageSubresources []ImageSubresourceLayers) {
	copyCount := len(imageSubresources)
	// imageSubresources is an input slice of values that do not need translation used
	var pImageSubresources unsafe.Pointer
	if imageSubresources != nil {
		pImageSubresources = unsafe.Pointer(&imageSubresources[0])
	}

	execTrampoline(keyvkCmdCopyMemoryToImageIndirectNV, uintptr(commandBuffer), uintptr(copyBufferAddress), uintptr(copyCount), uintptr(stride), uintptr(dstImage), uintptr(dstImageLayout), uintptr(unsafe.Pointer(pImageSubresources)))

}

// CmdCopyMemoryToMicromapEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdCopyMemoryToMicromapEXT.html
func CmdCopyMemoryToMicromapEXT(commandBuffer CommandBuffer, info *CopyMemoryToMicromapInfoEXT) {
	// Parameter is a singular input, requires translation - info
	var pInfo *_vkCopyMemoryToMicromapInfoEXT
	if info != nil {
		pInfo = info.Vulkanize()
	}

	execTrampoline(keyvkCmdCopyMemoryToMicromapEXT, uintptr(commandBuffer), uintptr(unsafe.Pointer(pInfo)))

}

// CmdCopyMicromapEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdCopyMicromapEXT.html
func CmdCopyMicromapEXT(commandBuffer CommandBuffer, info *CopyMicromapInfoEXT) {
	// Parameter is a singular input, requires translation - info
	var pInfo *_vkCopyMicromapInfoEXT
	if info != nil {
		pInfo = info.Vulkanize()
	}

	execTrampoline(keyvkCmdCopyMicromapEXT, uintptr(commandBuffer), uintptr(unsafe.Pointer(pInfo)))

}

// CmdCopyMicromapToMemoryEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdCopyMicromapToMemoryEXT.html
func CmdCopyMicromapToMemoryEXT(commandBuffer CommandBuffer, info *CopyMicromapToMemoryInfoEXT) {
	// Parameter is a singular input, requires translation - info
	var pInfo *_vkCopyMicromapToMemoryInfoEXT
	if info != nil {
		pInfo = info.Vulkanize()
	}

	execTrampoline(keyvkCmdCopyMicromapToMemoryEXT, uintptr(commandBuffer), uintptr(unsafe.Pointer(pInfo)))

}

// CmdCopyQueryPoolResults: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdCopyQueryPoolResults.html
func CmdCopyQueryPoolResults(commandBuffer CommandBuffer, queryPool QueryPool, firstQuery uint32, queryCount uint32, dstBuffer Buffer, dstOffset DeviceSize, stride DeviceSize, flags QueryResultFlags) {

	execTrampoline(keyvkCmdCopyQueryPoolResults, uintptr(commandBuffer), uintptr(queryPool), uintptr(firstQuery), uintptr(queryCount), uintptr(dstBuffer), uintptr(dstOffset), uintptr(stride), uintptr(flags))

}

// CmdCuLaunchKernelNVX: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdCuLaunchKernelNVX.html
func CmdCuLaunchKernelNVX(commandBuffer CommandBuffer, launchInfo *CuLaunchInfoNVX) {
	// Parameter is a singular input, requires translation - launchInfo
	var pLaunchInfo *_vkCuLaunchInfoNVX
	if launchInfo != nil {
		pLaunchInfo = launchInfo.Vulkanize()
	}

	execTrampoline(keyvkCmdCuLaunchKernelNVX, uintptr(commandBuffer), uintptr(unsafe.Pointer(pLaunchInfo)))

}

// CmdDebugMarkerBeginEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDebugMarkerBeginEXT.html
func CmdDebugMarkerBeginEXT(commandBuffer CommandBuffer, markerInfo *DebugMarkerMarkerInfoEXT) {
	// Parameter is a singular input, requires translation - markerInfo
	var pMarkerInfo *_vkDebugMarkerMarkerInfoEXT
	if markerInfo != nil {
		pMarkerInfo = markerInfo.Vulkanize()
	}

	execTrampoline(keyvkCmdDebugMarkerBeginEXT, uintptr(commandBuffer), uintptr(unsafe.Pointer(pMarkerInfo)))

}

// CmdDebugMarkerEndEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDebugMarkerEndEXT.html
func CmdDebugMarkerEndEXT(commandBuffer CommandBuffer) {

	execTrampoline(keyvkCmdDebugMarkerEndEXT, uintptr(commandBuffer))

}

// CmdDebugMarkerInsertEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDebugMarkerInsertEXT.html
func CmdDebugMarkerInsertEXT(commandBuffer CommandBuffer, markerInfo *DebugMarkerMarkerInfoEXT) {
	// Parameter is a singular input, requires translation - markerInfo
	var pMarkerInfo *_vkDebugMarkerMarkerInfoEXT
	if markerInfo != nil {
		pMarkerInfo = markerInfo.Vulkanize()
	}

	execTrampoline(keyvkCmdDebugMarkerInsertEXT, uintptr(commandBuffer), uintptr(unsafe.Pointer(pMarkerInfo)))

}

// CmdDecodeVideoKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDecodeVideoKHR.html
func CmdDecodeVideoKHR(commandBuffer CommandBuffer, decodeInfo *VideoDecodeInfoKHR) {
	// Parameter is a singular input, requires translation - decodeInfo
	var pDecodeInfo *_vkVideoDecodeInfoKHR
	if decodeInfo != nil {
		pDecodeInfo = decodeInfo.Vulkanize()
	}

	execTrampoline(keyvkCmdDecodeVideoKHR, uintptr(commandBuffer), uintptr(unsafe.Pointer(pDecodeInfo)))

}

// CmdDecompressMemoryIndirectCountNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDecompressMemoryIndirectCountNV.html
func CmdDecompressMemoryIndirectCountNV(commandBuffer CommandBuffer, indirectCommandsAddress DeviceAddress, indirectCommandsCountAddress DeviceAddress, stride uint32) {

	execTrampoline(keyvkCmdDecompressMemoryIndirectCountNV, uintptr(commandBuffer), uintptr(indirectCommandsAddress), uintptr(indirectCommandsCountAddress), uintptr(stride))

}

// CmdDecompressMemoryNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDecompressMemoryNV.html
func CmdDecompressMemoryNV(commandBuffer CommandBuffer, decompressMemoryRegions []DecompressMemoryRegionNV) {
	decompressRegionCount := len(decompressMemoryRegions)
	// decompressMemoryRegions is an input slice of values that do not need translation used
	var pDecompressMemoryRegions unsafe.Pointer
	if decompressMemoryRegions != nil {
		pDecompressMemoryRegions = unsafe.Pointer(&decompressMemoryRegions[0])
	}

	execTrampoline(keyvkCmdDecompressMemoryNV, uintptr(commandBuffer), uintptr(decompressRegionCount), uintptr(unsafe.Pointer(pDecompressMemoryRegions)))

}

// CmdDispatch: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDispatch.html
func CmdDispatch(commandBuffer CommandBuffer, groupCountX uint32, groupCountY uint32, groupCountZ uint32) {

	execTrampoline(keyvkCmdDispatch, uintptr(commandBuffer), uintptr(groupCountX), uintptr(groupCountY), uintptr(groupCountZ))

}

// CmdDispatchBase: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDispatchBase.html
func CmdDispatchBase(commandBuffer CommandBuffer, baseGroupX uint32, baseGroupY uint32, baseGroupZ uint32, groupCountX uint32, groupCountY uint32, groupCountZ uint32) {

	execTrampoline(keyvkCmdDispatchBase, uintptr(commandBuffer), uintptr(baseGroupX), uintptr(baseGroupY), uintptr(baseGroupZ), uintptr(groupCountX), uintptr(groupCountY), uintptr(groupCountZ))

}

var CmdDispatchBaseKHR = CmdDispatchBase

// CmdDispatchIndirect: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDispatchIndirect.html
func CmdDispatchIndirect(commandBuffer CommandBuffer, buffer Buffer, offset DeviceSize) {

	execTrampoline(keyvkCmdDispatchIndirect, uintptr(commandBuffer), uintptr(buffer), uintptr(offset))

}

// CmdDraw: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDraw.html
func CmdDraw(commandBuffer CommandBuffer, vertexCount uint32, instanceCount uint32, firstVertex uint32, firstInstance uint32) {

	execTrampoline(keyvkCmdDraw, uintptr(commandBuffer), uintptr(vertexCount), uintptr(instanceCount), uintptr(firstVertex), uintptr(firstInstance))

}

// CmdDrawClusterHUAWEI: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDrawClusterHUAWEI.html
func CmdDrawClusterHUAWEI(commandBuffer CommandBuffer, groupCountX uint32, groupCountY uint32, groupCountZ uint32) {

	execTrampoline(keyvkCmdDrawClusterHUAWEI, uintptr(commandBuffer), uintptr(groupCountX), uintptr(groupCountY), uintptr(groupCountZ))

}

// CmdDrawClusterIndirectHUAWEI: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDrawClusterIndirectHUAWEI.html
func CmdDrawClusterIndirectHUAWEI(commandBuffer CommandBuffer, buffer Buffer, offset DeviceSize) {

	execTrampoline(keyvkCmdDrawClusterIndirectHUAWEI, uintptr(commandBuffer), uintptr(buffer), uintptr(offset))

}

// CmdDrawIndexed: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDrawIndexed.html
func CmdDrawIndexed(commandBuffer CommandBuffer, indexCount uint32, instanceCount uint32, firstIndex uint32, vertexOffset int32, firstInstance uint32) {

	execTrampoline(keyvkCmdDrawIndexed, uintptr(commandBuffer), uintptr(indexCount), uintptr(instanceCount), uintptr(firstIndex), uintptr(vertexOffset), uintptr(firstInstance))

}

// CmdDrawIndexedIndirect: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDrawIndexedIndirect.html
func CmdDrawIndexedIndirect(commandBuffer CommandBuffer, buffer Buffer, offset DeviceSize, drawCount uint32, stride uint32) {

	execTrampoline(keyvkCmdDrawIndexedIndirect, uintptr(commandBuffer), uintptr(buffer), uintptr(offset), uintptr(drawCount), uintptr(stride))

}

// CmdDrawIndexedIndirectCount: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDrawIndexedIndirectCount.html
func CmdDrawIndexedIndirectCount(commandBuffer CommandBuffer, buffer Buffer, offset DeviceSize, countBuffer Buffer, countBufferOffset DeviceSize, maxDrawCount uint32, stride uint32) {

	execTrampoline(keyvkCmdDrawIndexedIndirectCount, uintptr(commandBuffer), uintptr(buffer), uintptr(offset), uintptr(countBuffer), uintptr(countBufferOffset), uintptr(maxDrawCount), uintptr(stride))

}

var CmdDrawIndexedIndirectCountAMD = CmdDrawIndexedIndirectCount

var CmdDrawIndexedIndirectCountKHR = CmdDrawIndexedIndirectCount

// CmdDrawIndirect: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDrawIndirect.html
func CmdDrawIndirect(commandBuffer CommandBuffer, buffer Buffer, offset DeviceSize, drawCount uint32, stride uint32) {

	execTrampoline(keyvkCmdDrawIndirect, uintptr(commandBuffer), uintptr(buffer), uintptr(offset), uintptr(drawCount), uintptr(stride))

}

// CmdDrawIndirectByteCountEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDrawIndirectByteCountEXT.html
func CmdDrawIndirectByteCountEXT(commandBuffer CommandBuffer, instanceCount uint32, firstInstance uint32, counterBuffer Buffer, counterBufferOffset DeviceSize, counterOffset uint32, vertexStride uint32) {

	execTrampoline(keyvkCmdDrawIndirectByteCountEXT, uintptr(commandBuffer), uintptr(instanceCount), uintptr(firstInstance), uintptr(counterBuffer), uintptr(counterBufferOffset), uintptr(counterOffset), uintptr(vertexStride))

}

// CmdDrawIndirectCount: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDrawIndirectCount.html
func CmdDrawIndirectCount(commandBuffer CommandBuffer, buffer Buffer, offset DeviceSize, countBuffer Buffer, countBufferOffset DeviceSize, maxDrawCount uint32, stride uint32) {

	execTrampoline(keyvkCmdDrawIndirectCount, uintptr(commandBuffer), uintptr(buffer), uintptr(offset), uintptr(countBuffer), uintptr(countBufferOffset), uintptr(maxDrawCount), uintptr(stride))

}

var CmdDrawIndirectCountAMD = CmdDrawIndirectCount

var CmdDrawIndirectCountKHR = CmdDrawIndirectCount

// CmdDrawMeshTasksEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDrawMeshTasksEXT.html
func CmdDrawMeshTasksEXT(commandBuffer CommandBuffer, groupCountX uint32, groupCountY uint32, groupCountZ uint32) {

	execTrampoline(keyvkCmdDrawMeshTasksEXT, uintptr(commandBuffer), uintptr(groupCountX), uintptr(groupCountY), uintptr(groupCountZ))

}

// CmdDrawMeshTasksIndirectCountEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDrawMeshTasksIndirectCountEXT.html
func CmdDrawMeshTasksIndirectCountEXT(commandBuffer CommandBuffer, buffer Buffer, offset DeviceSize, countBuffer Buffer, countBufferOffset DeviceSize, maxDrawCount uint32, stride uint32) {

	execTrampoline(keyvkCmdDrawMeshTasksIndirectCountEXT, uintptr(commandBuffer), uintptr(buffer), uintptr(offset), uintptr(countBuffer), uintptr(countBufferOffset), uintptr(maxDrawCount), uintptr(stride))

}

// CmdDrawMeshTasksIndirectCountNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDrawMeshTasksIndirectCountNV.html
func CmdDrawMeshTasksIndirectCountNV(commandBuffer CommandBuffer, buffer Buffer, offset DeviceSize, countBuffer Buffer, countBufferOffset DeviceSize, maxDrawCount uint32, stride uint32) {

	execTrampoline(keyvkCmdDrawMeshTasksIndirectCountNV, uintptr(commandBuffer), uintptr(buffer), uintptr(offset), uintptr(countBuffer), uintptr(countBufferOffset), uintptr(maxDrawCount), uintptr(stride))

}

// CmdDrawMeshTasksIndirectEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDrawMeshTasksIndirectEXT.html
func CmdDrawMeshTasksIndirectEXT(commandBuffer CommandBuffer, buffer Buffer, offset DeviceSize, drawCount uint32, stride uint32) {

	execTrampoline(keyvkCmdDrawMeshTasksIndirectEXT, uintptr(commandBuffer), uintptr(buffer), uintptr(offset), uintptr(drawCount), uintptr(stride))

}

// CmdDrawMeshTasksIndirectNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDrawMeshTasksIndirectNV.html
func CmdDrawMeshTasksIndirectNV(commandBuffer CommandBuffer, buffer Buffer, offset DeviceSize, drawCount uint32, stride uint32) {

	execTrampoline(keyvkCmdDrawMeshTasksIndirectNV, uintptr(commandBuffer), uintptr(buffer), uintptr(offset), uintptr(drawCount), uintptr(stride))

}

// CmdDrawMeshTasksNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDrawMeshTasksNV.html
func CmdDrawMeshTasksNV(commandBuffer CommandBuffer, taskCount uint32, firstTask uint32) {

	execTrampoline(keyvkCmdDrawMeshTasksNV, uintptr(commandBuffer), uintptr(taskCount), uintptr(firstTask))

}

// CmdDrawMultiEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDrawMultiEXT.html
func CmdDrawMultiEXT(commandBuffer CommandBuffer, vertexInfo []MultiDrawInfoEXT, instanceCount uint32, firstInstance uint32, stride uint32) {
	drawCount := len(vertexInfo)
	// vertexInfo is an input slice of values that do not need translation used
	var pVertexInfo unsafe.Pointer
	if vertexInfo != nil {
		pVertexInfo = unsafe.Pointer(&vertexInfo[0])
	}

	execTrampoline(keyvkCmdDrawMultiEXT, uintptr(commandBuffer), uintptr(drawCount), uintptr(unsafe.Pointer(pVertexInfo)), uintptr(instanceCount), uintptr(firstInstance), uintptr(stride))

}

// CmdDrawMultiIndexedEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdDrawMultiIndexedEXT.html
func CmdDrawMultiIndexedEXT(commandBuffer CommandBuffer, indexInfo []MultiDrawIndexedInfoEXT, instanceCount uint32, firstInstance uint32, stride uint32, vertexOffset *int32) {
	drawCount := len(indexInfo)
	// indexInfo is an input slice of values that do not need translation used
	var pIndexInfo unsafe.Pointer
	if indexInfo != nil {
		pIndexInfo = unsafe.Pointer(&indexInfo[0])
	}

	// Parameter is a singular input, pass direct - vertexOffset
	var pVertexOffset unsafe.Pointer
	if vertexOffset != nil {
		pVertexOffset = unsafe.Pointer(vertexOffset)
	}

	execTrampoline(keyvkCmdDrawMultiIndexedEXT, uintptr(commandBuffer), uintptr(drawCount), uintptr(unsafe.Pointer(pIndexInfo)), uintptr(instanceCount), uintptr(firstInstance), uintptr(stride), uintptr(unsafe.Pointer(pVertexOffset)))

}

// CmdEndConditionalRenderingEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdEndConditionalRenderingEXT.html
func CmdEndConditionalRenderingEXT(commandBuffer CommandBuffer) {

	execTrampoline(keyvkCmdEndConditionalRenderingEXT, uintptr(commandBuffer))

}

// CmdEndDebugUtilsLabelEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdEndDebugUtilsLabelEXT.html
func CmdEndDebugUtilsLabelEXT(commandBuffer CommandBuffer) {

	execTrampoline(keyvkCmdEndDebugUtilsLabelEXT, uintptr(commandBuffer))

}

// CmdEndQuery: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdEndQuery.html
func CmdEndQuery(commandBuffer CommandBuffer, queryPool QueryPool, query uint32) {

	execTrampoline(keyvkCmdEndQuery, uintptr(commandBuffer), uintptr(queryPool), uintptr(query))

}

// CmdEndQueryIndexedEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdEndQueryIndexedEXT.html
func CmdEndQueryIndexedEXT(commandBuffer CommandBuffer, queryPool QueryPool, query uint32, index uint32) {

	execTrampoline(keyvkCmdEndQueryIndexedEXT, uintptr(commandBuffer), uintptr(queryPool), uintptr(query), uintptr(index))

}

// CmdEndRenderPass: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdEndRenderPass.html
func CmdEndRenderPass(commandBuffer CommandBuffer) {

	execTrampoline(keyvkCmdEndRenderPass, uintptr(commandBuffer))

}

// CmdEndRenderPass2: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdEndRenderPass2.html
func CmdEndRenderPass2(commandBuffer CommandBuffer, subpassEndInfo *SubpassEndInfo) {
	// Parameter is a singular input, requires translation - subpassEndInfo
	var pSubpassEndInfo *_vkSubpassEndInfo
	if subpassEndInfo != nil {
		pSubpassEndInfo = subpassEndInfo.Vulkanize()
	}

	execTrampoline(keyvkCmdEndRenderPass2, uintptr(commandBuffer), uintptr(unsafe.Pointer(pSubpassEndInfo)))

}

var CmdEndRenderPass2KHR = CmdEndRenderPass2

// CmdEndRendering: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdEndRendering.html
func CmdEndRendering(commandBuffer CommandBuffer) {

	execTrampoline(keyvkCmdEndRendering, uintptr(commandBuffer))

}

var CmdEndRenderingKHR = CmdEndRendering

// CmdEndTransformFeedbackEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdEndTransformFeedbackEXT.html
func CmdEndTransformFeedbackEXT(commandBuffer CommandBuffer, firstCounterBuffer uint32, counterBuffers []Buffer, counterBufferOffsets []DeviceSize) {
	counterBufferCount := len(counterBuffers)
	// counterBuffers is an input slice of values that do not need translation used
	var pCounterBuffers unsafe.Pointer
	if counterBuffers != nil {
		pCounterBuffers = unsafe.Pointer(&counterBuffers[0])
	}

	// counterBufferOffsets is an input slice of values that do not need translation used
	var pCounterBufferOffsets unsafe.Pointer
	if counterBufferOffsets != nil {
		pCounterBufferOffsets = unsafe.Pointer(&counterBufferOffsets[0])
	}

	execTrampoline(keyvkCmdEndTransformFeedbackEXT, uintptr(commandBuffer), uintptr(firstCounterBuffer), uintptr(counterBufferCount), uintptr(unsafe.Pointer(pCounterBuffers)), uintptr(unsafe.Pointer(pCounterBufferOffsets)))

}

// CmdEndVideoCodingKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdEndVideoCodingKHR.html
func CmdEndVideoCodingKHR(commandBuffer CommandBuffer, endCodingInfo *VideoEndCodingInfoKHR) {
	// Parameter is a singular input, requires translation - endCodingInfo
	var pEndCodingInfo *_vkVideoEndCodingInfoKHR
	if endCodingInfo != nil {
		pEndCodingInfo = endCodingInfo.Vulkanize()
	}

	execTrampoline(keyvkCmdEndVideoCodingKHR, uintptr(commandBuffer), uintptr(unsafe.Pointer(pEndCodingInfo)))

}

// CmdExecuteCommands: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdExecuteCommands.html
func CmdExecuteCommands(commandBuffer CommandBuffer, commandBuffers []CommandBuffer) {
	commandBufferCount := len(commandBuffers)
	// commandBuffers is an input slice of values that do not need translation used
	var pCommandBuffers unsafe.Pointer
	if commandBuffers != nil {
		pCommandBuffers = unsafe.Pointer(&commandBuffers[0])
	}

	execTrampoline(keyvkCmdExecuteCommands, uintptr(commandBuffer), uintptr(commandBufferCount), uintptr(unsafe.Pointer(pCommandBuffers)))

}

// CmdExecuteGeneratedCommandsNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdExecuteGeneratedCommandsNV.html
func CmdExecuteGeneratedCommandsNV(commandBuffer CommandBuffer, isPreprocessed bool, generatedCommandsInfo *GeneratedCommandsInfoNV) {
	isPreprocessed_Bool32 := translateInternal_Bool32(isPreprocessed)
	// Parameter is a singular input, requires translation - generatedCommandsInfo
	var pGeneratedCommandsInfo *_vkGeneratedCommandsInfoNV
	if generatedCommandsInfo != nil {
		pGeneratedCommandsInfo = generatedCommandsInfo.Vulkanize()
	}

	execTrampoline(keyvkCmdExecuteGeneratedCommandsNV, uintptr(commandBuffer), uintptr(isPreprocessed_Bool32), uintptr(unsafe.Pointer(pGeneratedCommandsInfo)))

}

// CmdFillBuffer: transfer support is only available when VK_KHR_maintenance1 is enabled, as documented in valid usage language in the specification
// See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdFillBuffer.html
func CmdFillBuffer(commandBuffer CommandBuffer, dstBuffer Buffer, dstOffset DeviceSize, size DeviceSize, data uint32) {

	execTrampoline(keyvkCmdFillBuffer, uintptr(commandBuffer), uintptr(dstBuffer), uintptr(dstOffset), uintptr(size), uintptr(data))

}

// CmdInsertDebugUtilsLabelEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdInsertDebugUtilsLabelEXT.html
func CmdInsertDebugUtilsLabelEXT(commandBuffer CommandBuffer, labelInfo *DebugUtilsLabelEXT) {
	// Parameter is a singular input, requires translation - labelInfo
	var pLabelInfo *_vkDebugUtilsLabelEXT
	if labelInfo != nil {
		pLabelInfo = labelInfo.Vulkanize()
	}

	execTrampoline(keyvkCmdInsertDebugUtilsLabelEXT, uintptr(commandBuffer), uintptr(unsafe.Pointer(pLabelInfo)))

}

// CmdNextSubpass: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdNextSubpass.html
func CmdNextSubpass(commandBuffer CommandBuffer, contents SubpassContents) {

	execTrampoline(keyvkCmdNextSubpass, uintptr(commandBuffer), uintptr(contents))

}

// CmdNextSubpass2: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdNextSubpass2.html
func CmdNextSubpass2(commandBuffer CommandBuffer, subpassBeginInfo *SubpassBeginInfo, subpassEndInfo *SubpassEndInfo) {
	// Parameter is a singular input, requires translation - subpassBeginInfo
	var pSubpassBeginInfo *_vkSubpassBeginInfo
	if subpassBeginInfo != nil {
		pSubpassBeginInfo = subpassBeginInfo.Vulkanize()
	}

	// Parameter is a singular input, requires translation - subpassEndInfo
	var pSubpassEndInfo *_vkSubpassEndInfo
	if subpassEndInfo != nil {
		pSubpassEndInfo = subpassEndInfo.Vulkanize()
	}

	execTrampoline(keyvkCmdNextSubpass2, uintptr(commandBuffer), uintptr(unsafe.Pointer(pSubpassBeginInfo)), uintptr(unsafe.Pointer(pSubpassEndInfo)))

}

var CmdNextSubpass2KHR = CmdNextSubpass2

// CmdOpticalFlowExecuteNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdOpticalFlowExecuteNV.html
func CmdOpticalFlowExecuteNV(commandBuffer CommandBuffer, session OpticalFlowSessionNV, executeInfo *OpticalFlowExecuteInfoNV) {
	// Parameter is a singular input, requires translation - executeInfo
	var pExecuteInfo *_vkOpticalFlowExecuteInfoNV
	if executeInfo != nil {
		pExecuteInfo = executeInfo.Vulkanize()
	}

	execTrampoline(keyvkCmdOpticalFlowExecuteNV, uintptr(commandBuffer), uintptr(session), uintptr(unsafe.Pointer(pExecuteInfo)))

}

// CmdPipelineBarrier: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdPipelineBarrier.html
func CmdPipelineBarrier(commandBuffer CommandBuffer, srcStageMask PipelineStageFlags, dstStageMask PipelineStageFlags, dependencyFlags DependencyFlags, memoryBarriers []MemoryBarrier, bufferMemoryBarriers []BufferMemoryBarrier, imageMemoryBarriers []ImageMemoryBarrier) {
	memoryBarrierCount := len(memoryBarriers)
	// memoryBarriers is an input slice that requires translation to an internal type
	var pMemoryBarriers unsafe.Pointer
	if len(memoryBarriers) > 0 {
		sl_memoryBarriers := make([]_vkMemoryBarrier, memoryBarrierCount)
		for i, v := range memoryBarriers {
			sl_memoryBarriers[i] = *(v.Vulkanize())
		}
		pMemoryBarriers = unsafe.Pointer(&sl_memoryBarriers[0])
	}

	bufferMemoryBarrierCount := len(bufferMemoryBarriers)
	// bufferMemoryBarriers is an input slice that requires translation to an internal type
	var pBufferMemoryBarriers unsafe.Pointer
	if len(bufferMemoryBarriers) > 0 {
		sl_bufferMemoryBarriers := make([]_vkBufferMemoryBarrier, bufferMemoryBarrierCount)
		for i, v := range bufferMemoryBarriers {
			sl_bufferMemoryBarriers[i] = *(v.Vulkanize())
		}
		pBufferMemoryBarriers = unsafe.Pointer(&sl_bufferMemoryBarriers[0])
	}

	imageMemoryBarrierCount := len(imageMemoryBarriers)
	// imageMemoryBarriers is an input slice that requires translation to an internal type
	var pImageMemoryBarriers unsafe.Pointer
	if len(imageMemoryBarriers) > 0 {
		sl_imageMemoryBarriers := make([]_vkImageMemoryBarrier, imageMemoryBarrierCount)
		for i, v := range imageMemoryBarriers {
			sl_imageMemoryBarriers[i] = *(v.Vulkanize())
		}
		pImageMemoryBarriers = unsafe.Pointer(&sl_imageMemoryBarriers[0])
	}

	execTrampoline(keyvkCmdPipelineBarrier, uintptr(commandBuffer), uintptr(srcStageMask), uintptr(dstStageMask), uintptr(dependencyFlags), uintptr(memoryBarrierCount), uintptr(unsafe.Pointer(pMemoryBarriers)), uintptr(bufferMemoryBarrierCount), uintptr(unsafe.Pointer(pBufferMemoryBarriers)), uintptr(imageMemoryBarrierCount), uintptr(unsafe.Pointer(pImageMemoryBarriers)))

}

// CmdPipelineBarrier2: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdPipelineBarrier2.html
func CmdPipelineBarrier2(commandBuffer CommandBuffer, dependencyInfo *DependencyInfo) {
	// Parameter is a singular input, requires translation - dependencyInfo
	var pDependencyInfo *_vkDependencyInfo
	if dependencyInfo != nil {
		pDependencyInfo = dependencyInfo.Vulkanize()
	}

	execTrampoline(keyvkCmdPipelineBarrier2, uintptr(commandBuffer), uintptr(unsafe.Pointer(pDependencyInfo)))

}

var CmdPipelineBarrier2KHR = CmdPipelineBarrier2

// CmdPreprocessGeneratedCommandsNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdPreprocessGeneratedCommandsNV.html
func CmdPreprocessGeneratedCommandsNV(commandBuffer CommandBuffer, generatedCommandsInfo *GeneratedCommandsInfoNV) {
	// Parameter is a singular input, requires translation - generatedCommandsInfo
	var pGeneratedCommandsInfo *_vkGeneratedCommandsInfoNV
	if generatedCommandsInfo != nil {
		pGeneratedCommandsInfo = generatedCommandsInfo.Vulkanize()
	}

	execTrampoline(keyvkCmdPreprocessGeneratedCommandsNV, uintptr(commandBuffer), uintptr(unsafe.Pointer(pGeneratedCommandsInfo)))

}

// CmdPushConstants: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdPushConstants.html
func CmdPushConstants(commandBuffer CommandBuffer, layout PipelineLayout, stageFlags ShaderStageFlags, offset uint32, values []byte) {
	size := len(values)
	// values is an input slice of values that do not need translation used
	var pValues unsafe.Pointer
	if values != nil {
		pValues = unsafe.Pointer(&values[0])
	}

	execTrampoline(keyvkCmdPushConstants, uintptr(commandBuffer), uintptr(layout), uintptr(stageFlags), uintptr(offset), uintptr(size), uintptr(unsafe.Pointer(pValues)))

}

// CmdPushDescriptorSetKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdPushDescriptorSetKHR.html
func CmdPushDescriptorSetKHR(commandBuffer CommandBuffer, pipelineBindPoint PipelineBindPoint, layout PipelineLayout, set uint32, descriptorWrites []WriteDescriptorSet) {
	descriptorWriteCount := len(descriptorWrites)
	// descriptorWrites is an input slice that requires translation to an internal type
	var pDescriptorWrites unsafe.Pointer
	if len(descriptorWrites) > 0 {
		sl_descriptorWrites := make([]_vkWriteDescriptorSet, descriptorWriteCount)
		for i, v := range descriptorWrites {
			sl_descriptorWrites[i] = *(v.Vulkanize())
		}
		pDescriptorWrites = unsafe.Pointer(&sl_descriptorWrites[0])
	}

	execTrampoline(keyvkCmdPushDescriptorSetKHR, uintptr(commandBuffer), uintptr(pipelineBindPoint), uintptr(layout), uintptr(set), uintptr(descriptorWriteCount), uintptr(unsafe.Pointer(pDescriptorWrites)))

}

// CmdPushDescriptorSetWithTemplateKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdPushDescriptorSetWithTemplateKHR.html
func CmdPushDescriptorSetWithTemplateKHR(commandBuffer CommandBuffer, descriptorUpdateTemplate DescriptorUpdateTemplate, layout PipelineLayout, set uint32, data *byte) {
	// Parameter is a singular input, pass direct - data
	var pData unsafe.Pointer
	if data != nil {
		pData = unsafe.Pointer(data)
	}

	execTrampoline(keyvkCmdPushDescriptorSetWithTemplateKHR, uintptr(commandBuffer), uintptr(descriptorUpdateTemplate), uintptr(layout), uintptr(set), uintptr(unsafe.Pointer(pData)))

}

// CmdResetEvent: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdResetEvent.html
func CmdResetEvent(commandBuffer CommandBuffer, event Event, stageMask PipelineStageFlags) {

	execTrampoline(keyvkCmdResetEvent, uintptr(commandBuffer), uintptr(event), uintptr(stageMask))

}

// CmdResetEvent2: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdResetEvent2.html
func CmdResetEvent2(commandBuffer CommandBuffer, event Event, stageMask PipelineStageFlags2) {

	execTrampoline(keyvkCmdResetEvent2, uintptr(commandBuffer), uintptr(event), uintptr(stageMask))

}

var CmdResetEvent2KHR = CmdResetEvent2

// CmdResetQueryPool: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdResetQueryPool.html
func CmdResetQueryPool(commandBuffer CommandBuffer, queryPool QueryPool, firstQuery uint32, queryCount uint32) {

	execTrampoline(keyvkCmdResetQueryPool, uintptr(commandBuffer), uintptr(queryPool), uintptr(firstQuery), uintptr(queryCount))

}

// CmdResolveImage: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdResolveImage.html
func CmdResolveImage(commandBuffer CommandBuffer, srcImage Image, srcImageLayout ImageLayout, dstImage Image, dstImageLayout ImageLayout, regions []ImageResolve) {
	regionCount := len(regions)
	// regions is an input slice that requires translation to an internal type
	var pRegions unsafe.Pointer
	if len(regions) > 0 {
		sl_regions := make([]_vkImageResolve, regionCount)
		for i, v := range regions {
			sl_regions[i] = *(v.Vulkanize())
		}
		pRegions = unsafe.Pointer(&sl_regions[0])
	}

	execTrampoline(keyvkCmdResolveImage, uintptr(commandBuffer), uintptr(srcImage), uintptr(srcImageLayout), uintptr(dstImage), uintptr(dstImageLayout), uintptr(regionCount), uintptr(unsafe.Pointer(pRegions)))

}

// CmdResolveImage2: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdResolveImage2.html
func CmdResolveImage2(commandBuffer CommandBuffer, resolveImageInfo *ResolveImageInfo2) {
	// Parameter is a singular input, requires translation - resolveImageInfo
	var pResolveImageInfo *_vkResolveImageInfo2
	if resolveImageInfo != nil {
		pResolveImageInfo = resolveImageInfo.Vulkanize()
	}

	execTrampoline(keyvkCmdResolveImage2, uintptr(commandBuffer), uintptr(unsafe.Pointer(pResolveImageInfo)))

}

var CmdResolveImage2KHR = CmdResolveImage2

// CmdSetAlphaToCoverageEnableEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetAlphaToCoverageEnableEXT.html
func CmdSetAlphaToCoverageEnableEXT(commandBuffer CommandBuffer, alphaToCoverageEnable bool) {
	alphaToCoverageEnable_Bool32 := translateInternal_Bool32(alphaToCoverageEnable)

	execTrampoline(keyvkCmdSetAlphaToCoverageEnableEXT, uintptr(commandBuffer), uintptr(alphaToCoverageEnable_Bool32))

}

// CmdSetAlphaToOneEnableEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetAlphaToOneEnableEXT.html
func CmdSetAlphaToOneEnableEXT(commandBuffer CommandBuffer, alphaToOneEnable bool) {
	alphaToOneEnable_Bool32 := translateInternal_Bool32(alphaToOneEnable)

	execTrampoline(keyvkCmdSetAlphaToOneEnableEXT, uintptr(commandBuffer), uintptr(alphaToOneEnable_Bool32))

}

// CmdSetBlendConstants: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetBlendConstants.html
func CmdSetBlendConstants(commandBuffer CommandBuffer, blendConstants float32) {

	execTrampoline(keyvkCmdSetBlendConstants, uintptr(commandBuffer), uintptr(blendConstants))

}

// CmdSetCheckpointNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetCheckpointNV.html
func CmdSetCheckpointNV(commandBuffer CommandBuffer, checkpointMarker *byte) {
	// Parameter is a singular input, pass direct - checkpointMarker
	var pCheckpointMarker unsafe.Pointer
	if checkpointMarker != nil {
		pCheckpointMarker = unsafe.Pointer(checkpointMarker)
	}

	execTrampoline(keyvkCmdSetCheckpointNV, uintptr(commandBuffer), uintptr(unsafe.Pointer(pCheckpointMarker)))

}

// CmdSetCoarseSampleOrderNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetCoarseSampleOrderNV.html
func CmdSetCoarseSampleOrderNV(commandBuffer CommandBuffer, sampleOrderType CoarseSampleOrderTypeNV, customSampleOrders []CoarseSampleOrderCustomNV) {
	customSampleOrderCount := len(customSampleOrders)
	// customSampleOrders is an input slice that requires translation to an internal type
	var pCustomSampleOrders unsafe.Pointer
	if len(customSampleOrders) > 0 {
		sl_customSampleOrders := make([]_vkCoarseSampleOrderCustomNV, customSampleOrderCount)
		for i, v := range customSampleOrders {
			sl_customSampleOrders[i] = *(v.Vulkanize())
		}
		pCustomSampleOrders = unsafe.Pointer(&sl_customSampleOrders[0])
	}

	execTrampoline(keyvkCmdSetCoarseSampleOrderNV, uintptr(commandBuffer), uintptr(sampleOrderType), uintptr(customSampleOrderCount), uintptr(unsafe.Pointer(pCustomSampleOrders)))

}

// CmdSetColorBlendAdvancedEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetColorBlendAdvancedEXT.html
func CmdSetColorBlendAdvancedEXT(commandBuffer CommandBuffer, firstAttachment uint32, colorBlendAdvanced []ColorBlendAdvancedEXT) {
	attachmentCount := len(colorBlendAdvanced)
	// colorBlendAdvanced is an input slice that requires translation to an internal type
	var pColorBlendAdvanced unsafe.Pointer
	if len(colorBlendAdvanced) > 0 {
		sl_colorBlendAdvanced := make([]_vkColorBlendAdvancedEXT, attachmentCount)
		for i, v := range colorBlendAdvanced {
			sl_colorBlendAdvanced[i] = *(v.Vulkanize())
		}
		pColorBlendAdvanced = unsafe.Pointer(&sl_colorBlendAdvanced[0])
	}

	execTrampoline(keyvkCmdSetColorBlendAdvancedEXT, uintptr(commandBuffer), uintptr(firstAttachment), uintptr(attachmentCount), uintptr(unsafe.Pointer(pColorBlendAdvanced)))

}

// CmdSetColorBlendEnableEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetColorBlendEnableEXT.html
func CmdSetColorBlendEnableEXT(commandBuffer CommandBuffer, firstAttachment uint32, colorBlendEnables []bool) {
	attachmentCount := len(colorBlendEnables)
	// colorBlendEnables is an input slice that requires translation to an internal type
	var pColorBlendEnables unsafe.Pointer
	if len(colorBlendEnables) > 0 {
		sl_colorBlendEnables := make([]Bool32, attachmentCount)
		for i, v := range colorBlendEnables {
			sl_colorBlendEnables[i] = translateInternal_Bool32(v)
		}
		pColorBlendEnables = unsafe.Pointer(&sl_colorBlendEnables[0])
	}

	execTrampoline(keyvkCmdSetColorBlendEnableEXT, uintptr(commandBuffer), uintptr(firstAttachment), uintptr(attachmentCount), uintptr(unsafe.Pointer(pColorBlendEnables)))

}

// CmdSetColorBlendEquationEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetColorBlendEquationEXT.html
func CmdSetColorBlendEquationEXT(commandBuffer CommandBuffer, firstAttachment uint32, colorBlendEquations []ColorBlendEquationEXT) {
	attachmentCount := len(colorBlendEquations)
	// colorBlendEquations is an input slice of values that do not need translation used
	var pColorBlendEquations unsafe.Pointer
	if colorBlendEquations != nil {
		pColorBlendEquations = unsafe.Pointer(&colorBlendEquations[0])
	}

	execTrampoline(keyvkCmdSetColorBlendEquationEXT, uintptr(commandBuffer), uintptr(firstAttachment), uintptr(attachmentCount), uintptr(unsafe.Pointer(pColorBlendEquations)))

}

// CmdSetColorWriteEnableEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetColorWriteEnableEXT.html
func CmdSetColorWriteEnableEXT(commandBuffer CommandBuffer, colorWriteEnables []bool) {
	attachmentCount := len(colorWriteEnables)
	// colorWriteEnables is an input slice that requires translation to an internal type
	var pColorWriteEnables unsafe.Pointer
	if len(colorWriteEnables) > 0 {
		sl_colorWriteEnables := make([]Bool32, attachmentCount)
		for i, v := range colorWriteEnables {
			sl_colorWriteEnables[i] = translateInternal_Bool32(v)
		}
		pColorWriteEnables = unsafe.Pointer(&sl_colorWriteEnables[0])
	}

	execTrampoline(keyvkCmdSetColorWriteEnableEXT, uintptr(commandBuffer), uintptr(attachmentCount), uintptr(unsafe.Pointer(pColorWriteEnables)))

}

// CmdSetColorWriteMaskEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetColorWriteMaskEXT.html
func CmdSetColorWriteMaskEXT(commandBuffer CommandBuffer, firstAttachment uint32, colorWriteMasks []ColorComponentFlags) {
	attachmentCount := len(colorWriteMasks)
	// colorWriteMasks is an input slice of values that do not need translation used
	var pColorWriteMasks unsafe.Pointer
	if colorWriteMasks != nil {
		pColorWriteMasks = unsafe.Pointer(&colorWriteMasks[0])
	}

	execTrampoline(keyvkCmdSetColorWriteMaskEXT, uintptr(commandBuffer), uintptr(firstAttachment), uintptr(attachmentCount), uintptr(unsafe.Pointer(pColorWriteMasks)))

}

// CmdSetConservativeRasterizationModeEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetConservativeRasterizationModeEXT.html
func CmdSetConservativeRasterizationModeEXT(commandBuffer CommandBuffer, conservativeRasterizationMode ConservativeRasterizationModeEXT) {

	execTrampoline(keyvkCmdSetConservativeRasterizationModeEXT, uintptr(commandBuffer), uintptr(conservativeRasterizationMode))

}

// CmdSetCoverageModulationModeNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetCoverageModulationModeNV.html
func CmdSetCoverageModulationModeNV(commandBuffer CommandBuffer, coverageModulationMode CoverageModulationModeNV) {

	execTrampoline(keyvkCmdSetCoverageModulationModeNV, uintptr(commandBuffer), uintptr(coverageModulationMode))

}

// CmdSetCoverageModulationTableEnableNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetCoverageModulationTableEnableNV.html
func CmdSetCoverageModulationTableEnableNV(commandBuffer CommandBuffer, coverageModulationTableEnable bool) {
	coverageModulationTableEnable_Bool32 := translateInternal_Bool32(coverageModulationTableEnable)

	execTrampoline(keyvkCmdSetCoverageModulationTableEnableNV, uintptr(commandBuffer), uintptr(coverageModulationTableEnable_Bool32))

}

// CmdSetCoverageModulationTableNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetCoverageModulationTableNV.html
func CmdSetCoverageModulationTableNV(commandBuffer CommandBuffer, coverageModulationTable []float32) {
	coverageModulationTableCount := len(coverageModulationTable)
	// coverageModulationTable is an input slice of values that do not need translation used
	var pCoverageModulationTable unsafe.Pointer
	if coverageModulationTable != nil {
		pCoverageModulationTable = unsafe.Pointer(&coverageModulationTable[0])
	}

	execTrampoline(keyvkCmdSetCoverageModulationTableNV, uintptr(commandBuffer), uintptr(coverageModulationTableCount), uintptr(unsafe.Pointer(pCoverageModulationTable)))

}

// CmdSetCoverageReductionModeNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetCoverageReductionModeNV.html
func CmdSetCoverageReductionModeNV(commandBuffer CommandBuffer, coverageReductionMode CoverageReductionModeNV) {

	execTrampoline(keyvkCmdSetCoverageReductionModeNV, uintptr(commandBuffer), uintptr(coverageReductionMode))

}

// CmdSetCoverageToColorEnableNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetCoverageToColorEnableNV.html
func CmdSetCoverageToColorEnableNV(commandBuffer CommandBuffer, coverageToColorEnable bool) {
	coverageToColorEnable_Bool32 := translateInternal_Bool32(coverageToColorEnable)

	execTrampoline(keyvkCmdSetCoverageToColorEnableNV, uintptr(commandBuffer), uintptr(coverageToColorEnable_Bool32))

}

// CmdSetCoverageToColorLocationNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetCoverageToColorLocationNV.html
func CmdSetCoverageToColorLocationNV(commandBuffer CommandBuffer, coverageToColorLocation uint32) {

	execTrampoline(keyvkCmdSetCoverageToColorLocationNV, uintptr(commandBuffer), uintptr(coverageToColorLocation))

}

// CmdSetCullMode: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetCullMode.html
func CmdSetCullMode(commandBuffer CommandBuffer, cullMode CullModeFlags) {

	execTrampoline(keyvkCmdSetCullMode, uintptr(commandBuffer), uintptr(cullMode))

}

var CmdSetCullModeEXT = CmdSetCullMode

// CmdSetDepthBias: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetDepthBias.html
func CmdSetDepthBias(commandBuffer CommandBuffer, depthBiasConstantFactor float32, depthBiasClamp float32, depthBiasSlopeFactor float32) {

	execTrampoline(keyvkCmdSetDepthBias, uintptr(commandBuffer), uintptr(depthBiasConstantFactor), uintptr(depthBiasClamp), uintptr(depthBiasSlopeFactor))

}

// CmdSetDepthBiasEnable: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetDepthBiasEnable.html
func CmdSetDepthBiasEnable(commandBuffer CommandBuffer, depthBiasEnable bool) {
	depthBiasEnable_Bool32 := translateInternal_Bool32(depthBiasEnable)

	execTrampoline(keyvkCmdSetDepthBiasEnable, uintptr(commandBuffer), uintptr(depthBiasEnable_Bool32))

}

var CmdSetDepthBiasEnableEXT = CmdSetDepthBiasEnable

// CmdSetDepthBounds: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetDepthBounds.html
func CmdSetDepthBounds(commandBuffer CommandBuffer, minDepthBounds float32, maxDepthBounds float32) {

	execTrampoline(keyvkCmdSetDepthBounds, uintptr(commandBuffer), uintptr(minDepthBounds), uintptr(maxDepthBounds))

}

// CmdSetDepthBoundsTestEnable: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetDepthBoundsTestEnable.html
func CmdSetDepthBoundsTestEnable(commandBuffer CommandBuffer, depthBoundsTestEnable bool) {
	depthBoundsTestEnable_Bool32 := translateInternal_Bool32(depthBoundsTestEnable)

	execTrampoline(keyvkCmdSetDepthBoundsTestEnable, uintptr(commandBuffer), uintptr(depthBoundsTestEnable_Bool32))

}

var CmdSetDepthBoundsTestEnableEXT = CmdSetDepthBoundsTestEnable

// CmdSetDepthClampEnableEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetDepthClampEnableEXT.html
func CmdSetDepthClampEnableEXT(commandBuffer CommandBuffer, depthClampEnable bool) {
	depthClampEnable_Bool32 := translateInternal_Bool32(depthClampEnable)

	execTrampoline(keyvkCmdSetDepthClampEnableEXT, uintptr(commandBuffer), uintptr(depthClampEnable_Bool32))

}

// CmdSetDepthClipEnableEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetDepthClipEnableEXT.html
func CmdSetDepthClipEnableEXT(commandBuffer CommandBuffer, depthClipEnable bool) {
	depthClipEnable_Bool32 := translateInternal_Bool32(depthClipEnable)

	execTrampoline(keyvkCmdSetDepthClipEnableEXT, uintptr(commandBuffer), uintptr(depthClipEnable_Bool32))

}

// CmdSetDepthClipNegativeOneToOneEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetDepthClipNegativeOneToOneEXT.html
func CmdSetDepthClipNegativeOneToOneEXT(commandBuffer CommandBuffer, negativeOneToOne bool) {
	negativeOneToOne_Bool32 := translateInternal_Bool32(negativeOneToOne)

	execTrampoline(keyvkCmdSetDepthClipNegativeOneToOneEXT, uintptr(commandBuffer), uintptr(negativeOneToOne_Bool32))

}

// CmdSetDepthCompareOp: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetDepthCompareOp.html
func CmdSetDepthCompareOp(commandBuffer CommandBuffer, depthCompareOp CompareOp) {

	execTrampoline(keyvkCmdSetDepthCompareOp, uintptr(commandBuffer), uintptr(depthCompareOp))

}

var CmdSetDepthCompareOpEXT = CmdSetDepthCompareOp

// CmdSetDepthTestEnable: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetDepthTestEnable.html
func CmdSetDepthTestEnable(commandBuffer CommandBuffer, depthTestEnable bool) {
	depthTestEnable_Bool32 := translateInternal_Bool32(depthTestEnable)

	execTrampoline(keyvkCmdSetDepthTestEnable, uintptr(commandBuffer), uintptr(depthTestEnable_Bool32))

}

var CmdSetDepthTestEnableEXT = CmdSetDepthTestEnable

// CmdSetDepthWriteEnable: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetDepthWriteEnable.html
func CmdSetDepthWriteEnable(commandBuffer CommandBuffer, depthWriteEnable bool) {
	depthWriteEnable_Bool32 := translateInternal_Bool32(depthWriteEnable)

	execTrampoline(keyvkCmdSetDepthWriteEnable, uintptr(commandBuffer), uintptr(depthWriteEnable_Bool32))

}

var CmdSetDepthWriteEnableEXT = CmdSetDepthWriteEnable

// CmdSetDescriptorBufferOffsetsEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetDescriptorBufferOffsetsEXT.html
func CmdSetDescriptorBufferOffsetsEXT(commandBuffer CommandBuffer, pipelineBindPoint PipelineBindPoint, layout PipelineLayout, firstSet uint32, bufferIndices []uint32, offsets []DeviceSize) {
	setCount := len(bufferIndices)
	// bufferIndices is an input slice of values that do not need translation used
	var pBufferIndices unsafe.Pointer
	if bufferIndices != nil {
		pBufferIndices = unsafe.Pointer(&bufferIndices[0])
	}

	// offsets is an input slice of values that do not need translation used
	var pOffsets unsafe.Pointer
	if offsets != nil {
		pOffsets = unsafe.Pointer(&offsets[0])
	}

	execTrampoline(keyvkCmdSetDescriptorBufferOffsetsEXT, uintptr(commandBuffer), uintptr(pipelineBindPoint), uintptr(layout), uintptr(firstSet), uintptr(setCount), uintptr(unsafe.Pointer(pBufferIndices)), uintptr(unsafe.Pointer(pOffsets)))

}

// CmdSetDeviceMask: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetDeviceMask.html
func CmdSetDeviceMask(commandBuffer CommandBuffer, deviceMask uint32) {

	execTrampoline(keyvkCmdSetDeviceMask, uintptr(commandBuffer), uintptr(deviceMask))

}

var CmdSetDeviceMaskKHR = CmdSetDeviceMask

// CmdSetDiscardRectangleEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetDiscardRectangleEXT.html
func CmdSetDiscardRectangleEXT(commandBuffer CommandBuffer, firstDiscardRectangle uint32, discardRectangles []Rect2D) {
	discardRectangleCount := len(discardRectangles)
	// discardRectangles is an input slice that requires translation to an internal type
	var pDiscardRectangles unsafe.Pointer
	if len(discardRectangles) > 0 {
		sl_discardRectangles := make([]_vkRect2D, discardRectangleCount)
		for i, v := range discardRectangles {
			sl_discardRectangles[i] = *(v.Vulkanize())
		}
		pDiscardRectangles = unsafe.Pointer(&sl_discardRectangles[0])
	}

	execTrampoline(keyvkCmdSetDiscardRectangleEXT, uintptr(commandBuffer), uintptr(firstDiscardRectangle), uintptr(discardRectangleCount), uintptr(unsafe.Pointer(pDiscardRectangles)))

}

// CmdSetEvent: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetEvent.html
func CmdSetEvent(commandBuffer CommandBuffer, event Event, stageMask PipelineStageFlags) {

	execTrampoline(keyvkCmdSetEvent, uintptr(commandBuffer), uintptr(event), uintptr(stageMask))

}

// CmdSetEvent2: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetEvent2.html
func CmdSetEvent2(commandBuffer CommandBuffer, event Event, dependencyInfo *DependencyInfo) {
	// Parameter is a singular input, requires translation - dependencyInfo
	var pDependencyInfo *_vkDependencyInfo
	if dependencyInfo != nil {
		pDependencyInfo = dependencyInfo.Vulkanize()
	}

	execTrampoline(keyvkCmdSetEvent2, uintptr(commandBuffer), uintptr(event), uintptr(unsafe.Pointer(pDependencyInfo)))

}

var CmdSetEvent2KHR = CmdSetEvent2

// CmdSetExclusiveScissorNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetExclusiveScissorNV.html
func CmdSetExclusiveScissorNV(commandBuffer CommandBuffer, firstExclusiveScissor uint32, exclusiveScissors []Rect2D) {
	exclusiveScissorCount := len(exclusiveScissors)
	// exclusiveScissors is an input slice that requires translation to an internal type
	var pExclusiveScissors unsafe.Pointer
	if len(exclusiveScissors) > 0 {
		sl_exclusiveScissors := make([]_vkRect2D, exclusiveScissorCount)
		for i, v := range exclusiveScissors {
			sl_exclusiveScissors[i] = *(v.Vulkanize())
		}
		pExclusiveScissors = unsafe.Pointer(&sl_exclusiveScissors[0])
	}

	execTrampoline(keyvkCmdSetExclusiveScissorNV, uintptr(commandBuffer), uintptr(firstExclusiveScissor), uintptr(exclusiveScissorCount), uintptr(unsafe.Pointer(pExclusiveScissors)))

}

// CmdSetExtraPrimitiveOverestimationSizeEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetExtraPrimitiveOverestimationSizeEXT.html
func CmdSetExtraPrimitiveOverestimationSizeEXT(commandBuffer CommandBuffer, extraPrimitiveOverestimationSize float32) {

	execTrampoline(keyvkCmdSetExtraPrimitiveOverestimationSizeEXT, uintptr(commandBuffer), uintptr(extraPrimitiveOverestimationSize))

}

// CmdSetFragmentShadingRateEnumNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetFragmentShadingRateEnumNV.html
func CmdSetFragmentShadingRateEnumNV(commandBuffer CommandBuffer, shadingRate FragmentShadingRateNV, combinerOps FragmentShadingRateCombinerOpKHR) {

	execTrampoline(keyvkCmdSetFragmentShadingRateEnumNV, uintptr(commandBuffer), uintptr(shadingRate), uintptr(combinerOps))

}

// CmdSetFragmentShadingRateKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetFragmentShadingRateKHR.html
func CmdSetFragmentShadingRateKHR(commandBuffer CommandBuffer, fragmentSize *Extent2D, combinerOps FragmentShadingRateCombinerOpKHR) {
	// Parameter is a singular input, pass direct - fragmentSize
	var pFragmentSize unsafe.Pointer
	if fragmentSize != nil {
		pFragmentSize = unsafe.Pointer(fragmentSize)
	}

	execTrampoline(keyvkCmdSetFragmentShadingRateKHR, uintptr(commandBuffer), uintptr(unsafe.Pointer(pFragmentSize)), uintptr(combinerOps))

}

// CmdSetFrontFace: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetFrontFace.html
func CmdSetFrontFace(commandBuffer CommandBuffer, frontFace FrontFace) {

	execTrampoline(keyvkCmdSetFrontFace, uintptr(commandBuffer), uintptr(frontFace))

}

var CmdSetFrontFaceEXT = CmdSetFrontFace

// CmdSetLineRasterizationModeEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetLineRasterizationModeEXT.html
func CmdSetLineRasterizationModeEXT(commandBuffer CommandBuffer, lineRasterizationMode LineRasterizationModeEXT) {

	execTrampoline(keyvkCmdSetLineRasterizationModeEXT, uintptr(commandBuffer), uintptr(lineRasterizationMode))

}

// CmdSetLineStippleEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetLineStippleEXT.html
func CmdSetLineStippleEXT(commandBuffer CommandBuffer, lineStippleFactor uint32, lineStipplePattern uint16) {

	execTrampoline(keyvkCmdSetLineStippleEXT, uintptr(commandBuffer), uintptr(lineStippleFactor), uintptr(lineStipplePattern))

}

// CmdSetLineStippleEnableEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetLineStippleEnableEXT.html
func CmdSetLineStippleEnableEXT(commandBuffer CommandBuffer, stippledLineEnable bool) {
	stippledLineEnable_Bool32 := translateInternal_Bool32(stippledLineEnable)

	execTrampoline(keyvkCmdSetLineStippleEnableEXT, uintptr(commandBuffer), uintptr(stippledLineEnable_Bool32))

}

// CmdSetLineWidth: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetLineWidth.html
func CmdSetLineWidth(commandBuffer CommandBuffer, lineWidth float32) {

	execTrampoline(keyvkCmdSetLineWidth, uintptr(commandBuffer), uintptr(lineWidth))

}

// CmdSetLogicOpEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetLogicOpEXT.html
func CmdSetLogicOpEXT(commandBuffer CommandBuffer, logicOp LogicOp) {

	execTrampoline(keyvkCmdSetLogicOpEXT, uintptr(commandBuffer), uintptr(logicOp))

}

// CmdSetLogicOpEnableEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetLogicOpEnableEXT.html
func CmdSetLogicOpEnableEXT(commandBuffer CommandBuffer, logicOpEnable bool) {
	logicOpEnable_Bool32 := translateInternal_Bool32(logicOpEnable)

	execTrampoline(keyvkCmdSetLogicOpEnableEXT, uintptr(commandBuffer), uintptr(logicOpEnable_Bool32))

}

// CmdSetPatchControlPointsEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetPatchControlPointsEXT.html
func CmdSetPatchControlPointsEXT(commandBuffer CommandBuffer, patchControlPoints uint32) {

	execTrampoline(keyvkCmdSetPatchControlPointsEXT, uintptr(commandBuffer), uintptr(patchControlPoints))

}

// CmdSetPerformanceMarkerINTEL: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetPerformanceMarkerINTEL.html
func CmdSetPerformanceMarkerINTEL(commandBuffer CommandBuffer, markerInfo *PerformanceMarkerInfoINTEL) (r Result) {
	// Parameter is a singular input, requires translation - markerInfo
	var pMarkerInfo *_vkPerformanceMarkerInfoINTEL
	if markerInfo != nil {
		pMarkerInfo = markerInfo.Vulkanize()
	}

	r = Result(execTrampoline(keyvkCmdSetPerformanceMarkerINTEL, uintptr(commandBuffer), uintptr(unsafe.Pointer(pMarkerInfo))))

	return
}

// CmdSetPerformanceOverrideINTEL: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetPerformanceOverrideINTEL.html
func CmdSetPerformanceOverrideINTEL(commandBuffer CommandBuffer, overrideInfo *PerformanceOverrideInfoINTEL) (r Result) {
	// Parameter is a singular input, requires translation - overrideInfo
	var pOverrideInfo *_vkPerformanceOverrideInfoINTEL
	if overrideInfo != nil {
		pOverrideInfo = overrideInfo.Vulkanize()
	}

	r = Result(execTrampoline(keyvkCmdSetPerformanceOverrideINTEL, uintptr(commandBuffer), uintptr(unsafe.Pointer(pOverrideInfo))))

	return
}

// CmdSetPerformanceStreamMarkerINTEL: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetPerformanceStreamMarkerINTEL.html
func CmdSetPerformanceStreamMarkerINTEL(commandBuffer CommandBuffer, markerInfo *PerformanceStreamMarkerInfoINTEL) (r Result) {
	// Parameter is a singular input, requires translation - markerInfo
	var pMarkerInfo *_vkPerformanceStreamMarkerInfoINTEL
	if markerInfo != nil {
		pMarkerInfo = markerInfo.Vulkanize()
	}

	r = Result(execTrampoline(keyvkCmdSetPerformanceStreamMarkerINTEL, uintptr(commandBuffer), uintptr(unsafe.Pointer(pMarkerInfo))))

	return
}

// CmdSetPolygonModeEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetPolygonModeEXT.html
func CmdSetPolygonModeEXT(commandBuffer CommandBuffer, polygonMode PolygonMode) {

	execTrampoline(keyvkCmdSetPolygonModeEXT, uintptr(commandBuffer), uintptr(polygonMode))

}

// CmdSetPrimitiveRestartEnable: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetPrimitiveRestartEnable.html
func CmdSetPrimitiveRestartEnable(commandBuffer CommandBuffer, primitiveRestartEnable bool) {
	primitiveRestartEnable_Bool32 := translateInternal_Bool32(primitiveRestartEnable)

	execTrampoline(keyvkCmdSetPrimitiveRestartEnable, uintptr(commandBuffer), uintptr(primitiveRestartEnable_Bool32))

}

var CmdSetPrimitiveRestartEnableEXT = CmdSetPrimitiveRestartEnable

// CmdSetPrimitiveTopology: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetPrimitiveTopology.html
func CmdSetPrimitiveTopology(commandBuffer CommandBuffer, primitiveTopology PrimitiveTopology) {

	execTrampoline(keyvkCmdSetPrimitiveTopology, uintptr(commandBuffer), uintptr(primitiveTopology))

}

var CmdSetPrimitiveTopologyEXT = CmdSetPrimitiveTopology

// CmdSetProvokingVertexModeEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetProvokingVertexModeEXT.html
func CmdSetProvokingVertexModeEXT(commandBuffer CommandBuffer, provokingVertexMode ProvokingVertexModeEXT) {

	execTrampoline(keyvkCmdSetProvokingVertexModeEXT, uintptr(commandBuffer), uintptr(provokingVertexMode))

}

// CmdSetRasterizationSamplesEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetRasterizationSamplesEXT.html
func CmdSetRasterizationSamplesEXT(commandBuffer CommandBuffer, rasterizationSamples SampleCountFlagBits) {

	execTrampoline(keyvkCmdSetRasterizationSamplesEXT, uintptr(commandBuffer), uintptr(rasterizationSamples))

}

// CmdSetRasterizationStreamEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetRasterizationStreamEXT.html
func CmdSetRasterizationStreamEXT(commandBuffer CommandBuffer, rasterizationStream uint32) {

	execTrampoline(keyvkCmdSetRasterizationStreamEXT, uintptr(commandBuffer), uintptr(rasterizationStream))

}

// CmdSetRasterizerDiscardEnable: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetRasterizerDiscardEnable.html
func CmdSetRasterizerDiscardEnable(commandBuffer CommandBuffer, rasterizerDiscardEnable bool) {
	rasterizerDiscardEnable_Bool32 := translateInternal_Bool32(rasterizerDiscardEnable)

	execTrampoline(keyvkCmdSetRasterizerDiscardEnable, uintptr(commandBuffer), uintptr(rasterizerDiscardEnable_Bool32))

}

var CmdSetRasterizerDiscardEnableEXT = CmdSetRasterizerDiscardEnable

// CmdSetRayTracingPipelineStackSizeKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetRayTracingPipelineStackSizeKHR.html
func CmdSetRayTracingPipelineStackSizeKHR(commandBuffer CommandBuffer, pipelineStackSize uint32) {

	execTrampoline(keyvkCmdSetRayTracingPipelineStackSizeKHR, uintptr(commandBuffer), uintptr(pipelineStackSize))

}

// CmdSetRepresentativeFragmentTestEnableNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetRepresentativeFragmentTestEnableNV.html
func CmdSetRepresentativeFragmentTestEnableNV(commandBuffer CommandBuffer, representativeFragmentTestEnable bool) {
	representativeFragmentTestEnable_Bool32 := translateInternal_Bool32(representativeFragmentTestEnable)

	execTrampoline(keyvkCmdSetRepresentativeFragmentTestEnableNV, uintptr(commandBuffer), uintptr(representativeFragmentTestEnable_Bool32))

}

// CmdSetSampleLocationsEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetSampleLocationsEXT.html
func CmdSetSampleLocationsEXT(commandBuffer CommandBuffer, sampleLocationsInfo *SampleLocationsInfoEXT) {
	// Parameter is a singular input, requires translation - sampleLocationsInfo
	var pSampleLocationsInfo *_vkSampleLocationsInfoEXT
	if sampleLocationsInfo != nil {
		pSampleLocationsInfo = sampleLocationsInfo.Vulkanize()
	}

	execTrampoline(keyvkCmdSetSampleLocationsEXT, uintptr(commandBuffer), uintptr(unsafe.Pointer(pSampleLocationsInfo)))

}

// CmdSetSampleLocationsEnableEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetSampleLocationsEnableEXT.html
func CmdSetSampleLocationsEnableEXT(commandBuffer CommandBuffer, sampleLocationsEnable bool) {
	sampleLocationsEnable_Bool32 := translateInternal_Bool32(sampleLocationsEnable)

	execTrampoline(keyvkCmdSetSampleLocationsEnableEXT, uintptr(commandBuffer), uintptr(sampleLocationsEnable_Bool32))

}

// CmdSetSampleMaskEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetSampleMaskEXT.html
func CmdSetSampleMaskEXT(commandBuffer CommandBuffer, samples SampleCountFlagBits, sampleMask []SampleMask) {
	// sampleMask is an edge case input slice, with an alternative length encoding. Developer must provide the length themselves.
	// No handling for internal vs. external types at this time, the only case this appears as of 1.3.240 is a handle type with a bitfield length encoding
	var pSampleMask *SampleMask
	if sampleMask != nil {
		pSampleMask = &sampleMask[0]
	}

	execTrampoline(keyvkCmdSetSampleMaskEXT, uintptr(commandBuffer), uintptr(samples), uintptr(unsafe.Pointer(pSampleMask)))

}

// CmdSetScissor: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetScissor.html
func CmdSetScissor(commandBuffer CommandBuffer, firstScissor uint32, scissors []Rect2D) {
	scissorCount := len(scissors)
	// scissors is an input slice that requires translation to an internal type
	var pScissors unsafe.Pointer
	if len(scissors) > 0 {
		sl_scissors := make([]_vkRect2D, scissorCount)
		for i, v := range scissors {
			sl_scissors[i] = *(v.Vulkanize())
		}
		pScissors = unsafe.Pointer(&sl_scissors[0])
	}

	execTrampoline(keyvkCmdSetScissor, uintptr(commandBuffer), uintptr(firstScissor), uintptr(scissorCount), uintptr(unsafe.Pointer(pScissors)))

}

// CmdSetScissorWithCount: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetScissorWithCount.html
func CmdSetScissorWithCount(commandBuffer CommandBuffer, scissors []Rect2D) {
	scissorCount := len(scissors)
	// scissors is an input slice that requires translation to an internal type
	var pScissors unsafe.Pointer
	if len(scissors) > 0 {
		sl_scissors := make([]_vkRect2D, scissorCount)
		for i, v := range scissors {
			sl_scissors[i] = *(v.Vulkanize())
		}
		pScissors = unsafe.Pointer(&sl_scissors[0])
	}

	execTrampoline(keyvkCmdSetScissorWithCount, uintptr(commandBuffer), uintptr(scissorCount), uintptr(unsafe.Pointer(pScissors)))

}

var CmdSetScissorWithCountEXT = CmdSetScissorWithCount

// CmdSetShadingRateImageEnableNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetShadingRateImageEnableNV.html
func CmdSetShadingRateImageEnableNV(commandBuffer CommandBuffer, shadingRateImageEnable bool) {
	shadingRateImageEnable_Bool32 := translateInternal_Bool32(shadingRateImageEnable)

	execTrampoline(keyvkCmdSetShadingRateImageEnableNV, uintptr(commandBuffer), uintptr(shadingRateImageEnable_Bool32))

}

// CmdSetStencilCompareMask: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetStencilCompareMask.html
func CmdSetStencilCompareMask(commandBuffer CommandBuffer, faceMask StencilFaceFlags, compareMask uint32) {

	execTrampoline(keyvkCmdSetStencilCompareMask, uintptr(commandBuffer), uintptr(faceMask), uintptr(compareMask))

}

// CmdSetStencilOp: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetStencilOp.html
func CmdSetStencilOp(commandBuffer CommandBuffer, faceMask StencilFaceFlags, failOp StencilOp, passOp StencilOp, depthFailOp StencilOp, compareOp CompareOp) {

	execTrampoline(keyvkCmdSetStencilOp, uintptr(commandBuffer), uintptr(faceMask), uintptr(failOp), uintptr(passOp), uintptr(depthFailOp), uintptr(compareOp))

}

var CmdSetStencilOpEXT = CmdSetStencilOp

// CmdSetStencilReference: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetStencilReference.html
func CmdSetStencilReference(commandBuffer CommandBuffer, faceMask StencilFaceFlags, reference uint32) {

	execTrampoline(keyvkCmdSetStencilReference, uintptr(commandBuffer), uintptr(faceMask), uintptr(reference))

}

// CmdSetStencilTestEnable: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetStencilTestEnable.html
func CmdSetStencilTestEnable(commandBuffer CommandBuffer, stencilTestEnable bool) {
	stencilTestEnable_Bool32 := translateInternal_Bool32(stencilTestEnable)

	execTrampoline(keyvkCmdSetStencilTestEnable, uintptr(commandBuffer), uintptr(stencilTestEnable_Bool32))

}

var CmdSetStencilTestEnableEXT = CmdSetStencilTestEnable

// CmdSetStencilWriteMask: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetStencilWriteMask.html
func CmdSetStencilWriteMask(commandBuffer CommandBuffer, faceMask StencilFaceFlags, writeMask uint32) {

	execTrampoline(keyvkCmdSetStencilWriteMask, uintptr(commandBuffer), uintptr(faceMask), uintptr(writeMask))

}

// CmdSetTessellationDomainOriginEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetTessellationDomainOriginEXT.html
func CmdSetTessellationDomainOriginEXT(commandBuffer CommandBuffer, domainOrigin TessellationDomainOrigin) {

	execTrampoline(keyvkCmdSetTessellationDomainOriginEXT, uintptr(commandBuffer), uintptr(domainOrigin))

}

// CmdSetVertexInputEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetVertexInputEXT.html
func CmdSetVertexInputEXT(commandBuffer CommandBuffer, vertexBindingDescriptions []VertexInputBindingDescription2EXT, vertexAttributeDescriptions []VertexInputAttributeDescription2EXT) {
	vertexBindingDescriptionCount := len(vertexBindingDescriptions)
	// vertexBindingDescriptions is an input slice that requires translation to an internal type
	var pVertexBindingDescriptions unsafe.Pointer
	if len(vertexBindingDescriptions) > 0 {
		sl_vertexBindingDescriptions := make([]_vkVertexInputBindingDescription2EXT, vertexBindingDescriptionCount)
		for i, v := range vertexBindingDescriptions {
			sl_vertexBindingDescriptions[i] = *(v.Vulkanize())
		}
		pVertexBindingDescriptions = unsafe.Pointer(&sl_vertexBindingDescriptions[0])
	}

	vertexAttributeDescriptionCount := len(vertexAttributeDescriptions)
	// vertexAttributeDescriptions is an input slice that requires translation to an internal type
	var pVertexAttributeDescriptions unsafe.Pointer
	if len(vertexAttributeDescriptions) > 0 {
		sl_vertexAttributeDescriptions := make([]_vkVertexInputAttributeDescription2EXT, vertexAttributeDescriptionCount)
		for i, v := range vertexAttributeDescriptions {
			sl_vertexAttributeDescriptions[i] = *(v.Vulkanize())
		}
		pVertexAttributeDescriptions = unsafe.Pointer(&sl_vertexAttributeDescriptions[0])
	}

	execTrampoline(keyvkCmdSetVertexInputEXT, uintptr(commandBuffer), uintptr(vertexBindingDescriptionCount), uintptr(unsafe.Pointer(pVertexBindingDescriptions)), uintptr(vertexAttributeDescriptionCount), uintptr(unsafe.Pointer(pVertexAttributeDescriptions)))

}

// CmdSetViewport: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetViewport.html
func CmdSetViewport(commandBuffer CommandBuffer, firstViewport uint32, viewports []Viewport) {
	viewportCount := len(viewports)
	// viewports is an input slice of values that do not need translation used
	var pViewports unsafe.Pointer
	if viewports != nil {
		pViewports = unsafe.Pointer(&viewports[0])
	}

	execTrampoline(keyvkCmdSetViewport, uintptr(commandBuffer), uintptr(firstViewport), uintptr(viewportCount), uintptr(unsafe.Pointer(pViewports)))

}

// CmdSetViewportShadingRatePaletteNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetViewportShadingRatePaletteNV.html
func CmdSetViewportShadingRatePaletteNV(commandBuffer CommandBuffer, firstViewport uint32, shadingRatePalettes []ShadingRatePaletteNV) {
	viewportCount := len(shadingRatePalettes)
	// shadingRatePalettes is an input slice that requires translation to an internal type
	var pShadingRatePalettes unsafe.Pointer
	if len(shadingRatePalettes) > 0 {
		sl_shadingRatePalettes := make([]_vkShadingRatePaletteNV, viewportCount)
		for i, v := range shadingRatePalettes {
			sl_shadingRatePalettes[i] = *(v.Vulkanize())
		}
		pShadingRatePalettes = unsafe.Pointer(&sl_shadingRatePalettes[0])
	}

	execTrampoline(keyvkCmdSetViewportShadingRatePaletteNV, uintptr(commandBuffer), uintptr(firstViewport), uintptr(viewportCount), uintptr(unsafe.Pointer(pShadingRatePalettes)))

}

// CmdSetViewportSwizzleNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetViewportSwizzleNV.html
func CmdSetViewportSwizzleNV(commandBuffer CommandBuffer, firstViewport uint32, viewportSwizzles []ViewportSwizzleNV) {
	viewportCount := len(viewportSwizzles)
	// viewportSwizzles is an input slice of values that do not need translation used
	var pViewportSwizzles unsafe.Pointer
	if viewportSwizzles != nil {
		pViewportSwizzles = unsafe.Pointer(&viewportSwizzles[0])
	}

	execTrampoline(keyvkCmdSetViewportSwizzleNV, uintptr(commandBuffer), uintptr(firstViewport), uintptr(viewportCount), uintptr(unsafe.Pointer(pViewportSwizzles)))

}

// CmdSetViewportWScalingEnableNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetViewportWScalingEnableNV.html
func CmdSetViewportWScalingEnableNV(commandBuffer CommandBuffer, viewportWScalingEnable bool) {
	viewportWScalingEnable_Bool32 := translateInternal_Bool32(viewportWScalingEnable)

	execTrampoline(keyvkCmdSetViewportWScalingEnableNV, uintptr(commandBuffer), uintptr(viewportWScalingEnable_Bool32))

}

// CmdSetViewportWScalingNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetViewportWScalingNV.html
func CmdSetViewportWScalingNV(commandBuffer CommandBuffer, firstViewport uint32, viewportWScalings []ViewportWScalingNV) {
	viewportCount := len(viewportWScalings)
	// viewportWScalings is an input slice of values that do not need translation used
	var pViewportWScalings unsafe.Pointer
	if viewportWScalings != nil {
		pViewportWScalings = unsafe.Pointer(&viewportWScalings[0])
	}

	execTrampoline(keyvkCmdSetViewportWScalingNV, uintptr(commandBuffer), uintptr(firstViewport), uintptr(viewportCount), uintptr(unsafe.Pointer(pViewportWScalings)))

}

// CmdSetViewportWithCount: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSetViewportWithCount.html
func CmdSetViewportWithCount(commandBuffer CommandBuffer, viewports []Viewport) {
	viewportCount := len(viewports)
	// viewports is an input slice of values that do not need translation used
	var pViewports unsafe.Pointer
	if viewports != nil {
		pViewports = unsafe.Pointer(&viewports[0])
	}

	execTrampoline(keyvkCmdSetViewportWithCount, uintptr(commandBuffer), uintptr(viewportCount), uintptr(unsafe.Pointer(pViewports)))

}

var CmdSetViewportWithCountEXT = CmdSetViewportWithCount

// CmdSubpassShadingHUAWEI: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdSubpassShadingHUAWEI.html
func CmdSubpassShadingHUAWEI(commandBuffer CommandBuffer) {

	execTrampoline(keyvkCmdSubpassShadingHUAWEI, uintptr(commandBuffer))

}

// CmdTraceRaysIndirect2KHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdTraceRaysIndirect2KHR.html
func CmdTraceRaysIndirect2KHR(commandBuffer CommandBuffer, indirectDeviceAddress DeviceAddress) {

	execTrampoline(keyvkCmdTraceRaysIndirect2KHR, uintptr(commandBuffer), uintptr(indirectDeviceAddress))

}

// CmdTraceRaysIndirectKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdTraceRaysIndirectKHR.html
func CmdTraceRaysIndirectKHR(commandBuffer CommandBuffer, raygenShaderBindingTable *StridedDeviceAddressRegionKHR, missShaderBindingTable *StridedDeviceAddressRegionKHR, hitShaderBindingTable *StridedDeviceAddressRegionKHR, callableShaderBindingTable *StridedDeviceAddressRegionKHR, indirectDeviceAddress DeviceAddress) {
	// Parameter is a singular input, pass direct - raygenShaderBindingTable
	var pRaygenShaderBindingTable unsafe.Pointer
	if raygenShaderBindingTable != nil {
		pRaygenShaderBindingTable = unsafe.Pointer(raygenShaderBindingTable)
	}

	// Parameter is a singular input, pass direct - missShaderBindingTable
	var pMissShaderBindingTable unsafe.Pointer
	if missShaderBindingTable != nil {
		pMissShaderBindingTable = unsafe.Pointer(missShaderBindingTable)
	}

	// Parameter is a singular input, pass direct - hitShaderBindingTable
	var pHitShaderBindingTable unsafe.Pointer
	if hitShaderBindingTable != nil {
		pHitShaderBindingTable = unsafe.Pointer(hitShaderBindingTable)
	}

	// Parameter is a singular input, pass direct - callableShaderBindingTable
	var pCallableShaderBindingTable unsafe.Pointer
	if callableShaderBindingTable != nil {
		pCallableShaderBindingTable = unsafe.Pointer(callableShaderBindingTable)
	}

	execTrampoline(keyvkCmdTraceRaysIndirectKHR, uintptr(commandBuffer), uintptr(unsafe.Pointer(pRaygenShaderBindingTable)), uintptr(unsafe.Pointer(pMissShaderBindingTable)), uintptr(unsafe.Pointer(pHitShaderBindingTable)), uintptr(unsafe.Pointer(pCallableShaderBindingTable)), uintptr(indirectDeviceAddress))

}

// CmdTraceRaysKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdTraceRaysKHR.html
func CmdTraceRaysKHR(commandBuffer CommandBuffer, raygenShaderBindingTable *StridedDeviceAddressRegionKHR, missShaderBindingTable *StridedDeviceAddressRegionKHR, hitShaderBindingTable *StridedDeviceAddressRegionKHR, callableShaderBindingTable *StridedDeviceAddressRegionKHR, width uint32, height uint32, depth uint32) {
	// Parameter is a singular input, pass direct - raygenShaderBindingTable
	var pRaygenShaderBindingTable unsafe.Pointer
	if raygenShaderBindingTable != nil {
		pRaygenShaderBindingTable = unsafe.Pointer(raygenShaderBindingTable)
	}

	// Parameter is a singular input, pass direct - missShaderBindingTable
	var pMissShaderBindingTable unsafe.Pointer
	if missShaderBindingTable != nil {
		pMissShaderBindingTable = unsafe.Pointer(missShaderBindingTable)
	}

	// Parameter is a singular input, pass direct - hitShaderBindingTable
	var pHitShaderBindingTable unsafe.Pointer
	if hitShaderBindingTable != nil {
		pHitShaderBindingTable = unsafe.Pointer(hitShaderBindingTable)
	}

	// Parameter is a singular input, pass direct - callableShaderBindingTable
	var pCallableShaderBindingTable unsafe.Pointer
	if callableShaderBindingTable != nil {
		pCallableShaderBindingTable = unsafe.Pointer(callableShaderBindingTable)
	}

	execTrampoline(keyvkCmdTraceRaysKHR, uintptr(commandBuffer), uintptr(unsafe.Pointer(pRaygenShaderBindingTable)), uintptr(unsafe.Pointer(pMissShaderBindingTable)), uintptr(unsafe.Pointer(pHitShaderBindingTable)), uintptr(unsafe.Pointer(pCallableShaderBindingTable)), uintptr(width), uintptr(height), uintptr(depth))

}

// CmdTraceRaysNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdTraceRaysNV.html
func CmdTraceRaysNV(commandBuffer CommandBuffer, raygenShaderBindingTableBuffer Buffer, raygenShaderBindingOffset DeviceSize, missShaderBindingTableBuffer Buffer, missShaderBindingOffset DeviceSize, missShaderBindingStride DeviceSize, hitShaderBindingTableBuffer Buffer, hitShaderBindingOffset DeviceSize, hitShaderBindingStride DeviceSize, callableShaderBindingTableBuffer Buffer, callableShaderBindingOffset DeviceSize, callableShaderBindingStride DeviceSize, width uint32, height uint32, depth uint32) {

	execTrampoline(keyvkCmdTraceRaysNV, uintptr(commandBuffer), uintptr(raygenShaderBindingTableBuffer), uintptr(raygenShaderBindingOffset), uintptr(missShaderBindingTableBuffer), uintptr(missShaderBindingOffset), uintptr(missShaderBindingStride), uintptr(hitShaderBindingTableBuffer), uintptr(hitShaderBindingOffset), uintptr(hitShaderBindingStride), uintptr(callableShaderBindingTableBuffer), uintptr(callableShaderBindingOffset), uintptr(callableShaderBindingStride), uintptr(width), uintptr(height), uintptr(depth))

}

// CmdUpdateBuffer: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdUpdateBuffer.html
func CmdUpdateBuffer(commandBuffer CommandBuffer, dstBuffer Buffer, dstOffset DeviceSize, data []byte) {
	dataSize := len(data)
	// data is an input slice of values that do not need translation used
	var pData unsafe.Pointer
	if data != nil {
		pData = unsafe.Pointer(&data[0])
	}

	execTrampoline(keyvkCmdUpdateBuffer, uintptr(commandBuffer), uintptr(dstBuffer), uintptr(dstOffset), uintptr(dataSize), uintptr(unsafe.Pointer(pData)))

}

// CmdWaitEvents: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdWaitEvents.html
func CmdWaitEvents(commandBuffer CommandBuffer, events []Event, srcStageMask PipelineStageFlags, dstStageMask PipelineStageFlags, memoryBarriers []MemoryBarrier, bufferMemoryBarriers []BufferMemoryBarrier, imageMemoryBarriers []ImageMemoryBarrier) {
	eventCount := len(events)
	// events is an input slice of values that do not need translation used
	var pEvents unsafe.Pointer
	if events != nil {
		pEvents = unsafe.Pointer(&events[0])
	}

	memoryBarrierCount := len(memoryBarriers)
	// memoryBarriers is an input slice that requires translation to an internal type
	var pMemoryBarriers unsafe.Pointer
	if len(memoryBarriers) > 0 {
		sl_memoryBarriers := make([]_vkMemoryBarrier, memoryBarrierCount)
		for i, v := range memoryBarriers {
			sl_memoryBarriers[i] = *(v.Vulkanize())
		}
		pMemoryBarriers = unsafe.Pointer(&sl_memoryBarriers[0])
	}

	bufferMemoryBarrierCount := len(bufferMemoryBarriers)
	// bufferMemoryBarriers is an input slice that requires translation to an internal type
	var pBufferMemoryBarriers unsafe.Pointer
	if len(bufferMemoryBarriers) > 0 {
		sl_bufferMemoryBarriers := make([]_vkBufferMemoryBarrier, bufferMemoryBarrierCount)
		for i, v := range bufferMemoryBarriers {
			sl_bufferMemoryBarriers[i] = *(v.Vulkanize())
		}
		pBufferMemoryBarriers = unsafe.Pointer(&sl_bufferMemoryBarriers[0])
	}

	imageMemoryBarrierCount := len(imageMemoryBarriers)
	// imageMemoryBarriers is an input slice that requires translation to an internal type
	var pImageMemoryBarriers unsafe.Pointer
	if len(imageMemoryBarriers) > 0 {
		sl_imageMemoryBarriers := make([]_vkImageMemoryBarrier, imageMemoryBarrierCount)
		for i, v := range imageMemoryBarriers {
			sl_imageMemoryBarriers[i] = *(v.Vulkanize())
		}
		pImageMemoryBarriers = unsafe.Pointer(&sl_imageMemoryBarriers[0])
	}

	execTrampoline(keyvkCmdWaitEvents, uintptr(commandBuffer), uintptr(eventCount), uintptr(unsafe.Pointer(pEvents)), uintptr(srcStageMask), uintptr(dstStageMask), uintptr(memoryBarrierCount), uintptr(unsafe.Pointer(pMemoryBarriers)), uintptr(bufferMemoryBarrierCount), uintptr(unsafe.Pointer(pBufferMemoryBarriers)), uintptr(imageMemoryBarrierCount), uintptr(unsafe.Pointer(pImageMemoryBarriers)))

}

// CmdWaitEvents2: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdWaitEvents2.html
func CmdWaitEvents2(commandBuffer CommandBuffer, events []Event, dependencyInfos []DependencyInfo) {
	eventCount := len(events)
	// events is an input slice of values that do not need translation used
	var pEvents unsafe.Pointer
	if events != nil {
		pEvents = unsafe.Pointer(&events[0])
	}

	// dependencyInfos is an input slice that requires translation to an internal type
	var pDependencyInfos unsafe.Pointer
	if len(dependencyInfos) > 0 {
		sl_dependencyInfos := make([]_vkDependencyInfo, eventCount)
		for i, v := range dependencyInfos {
			sl_dependencyInfos[i] = *(v.Vulkanize())
		}
		pDependencyInfos = unsafe.Pointer(&sl_dependencyInfos[0])
	}

	execTrampoline(keyvkCmdWaitEvents2, uintptr(commandBuffer), uintptr(eventCount), uintptr(unsafe.Pointer(pEvents)), uintptr(unsafe.Pointer(pDependencyInfos)))

}

var CmdWaitEvents2KHR = CmdWaitEvents2

// CmdWriteAccelerationStructuresPropertiesKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdWriteAccelerationStructuresPropertiesKHR.html
func CmdWriteAccelerationStructuresPropertiesKHR(commandBuffer CommandBuffer, accelerationStructures []AccelerationStructureKHR, queryType QueryType, queryPool QueryPool, firstQuery uint32) {
	accelerationStructureCount := len(accelerationStructures)
	// accelerationStructures is an input slice of values that do not need translation used
	var pAccelerationStructures unsafe.Pointer
	if accelerationStructures != nil {
		pAccelerationStructures = unsafe.Pointer(&accelerationStructures[0])
	}

	execTrampoline(keyvkCmdWriteAccelerationStructuresPropertiesKHR, uintptr(commandBuffer), uintptr(accelerationStructureCount), uintptr(unsafe.Pointer(pAccelerationStructures)), uintptr(queryType), uintptr(queryPool), uintptr(firstQuery))

}

// CmdWriteAccelerationStructuresPropertiesNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdWriteAccelerationStructuresPropertiesNV.html
func CmdWriteAccelerationStructuresPropertiesNV(commandBuffer CommandBuffer, accelerationStructures []AccelerationStructureNV, queryType QueryType, queryPool QueryPool, firstQuery uint32) {
	accelerationStructureCount := len(accelerationStructures)
	// accelerationStructures is an input slice of values that do not need translation used
	var pAccelerationStructures unsafe.Pointer
	if accelerationStructures != nil {
		pAccelerationStructures = unsafe.Pointer(&accelerationStructures[0])
	}

	execTrampoline(keyvkCmdWriteAccelerationStructuresPropertiesNV, uintptr(commandBuffer), uintptr(accelerationStructureCount), uintptr(unsafe.Pointer(pAccelerationStructures)), uintptr(queryType), uintptr(queryPool), uintptr(firstQuery))

}

// CmdWriteBufferMarker2AMD: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdWriteBufferMarker2AMD.html
func CmdWriteBufferMarker2AMD(commandBuffer CommandBuffer, stage PipelineStageFlags2, dstBuffer Buffer, dstOffset DeviceSize, marker uint32) {

	execTrampoline(keyvkCmdWriteBufferMarker2AMD, uintptr(commandBuffer), uintptr(stage), uintptr(dstBuffer), uintptr(dstOffset), uintptr(marker))

}

// CmdWriteBufferMarkerAMD: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdWriteBufferMarkerAMD.html
func CmdWriteBufferMarkerAMD(commandBuffer CommandBuffer, pipelineStage PipelineStageFlagBits, dstBuffer Buffer, dstOffset DeviceSize, marker uint32) {

	execTrampoline(keyvkCmdWriteBufferMarkerAMD, uintptr(commandBuffer), uintptr(pipelineStage), uintptr(dstBuffer), uintptr(dstOffset), uintptr(marker))

}

// CmdWriteMicromapsPropertiesEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdWriteMicromapsPropertiesEXT.html
func CmdWriteMicromapsPropertiesEXT(commandBuffer CommandBuffer, micromaps []MicromapEXT, queryType QueryType, queryPool QueryPool, firstQuery uint32) {
	micromapCount := len(micromaps)
	// micromaps is an input slice of values that do not need translation used
	var pMicromaps unsafe.Pointer
	if micromaps != nil {
		pMicromaps = unsafe.Pointer(&micromaps[0])
	}

	execTrampoline(keyvkCmdWriteMicromapsPropertiesEXT, uintptr(commandBuffer), uintptr(micromapCount), uintptr(unsafe.Pointer(pMicromaps)), uintptr(queryType), uintptr(queryPool), uintptr(firstQuery))

}

// CmdWriteTimestamp: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdWriteTimestamp.html
func CmdWriteTimestamp(commandBuffer CommandBuffer, pipelineStage PipelineStageFlagBits, queryPool QueryPool, query uint32) {

	execTrampoline(keyvkCmdWriteTimestamp, uintptr(commandBuffer), uintptr(pipelineStage), uintptr(queryPool), uintptr(query))

}

// CmdWriteTimestamp2: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCmdWriteTimestamp2.html
func CmdWriteTimestamp2(commandBuffer CommandBuffer, stage PipelineStageFlags2, queryPool QueryPool, query uint32) {

	execTrampoline(keyvkCmdWriteTimestamp2, uintptr(commandBuffer), uintptr(stage), uintptr(queryPool), uintptr(query))

}

var CmdWriteTimestamp2KHR = CmdWriteTimestamp2

// CompileDeferredNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCompileDeferredNV.html
func CompileDeferredNV(device Device, pipeline Pipeline, shader uint32) (r Result) {

	r = Result(execTrampoline(keyvkCompileDeferredNV, uintptr(device), uintptr(pipeline), uintptr(shader)))

	return
}

// CopyAccelerationStructureKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCopyAccelerationStructureKHR.html
func CopyAccelerationStructureKHR(device Device, deferredOperation DeferredOperationKHR, info *CopyAccelerationStructureInfoKHR) (r Result) {
	// Parameter is a singular input, requires translation - info
	var pInfo *_vkCopyAccelerationStructureInfoKHR
	if info != nil {
		pInfo = info.Vulkanize()
	}

	r = Result(execTrampoline(keyvkCopyAccelerationStructureKHR, uintptr(device), uintptr(deferredOperation), uintptr(unsafe.Pointer(pInfo))))

	return
}

// CopyAccelerationStructureToMemoryKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCopyAccelerationStructureToMemoryKHR.html
func CopyAccelerationStructureToMemoryKHR(device Device, deferredOperation DeferredOperationKHR, info *CopyAccelerationStructureToMemoryInfoKHR) (r Result) {
	// Parameter is a singular input, requires translation - info
	var pInfo *_vkCopyAccelerationStructureToMemoryInfoKHR
	if info != nil {
		pInfo = info.Vulkanize()
	}

	r = Result(execTrampoline(keyvkCopyAccelerationStructureToMemoryKHR, uintptr(device), uintptr(deferredOperation), uintptr(unsafe.Pointer(pInfo))))

	return
}

// CopyMemoryToAccelerationStructureKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCopyMemoryToAccelerationStructureKHR.html
func CopyMemoryToAccelerationStructureKHR(device Device, deferredOperation DeferredOperationKHR, info *CopyMemoryToAccelerationStructureInfoKHR) (r Result) {
	// Parameter is a singular input, requires translation - info
	var pInfo *_vkCopyMemoryToAccelerationStructureInfoKHR
	if info != nil {
		pInfo = info.Vulkanize()
	}

	r = Result(execTrampoline(keyvkCopyMemoryToAccelerationStructureKHR, uintptr(device), uintptr(deferredOperation), uintptr(unsafe.Pointer(pInfo))))

	return
}

// CopyMemoryToMicromapEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCopyMemoryToMicromapEXT.html
func CopyMemoryToMicromapEXT(device Device, deferredOperation DeferredOperationKHR, info *CopyMemoryToMicromapInfoEXT) (r Result) {
	// Parameter is a singular input, requires translation - info
	var pInfo *_vkCopyMemoryToMicromapInfoEXT
	if info != nil {
		pInfo = info.Vulkanize()
	}

	r = Result(execTrampoline(keyvkCopyMemoryToMicromapEXT, uintptr(device), uintptr(deferredOperation), uintptr(unsafe.Pointer(pInfo))))

	return
}

// CopyMicromapEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCopyMicromapEXT.html
func CopyMicromapEXT(device Device, deferredOperation DeferredOperationKHR, info *CopyMicromapInfoEXT) (r Result) {
	// Parameter is a singular input, requires translation - info
	var pInfo *_vkCopyMicromapInfoEXT
	if info != nil {
		pInfo = info.Vulkanize()
	}

	r = Result(execTrampoline(keyvkCopyMicromapEXT, uintptr(device), uintptr(deferredOperation), uintptr(unsafe.Pointer(pInfo))))

	return
}

// CopyMicromapToMemoryEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCopyMicromapToMemoryEXT.html
func CopyMicromapToMemoryEXT(device Device, deferredOperation DeferredOperationKHR, info *CopyMicromapToMemoryInfoEXT) (r Result) {
	// Parameter is a singular input, requires translation - info
	var pInfo *_vkCopyMicromapToMemoryInfoEXT
	if info != nil {
		pInfo = info.Vulkanize()
	}

	r = Result(execTrampoline(keyvkCopyMicromapToMemoryEXT, uintptr(device), uintptr(deferredOperation), uintptr(unsafe.Pointer(pInfo))))

	return
}

// CreateAccelerationStructureKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateAccelerationStructureKHR.html
func CreateAccelerationStructureKHR(device Device, createInfo *AccelerationStructureCreateInfoKHR, allocator *AllocationCallbacks) (r Result, accelerationStructure AccelerationStructureKHR) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkAccelerationStructureCreateInfoKHR
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// accelerationStructure is a binding-allocated single return value and will be populated by Vulkan
	ptr_pAccelerationStructure := &accelerationStructure

	r = Result(execTrampoline(keyvkCreateAccelerationStructureKHR, uintptr(device), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pAccelerationStructure))))

	return
}

// CreateAccelerationStructureNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateAccelerationStructureNV.html
func CreateAccelerationStructureNV(device Device, createInfo *AccelerationStructureCreateInfoNV, allocator *AllocationCallbacks) (r Result, accelerationStructure AccelerationStructureNV) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkAccelerationStructureCreateInfoNV
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// accelerationStructure is a binding-allocated single return value and will be populated by Vulkan
	ptr_pAccelerationStructure := &accelerationStructure

	r = Result(execTrampoline(keyvkCreateAccelerationStructureNV, uintptr(device), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pAccelerationStructure))))

	return
}

// CreateBuffer: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateBuffer.html
func CreateBuffer(device Device, createInfo *BufferCreateInfo, allocator *AllocationCallbacks) (r Result, buffer Buffer) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkBufferCreateInfo
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// buffer is a binding-allocated single return value and will be populated by Vulkan
	ptr_pBuffer := &buffer

	r = Result(execTrampoline(keyvkCreateBuffer, uintptr(device), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pBuffer))))

	return
}

// CreateBufferView: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateBufferView.html
func CreateBufferView(device Device, createInfo *BufferViewCreateInfo, allocator *AllocationCallbacks) (r Result, view BufferView) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkBufferViewCreateInfo
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// view is a binding-allocated single return value and will be populated by Vulkan
	ptr_pView := &view

	r = Result(execTrampoline(keyvkCreateBufferView, uintptr(device), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pView))))

	return
}

// CreateCommandPool: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateCommandPool.html
func CreateCommandPool(device Device, createInfo *CommandPoolCreateInfo, allocator *AllocationCallbacks) (r Result, commandPool CommandPool) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkCommandPoolCreateInfo
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// commandPool is a binding-allocated single return value and will be populated by Vulkan
	ptr_pCommandPool := &commandPool

	r = Result(execTrampoline(keyvkCreateCommandPool, uintptr(device), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pCommandPool))))

	return
}

// CreateComputePipelines: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateComputePipelines.html
func CreateComputePipelines(device Device, pipelineCache PipelineCache, createInfos []ComputePipelineCreateInfo, allocator *AllocationCallbacks) (r Result, pipelines []Pipeline) {
	createInfoCount := len(createInfos)
	// createInfos is an input slice that requires translation to an internal type
	var pCreateInfos unsafe.Pointer
	if len(createInfos) > 0 {
		sl_createInfos := make([]_vkComputePipelineCreateInfo, createInfoCount)
		for i, v := range createInfos {
			sl_createInfos[i] = *(v.Vulkanize())
		}
		pCreateInfos = unsafe.Pointer(&sl_createInfos[0])
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// pipelines is an output array that will be allocated by the binding, len is from createInfoCount
	pipelines = make([]Pipeline, createInfoCount)
	pPipelines := unsafe.Pointer(&pipelines[0])

	r = Result(execTrampoline(keyvkCreateComputePipelines, uintptr(device), uintptr(pipelineCache), uintptr(createInfoCount), uintptr(unsafe.Pointer(pCreateInfos)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(pPipelines))))

	return
}

// CreateCuFunctionNVX: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateCuFunctionNVX.html
func CreateCuFunctionNVX(device Device, createInfo *CuFunctionCreateInfoNVX, allocator *AllocationCallbacks) (r Result, function CuFunctionNVX) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkCuFunctionCreateInfoNVX
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// function is a binding-allocated single return value and will be populated by Vulkan
	ptr_pFunction := &function

	r = Result(execTrampoline(keyvkCreateCuFunctionNVX, uintptr(device), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pFunction))))

	return
}

// CreateCuModuleNVX: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateCuModuleNVX.html
func CreateCuModuleNVX(device Device, createInfo *CuModuleCreateInfoNVX, allocator *AllocationCallbacks) (r Result, module CuModuleNVX) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkCuModuleCreateInfoNVX
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// module is a binding-allocated single return value and will be populated by Vulkan
	ptr_pModule := &module

	r = Result(execTrampoline(keyvkCreateCuModuleNVX, uintptr(device), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pModule))))

	return
}

// CreateDebugReportCallbackEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateDebugReportCallbackEXT.html
func CreateDebugReportCallbackEXT(instance Instance, createInfo *DebugReportCallbackCreateInfoEXT, allocator *AllocationCallbacks) (r Result, callback DebugReportCallbackEXT) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkDebugReportCallbackCreateInfoEXT
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// callback is a binding-allocated single return value and will be populated by Vulkan
	ptr_pCallback := &callback

	r = Result(execTrampoline(keyvkCreateDebugReportCallbackEXT, uintptr(instance), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pCallback))))

	return
}

// CreateDebugUtilsMessengerEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateDebugUtilsMessengerEXT.html
func CreateDebugUtilsMessengerEXT(instance Instance, createInfo *DebugUtilsMessengerCreateInfoEXT, allocator *AllocationCallbacks) (r Result, messenger DebugUtilsMessengerEXT) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkDebugUtilsMessengerCreateInfoEXT
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// messenger is a binding-allocated single return value and will be populated by Vulkan
	ptr_pMessenger := &messenger

	r = Result(execTrampoline(keyvkCreateDebugUtilsMessengerEXT, uintptr(instance), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pMessenger))))

	return
}

// CreateDeferredOperationKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateDeferredOperationKHR.html
func CreateDeferredOperationKHR(device Device, allocator *AllocationCallbacks) (r Result, deferredOperation DeferredOperationKHR) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// deferredOperation is a binding-allocated single return value and will be populated by Vulkan
	ptr_pDeferredOperation := &deferredOperation

	r = Result(execTrampoline(keyvkCreateDeferredOperationKHR, uintptr(device), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pDeferredOperation))))

	return
}

// CreateDescriptorPool: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateDescriptorPool.html
func CreateDescriptorPool(device Device, createInfo *DescriptorPoolCreateInfo, allocator *AllocationCallbacks) (r Result, descriptorPool DescriptorPool) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkDescriptorPoolCreateInfo
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// descriptorPool is a binding-allocated single return value and will be populated by Vulkan
	ptr_pDescriptorPool := &descriptorPool

	r = Result(execTrampoline(keyvkCreateDescriptorPool, uintptr(device), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pDescriptorPool))))

	return
}

// CreateDescriptorSetLayout: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateDescriptorSetLayout.html
func CreateDescriptorSetLayout(device Device, createInfo *DescriptorSetLayoutCreateInfo, allocator *AllocationCallbacks) (r Result, setLayout DescriptorSetLayout) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkDescriptorSetLayoutCreateInfo
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// setLayout is a binding-allocated single return value and will be populated by Vulkan
	ptr_pSetLayout := &setLayout

	r = Result(execTrampoline(keyvkCreateDescriptorSetLayout, uintptr(device), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pSetLayout))))

	return
}

// CreateDescriptorUpdateTemplate: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateDescriptorUpdateTemplate.html
func CreateDescriptorUpdateTemplate(device Device, createInfo *DescriptorUpdateTemplateCreateInfo, allocator *AllocationCallbacks) (r Result, descriptorUpdateTemplate DescriptorUpdateTemplate) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkDescriptorUpdateTemplateCreateInfo
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// descriptorUpdateTemplate is a binding-allocated single return value and will be populated by Vulkan
	ptr_pDescriptorUpdateTemplate := &descriptorUpdateTemplate

	r = Result(execTrampoline(keyvkCreateDescriptorUpdateTemplate, uintptr(device), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pDescriptorUpdateTemplate))))

	return
}

var CreateDescriptorUpdateTemplateKHR = CreateDescriptorUpdateTemplate

// CreateDevice: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateDevice.html
func CreateDevice(physicalDevice PhysicalDevice, createInfo *DeviceCreateInfo, allocator *AllocationCallbacks) (r Result, device Device) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkDeviceCreateInfo
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// device is a binding-allocated single return value and will be populated by Vulkan
	ptr_pDevice := &device

	r = Result(execTrampoline(keyvkCreateDevice, uintptr(physicalDevice), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pDevice))))

	return
}

// CreateDisplayModeKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateDisplayModeKHR.html
func CreateDisplayModeKHR(physicalDevice PhysicalDevice, display DisplayKHR, createInfo *DisplayModeCreateInfoKHR, allocator *AllocationCallbacks) (r Result, mode DisplayModeKHR) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkDisplayModeCreateInfoKHR
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// mode is a binding-allocated single return value and will be populated by Vulkan
	ptr_pMode := &mode

	r = Result(execTrampoline(keyvkCreateDisplayModeKHR, uintptr(physicalDevice), uintptr(display), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pMode))))

	return
}

// CreateDisplayPlaneSurfaceKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateDisplayPlaneSurfaceKHR.html
func CreateDisplayPlaneSurfaceKHR(instance Instance, createInfo *DisplaySurfaceCreateInfoKHR, allocator *AllocationCallbacks) (r Result, surface SurfaceKHR) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkDisplaySurfaceCreateInfoKHR
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// surface is a binding-allocated single return value and will be populated by Vulkan
	ptr_pSurface := &surface

	r = Result(execTrampoline(keyvkCreateDisplayPlaneSurfaceKHR, uintptr(instance), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pSurface))))

	return
}

// CreateEvent: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateEvent.html
func CreateEvent(device Device, createInfo *EventCreateInfo, allocator *AllocationCallbacks) (r Result, event Event) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkEventCreateInfo
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// event is a binding-allocated single return value and will be populated by Vulkan
	ptr_pEvent := &event

	r = Result(execTrampoline(keyvkCreateEvent, uintptr(device), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pEvent))))

	return
}

// CreateFence: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateFence.html
func CreateFence(device Device, createInfo *FenceCreateInfo, allocator *AllocationCallbacks) (r Result, fence Fence) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkFenceCreateInfo
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// fence is a binding-allocated single return value and will be populated by Vulkan
	ptr_pFence := &fence

	r = Result(execTrampoline(keyvkCreateFence, uintptr(device), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pFence))))

	return
}

// CreateFramebuffer: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateFramebuffer.html
func CreateFramebuffer(device Device, createInfo *FramebufferCreateInfo, allocator *AllocationCallbacks) (r Result, framebuffer Framebuffer) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkFramebufferCreateInfo
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// framebuffer is a binding-allocated single return value and will be populated by Vulkan
	ptr_pFramebuffer := &framebuffer

	r = Result(execTrampoline(keyvkCreateFramebuffer, uintptr(device), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pFramebuffer))))

	return
}

// CreateGraphicsPipelines: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateGraphicsPipelines.html
func CreateGraphicsPipelines(device Device, pipelineCache PipelineCache, createInfos []GraphicsPipelineCreateInfo, allocator *AllocationCallbacks) (r Result, pipelines []Pipeline) {
	createInfoCount := len(createInfos)
	// createInfos is an input slice that requires translation to an internal type
	var pCreateInfos unsafe.Pointer
	if len(createInfos) > 0 {
		sl_createInfos := make([]_vkGraphicsPipelineCreateInfo, createInfoCount)
		for i, v := range createInfos {
			sl_createInfos[i] = *(v.Vulkanize())
		}
		pCreateInfos = unsafe.Pointer(&sl_createInfos[0])
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// pipelines is an output array that will be allocated by the binding, len is from createInfoCount
	pipelines = make([]Pipeline, createInfoCount)
	pPipelines := unsafe.Pointer(&pipelines[0])

	r = Result(execTrampoline(keyvkCreateGraphicsPipelines, uintptr(device), uintptr(pipelineCache), uintptr(createInfoCount), uintptr(unsafe.Pointer(pCreateInfos)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(pPipelines))))

	return
}

// CreateHeadlessSurfaceEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateHeadlessSurfaceEXT.html
func CreateHeadlessSurfaceEXT(instance Instance, createInfo *HeadlessSurfaceCreateInfoEXT, allocator *AllocationCallbacks) (r Result, surface SurfaceKHR) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkHeadlessSurfaceCreateInfoEXT
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// surface is a binding-allocated single return value and will be populated by Vulkan
	ptr_pSurface := &surface

	r = Result(execTrampoline(keyvkCreateHeadlessSurfaceEXT, uintptr(instance), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pSurface))))

	return
}

// CreateImage: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateImage.html
func CreateImage(device Device, createInfo *ImageCreateInfo, allocator *AllocationCallbacks) (r Result, image Image) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkImageCreateInfo
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// image is a binding-allocated single return value and will be populated by Vulkan
	ptr_pImage := &image

	r = Result(execTrampoline(keyvkCreateImage, uintptr(device), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pImage))))

	return
}

// CreateImageView: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateImageView.html
func CreateImageView(device Device, createInfo *ImageViewCreateInfo, allocator *AllocationCallbacks) (r Result, view ImageView) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkImageViewCreateInfo
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// view is a binding-allocated single return value and will be populated by Vulkan
	ptr_pView := &view

	r = Result(execTrampoline(keyvkCreateImageView, uintptr(device), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pView))))

	return
}

// CreateIndirectCommandsLayoutNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateIndirectCommandsLayoutNV.html
func CreateIndirectCommandsLayoutNV(device Device, createInfo *IndirectCommandsLayoutCreateInfoNV, allocator *AllocationCallbacks) (r Result, indirectCommandsLayout IndirectCommandsLayoutNV) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkIndirectCommandsLayoutCreateInfoNV
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// indirectCommandsLayout is a binding-allocated single return value and will be populated by Vulkan
	ptr_pIndirectCommandsLayout := &indirectCommandsLayout

	r = Result(execTrampoline(keyvkCreateIndirectCommandsLayoutNV, uintptr(device), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pIndirectCommandsLayout))))

	return
}

// CreateInstance: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateInstance.html
func CreateInstance(createInfo *InstanceCreateInfo, allocator *AllocationCallbacks) (r Result, instance Instance) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkInstanceCreateInfo
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// instance is a binding-allocated single return value and will be populated by Vulkan
	ptr_pInstance := &instance

	r = Result(execTrampoline(keyvkCreateInstance, uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pInstance))))

	return
}

// CreateMicromapEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateMicromapEXT.html
func CreateMicromapEXT(device Device, createInfo *MicromapCreateInfoEXT, allocator *AllocationCallbacks) (r Result, micromap MicromapEXT) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkMicromapCreateInfoEXT
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// micromap is a binding-allocated single return value and will be populated by Vulkan
	ptr_pMicromap := &micromap

	r = Result(execTrampoline(keyvkCreateMicromapEXT, uintptr(device), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pMicromap))))

	return
}

// CreateOpticalFlowSessionNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateOpticalFlowSessionNV.html
func CreateOpticalFlowSessionNV(device Device, createInfo *OpticalFlowSessionCreateInfoNV, allocator *AllocationCallbacks) (r Result, session OpticalFlowSessionNV) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkOpticalFlowSessionCreateInfoNV
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// session is a binding-allocated single return value and will be populated by Vulkan
	ptr_pSession := &session

	r = Result(execTrampoline(keyvkCreateOpticalFlowSessionNV, uintptr(device), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pSession))))

	return
}

// CreatePipelineCache: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreatePipelineCache.html
func CreatePipelineCache(device Device, createInfo *PipelineCacheCreateInfo, allocator *AllocationCallbacks) (r Result, pipelineCache PipelineCache) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkPipelineCacheCreateInfo
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// pipelineCache is a binding-allocated single return value and will be populated by Vulkan
	ptr_pPipelineCache := &pipelineCache

	r = Result(execTrampoline(keyvkCreatePipelineCache, uintptr(device), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pPipelineCache))))

	return
}

// CreatePipelineLayout: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreatePipelineLayout.html
func CreatePipelineLayout(device Device, createInfo *PipelineLayoutCreateInfo, allocator *AllocationCallbacks) (r Result, pipelineLayout PipelineLayout) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkPipelineLayoutCreateInfo
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// pipelineLayout is a binding-allocated single return value and will be populated by Vulkan
	ptr_pPipelineLayout := &pipelineLayout

	r = Result(execTrampoline(keyvkCreatePipelineLayout, uintptr(device), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pPipelineLayout))))

	return
}

// CreatePrivateDataSlot: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreatePrivateDataSlot.html
func CreatePrivateDataSlot(device Device, createInfo *PrivateDataSlotCreateInfo, allocator *AllocationCallbacks) (r Result, privateDataSlot PrivateDataSlot) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkPrivateDataSlotCreateInfo
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// privateDataSlot is a binding-allocated single return value and will be populated by Vulkan
	ptr_pPrivateDataSlot := &privateDataSlot

	r = Result(execTrampoline(keyvkCreatePrivateDataSlot, uintptr(device), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pPrivateDataSlot))))

	return
}

var CreatePrivateDataSlotEXT = CreatePrivateDataSlot

// CreateQueryPool: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateQueryPool.html
func CreateQueryPool(device Device, createInfo *QueryPoolCreateInfo, allocator *AllocationCallbacks) (r Result, queryPool QueryPool) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkQueryPoolCreateInfo
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// queryPool is a binding-allocated single return value and will be populated by Vulkan
	ptr_pQueryPool := &queryPool

	r = Result(execTrampoline(keyvkCreateQueryPool, uintptr(device), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pQueryPool))))

	return
}

// CreateRayTracingPipelinesKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateRayTracingPipelinesKHR.html
func CreateRayTracingPipelinesKHR(device Device, deferredOperation DeferredOperationKHR, pipelineCache PipelineCache, createInfos []RayTracingPipelineCreateInfoKHR, allocator *AllocationCallbacks) (r Result, pipelines []Pipeline) {
	createInfoCount := len(createInfos)
	// createInfos is an input slice that requires translation to an internal type
	var pCreateInfos unsafe.Pointer
	if len(createInfos) > 0 {
		sl_createInfos := make([]_vkRayTracingPipelineCreateInfoKHR, createInfoCount)
		for i, v := range createInfos {
			sl_createInfos[i] = *(v.Vulkanize())
		}
		pCreateInfos = unsafe.Pointer(&sl_createInfos[0])
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// pipelines is an output array that will be allocated by the binding, len is from createInfoCount
	pipelines = make([]Pipeline, createInfoCount)
	pPipelines := unsafe.Pointer(&pipelines[0])

	r = Result(execTrampoline(keyvkCreateRayTracingPipelinesKHR, uintptr(device), uintptr(deferredOperation), uintptr(pipelineCache), uintptr(createInfoCount), uintptr(unsafe.Pointer(pCreateInfos)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(pPipelines))))

	return
}

// CreateRayTracingPipelinesNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateRayTracingPipelinesNV.html
func CreateRayTracingPipelinesNV(device Device, pipelineCache PipelineCache, createInfos []RayTracingPipelineCreateInfoNV, allocator *AllocationCallbacks) (r Result, pipelines []Pipeline) {
	createInfoCount := len(createInfos)
	// createInfos is an input slice that requires translation to an internal type
	var pCreateInfos unsafe.Pointer
	if len(createInfos) > 0 {
		sl_createInfos := make([]_vkRayTracingPipelineCreateInfoNV, createInfoCount)
		for i, v := range createInfos {
			sl_createInfos[i] = *(v.Vulkanize())
		}
		pCreateInfos = unsafe.Pointer(&sl_createInfos[0])
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// pipelines is an output array that will be allocated by the binding, len is from createInfoCount
	pipelines = make([]Pipeline, createInfoCount)
	pPipelines := unsafe.Pointer(&pipelines[0])

	r = Result(execTrampoline(keyvkCreateRayTracingPipelinesNV, uintptr(device), uintptr(pipelineCache), uintptr(createInfoCount), uintptr(unsafe.Pointer(pCreateInfos)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(pPipelines))))

	return
}

// CreateRenderPass: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateRenderPass.html
func CreateRenderPass(device Device, createInfo *RenderPassCreateInfo, allocator *AllocationCallbacks) (r Result, renderPass RenderPass) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkRenderPassCreateInfo
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// renderPass is a binding-allocated single return value and will be populated by Vulkan
	ptr_pRenderPass := &renderPass

	r = Result(execTrampoline(keyvkCreateRenderPass, uintptr(device), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pRenderPass))))

	return
}

// CreateRenderPass2: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateRenderPass2.html
func CreateRenderPass2(device Device, createInfo *RenderPassCreateInfo2, allocator *AllocationCallbacks) (r Result, renderPass RenderPass) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkRenderPassCreateInfo2
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// renderPass is a binding-allocated single return value and will be populated by Vulkan
	ptr_pRenderPass := &renderPass

	r = Result(execTrampoline(keyvkCreateRenderPass2, uintptr(device), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pRenderPass))))

	return
}

var CreateRenderPass2KHR = CreateRenderPass2

// CreateSampler: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateSampler.html
func CreateSampler(device Device, createInfo *SamplerCreateInfo, allocator *AllocationCallbacks) (r Result, sampler Sampler) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkSamplerCreateInfo
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// sampler is a binding-allocated single return value and will be populated by Vulkan
	ptr_pSampler := &sampler

	r = Result(execTrampoline(keyvkCreateSampler, uintptr(device), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pSampler))))

	return
}

// CreateSamplerYcbcrConversion: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateSamplerYcbcrConversion.html
func CreateSamplerYcbcrConversion(device Device, createInfo *SamplerYcbcrConversionCreateInfo, allocator *AllocationCallbacks) (r Result, ycbcrConversion SamplerYcbcrConversion) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkSamplerYcbcrConversionCreateInfo
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// ycbcrConversion is a binding-allocated single return value and will be populated by Vulkan
	ptr_pYcbcrConversion := &ycbcrConversion

	r = Result(execTrampoline(keyvkCreateSamplerYcbcrConversion, uintptr(device), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pYcbcrConversion))))

	return
}

var CreateSamplerYcbcrConversionKHR = CreateSamplerYcbcrConversion

// CreateSemaphore: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateSemaphore.html
func CreateSemaphore(device Device, createInfo *SemaphoreCreateInfo, allocator *AllocationCallbacks) (r Result, semaphore Semaphore) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkSemaphoreCreateInfo
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// semaphore is a binding-allocated single return value and will be populated by Vulkan
	ptr_pSemaphore := &semaphore

	r = Result(execTrampoline(keyvkCreateSemaphore, uintptr(device), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pSemaphore))))

	return
}

// CreateShaderModule: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateShaderModule.html
func CreateShaderModule(device Device, createInfo *ShaderModuleCreateInfo, allocator *AllocationCallbacks) (r Result, shaderModule ShaderModule) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkShaderModuleCreateInfo
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// shaderModule is a binding-allocated single return value and will be populated by Vulkan
	ptr_pShaderModule := &shaderModule

	r = Result(execTrampoline(keyvkCreateShaderModule, uintptr(device), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pShaderModule))))

	return
}

// CreateSharedSwapchainsKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateSharedSwapchainsKHR.html
func CreateSharedSwapchainsKHR(device Device, createInfos []SwapchainCreateInfoKHR, allocator *AllocationCallbacks) (r Result, swapchains []SwapchainKHR) {
	swapchainCount := len(createInfos)
	// createInfos is an input slice that requires translation to an internal type
	var pCreateInfos unsafe.Pointer
	if len(createInfos) > 0 {
		sl_createInfos := make([]_vkSwapchainCreateInfoKHR, swapchainCount)
		for i, v := range createInfos {
			sl_createInfos[i] = *(v.Vulkanize())
		}
		pCreateInfos = unsafe.Pointer(&sl_createInfos[0])
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// swapchains is an output array that will be allocated by the binding, len is from swapchainCount
	swapchains = make([]SwapchainKHR, swapchainCount)
	pSwapchains := unsafe.Pointer(&swapchains[0])

	r = Result(execTrampoline(keyvkCreateSharedSwapchainsKHR, uintptr(device), uintptr(swapchainCount), uintptr(unsafe.Pointer(pCreateInfos)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(pSwapchains))))

	return
}

// CreateSwapchainKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateSwapchainKHR.html
func CreateSwapchainKHR(device Device, createInfo *SwapchainCreateInfoKHR, allocator *AllocationCallbacks) (r Result, swapchain SwapchainKHR) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkSwapchainCreateInfoKHR
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// swapchain is a binding-allocated single return value and will be populated by Vulkan
	ptr_pSwapchain := &swapchain

	r = Result(execTrampoline(keyvkCreateSwapchainKHR, uintptr(device), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pSwapchain))))

	return
}

// CreateValidationCacheEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateValidationCacheEXT.html
func CreateValidationCacheEXT(device Device, createInfo *ValidationCacheCreateInfoEXT, allocator *AllocationCallbacks) (r Result, validationCache ValidationCacheEXT) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkValidationCacheCreateInfoEXT
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// validationCache is a binding-allocated single return value and will be populated by Vulkan
	ptr_pValidationCache := &validationCache

	r = Result(execTrampoline(keyvkCreateValidationCacheEXT, uintptr(device), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pValidationCache))))

	return
}

// CreateVideoSessionKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateVideoSessionKHR.html
func CreateVideoSessionKHR(device Device, createInfo *VideoSessionCreateInfoKHR, allocator *AllocationCallbacks) (r Result, videoSession VideoSessionKHR) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkVideoSessionCreateInfoKHR
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// videoSession is a binding-allocated single return value and will be populated by Vulkan
	ptr_pVideoSession := &videoSession

	r = Result(execTrampoline(keyvkCreateVideoSessionKHR, uintptr(device), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pVideoSession))))

	return
}

// CreateVideoSessionParametersKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateVideoSessionParametersKHR.html
func CreateVideoSessionParametersKHR(device Device, createInfo *VideoSessionParametersCreateInfoKHR, allocator *AllocationCallbacks) (r Result, videoSessionParameters VideoSessionParametersKHR) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkVideoSessionParametersCreateInfoKHR
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// videoSessionParameters is a binding-allocated single return value and will be populated by Vulkan
	ptr_pVideoSessionParameters := &videoSessionParameters

	r = Result(execTrampoline(keyvkCreateVideoSessionParametersKHR, uintptr(device), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pVideoSessionParameters))))

	return
}

// DebugMarkerSetObjectNameEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDebugMarkerSetObjectNameEXT.html
func DebugMarkerSetObjectNameEXT(device Device, nameInfo *DebugMarkerObjectNameInfoEXT) (r Result) {
	// Parameter is a singular input, requires translation - nameInfo
	var pNameInfo *_vkDebugMarkerObjectNameInfoEXT
	if nameInfo != nil {
		pNameInfo = nameInfo.Vulkanize()
	}

	r = Result(execTrampoline(keyvkDebugMarkerSetObjectNameEXT, uintptr(device), uintptr(unsafe.Pointer(pNameInfo))))

	return
}

// DebugMarkerSetObjectTagEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDebugMarkerSetObjectTagEXT.html
func DebugMarkerSetObjectTagEXT(device Device, tagInfo *DebugMarkerObjectTagInfoEXT) (r Result) {
	// Parameter is a singular input, requires translation - tagInfo
	var pTagInfo *_vkDebugMarkerObjectTagInfoEXT
	if tagInfo != nil {
		pTagInfo = tagInfo.Vulkanize()
	}

	r = Result(execTrampoline(keyvkDebugMarkerSetObjectTagEXT, uintptr(device), uintptr(unsafe.Pointer(pTagInfo))))

	return
}

// DebugReportMessageEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDebugReportMessageEXT.html
func DebugReportMessageEXT(instance Instance, flags DebugReportFlagsEXT, objectType DebugReportObjectTypeEXT, object uint64, location uintptr, messageCode int32, layerPrefix string, message string) {
	// Parameter is a singular input, requires translation - layerPrefix
	var pLayerPrefix *byte
	if layerPrefix != "" {
		pLayerPrefix = sys_stringToBytePointer(layerPrefix)
	}

	// Parameter is a singular input, requires translation - message
	var pMessage *byte
	if message != "" {
		pMessage = sys_stringToBytePointer(message)
	}

	execTrampoline(keyvkDebugReportMessageEXT, uintptr(instance), uintptr(flags), uintptr(objectType), uintptr(object), uintptr(location), uintptr(messageCode), uintptr(unsafe.Pointer(pLayerPrefix)), uintptr(unsafe.Pointer(pMessage)))

}

// DeferredOperationJoinKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDeferredOperationJoinKHR.html
func DeferredOperationJoinKHR(device Device, operation DeferredOperationKHR) (r Result) {

	r = Result(execTrampoline(keyvkDeferredOperationJoinKHR, uintptr(device), uintptr(operation)))

	return
}

// DestroyAccelerationStructureKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyAccelerationStructureKHR.html
func DestroyAccelerationStructureKHR(device Device, accelerationStructure AccelerationStructureKHR, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	execTrampoline(keyvkDestroyAccelerationStructureKHR, uintptr(device), uintptr(accelerationStructure), uintptr(unsafe.Pointer(pAllocator)))

}

// DestroyAccelerationStructureNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyAccelerationStructureNV.html
func DestroyAccelerationStructureNV(device Device, accelerationStructure AccelerationStructureNV, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	execTrampoline(keyvkDestroyAccelerationStructureNV, uintptr(device), uintptr(accelerationStructure), uintptr(unsafe.Pointer(pAllocator)))

}

// DestroyBuffer: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyBuffer.html
func DestroyBuffer(device Device, buffer Buffer, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	execTrampoline(keyvkDestroyBuffer, uintptr(device), uintptr(buffer), uintptr(unsafe.Pointer(pAllocator)))

}

// DestroyBufferView: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyBufferView.html
func DestroyBufferView(device Device, bufferView BufferView, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	execTrampoline(keyvkDestroyBufferView, uintptr(device), uintptr(bufferView), uintptr(unsafe.Pointer(pAllocator)))

}

// DestroyCommandPool: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyCommandPool.html
func DestroyCommandPool(device Device, commandPool CommandPool, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	execTrampoline(keyvkDestroyCommandPool, uintptr(device), uintptr(commandPool), uintptr(unsafe.Pointer(pAllocator)))

}

// DestroyCuFunctionNVX: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyCuFunctionNVX.html
func DestroyCuFunctionNVX(device Device, function CuFunctionNVX, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	execTrampoline(keyvkDestroyCuFunctionNVX, uintptr(device), uintptr(function), uintptr(unsafe.Pointer(pAllocator)))

}

// DestroyCuModuleNVX: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyCuModuleNVX.html
func DestroyCuModuleNVX(device Device, module CuModuleNVX, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	execTrampoline(keyvkDestroyCuModuleNVX, uintptr(device), uintptr(module), uintptr(unsafe.Pointer(pAllocator)))

}

// DestroyDebugReportCallbackEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyDebugReportCallbackEXT.html
func DestroyDebugReportCallbackEXT(instance Instance, callback DebugReportCallbackEXT, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	execTrampoline(keyvkDestroyDebugReportCallbackEXT, uintptr(instance), uintptr(callback), uintptr(unsafe.Pointer(pAllocator)))

}

// DestroyDebugUtilsMessengerEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyDebugUtilsMessengerEXT.html
func DestroyDebugUtilsMessengerEXT(instance Instance, messenger DebugUtilsMessengerEXT, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	execTrampoline(keyvkDestroyDebugUtilsMessengerEXT, uintptr(instance), uintptr(messenger), uintptr(unsafe.Pointer(pAllocator)))

}

// DestroyDeferredOperationKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyDeferredOperationKHR.html
func DestroyDeferredOperationKHR(device Device, operation DeferredOperationKHR, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	execTrampoline(keyvkDestroyDeferredOperationKHR, uintptr(device), uintptr(operation), uintptr(unsafe.Pointer(pAllocator)))

}

// DestroyDescriptorPool: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyDescriptorPool.html
func DestroyDescriptorPool(device Device, descriptorPool DescriptorPool, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	execTrampoline(keyvkDestroyDescriptorPool, uintptr(device), uintptr(descriptorPool), uintptr(unsafe.Pointer(pAllocator)))

}

// DestroyDescriptorSetLayout: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyDescriptorSetLayout.html
func DestroyDescriptorSetLayout(device Device, descriptorSetLayout DescriptorSetLayout, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	execTrampoline(keyvkDestroyDescriptorSetLayout, uintptr(device), uintptr(descriptorSetLayout), uintptr(unsafe.Pointer(pAllocator)))

}

// DestroyDescriptorUpdateTemplate: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyDescriptorUpdateTemplate.html
func DestroyDescriptorUpdateTemplate(device Device, descriptorUpdateTemplate DescriptorUpdateTemplate, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	execTrampoline(keyvkDestroyDescriptorUpdateTemplate, uintptr(device), uintptr(descriptorUpdateTemplate), uintptr(unsafe.Pointer(pAllocator)))

}

var DestroyDescriptorUpdateTemplateKHR = DestroyDescriptorUpdateTemplate

// DestroyDevice: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyDevice.html
func DestroyDevice(device Device, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	execTrampoline(keyvkDestroyDevice, uintptr(device), uintptr(unsafe.Pointer(pAllocator)))

}

// DestroyEvent: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyEvent.html
func DestroyEvent(device Device, event Event, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	execTrampoline(keyvkDestroyEvent, uintptr(device), uintptr(event), uintptr(unsafe.Pointer(pAllocator)))

}

// DestroyFence: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyFence.html
func DestroyFence(device Device, fence Fence, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	execTrampoline(keyvkDestroyFence, uintptr(device), uintptr(fence), uintptr(unsafe.Pointer(pAllocator)))

}

// DestroyFramebuffer: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyFramebuffer.html
func DestroyFramebuffer(device Device, framebuffer Framebuffer, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	execTrampoline(keyvkDestroyFramebuffer, uintptr(device), uintptr(framebuffer), uintptr(unsafe.Pointer(pAllocator)))

}

// DestroyImage: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyImage.html
func DestroyImage(device Device, image Image, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	execTrampoline(keyvkDestroyImage, uintptr(device), uintptr(image), uintptr(unsafe.Pointer(pAllocator)))

}

// DestroyImageView: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyImageView.html
func DestroyImageView(device Device, imageView ImageView, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	execTrampoline(keyvkDestroyImageView, uintptr(device), uintptr(imageView), uintptr(unsafe.Pointer(pAllocator)))

}

// DestroyIndirectCommandsLayoutNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyIndirectCommandsLayoutNV.html
func DestroyIndirectCommandsLayoutNV(device Device, indirectCommandsLayout IndirectCommandsLayoutNV, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	execTrampoline(keyvkDestroyIndirectCommandsLayoutNV, uintptr(device), uintptr(indirectCommandsLayout), uintptr(unsafe.Pointer(pAllocator)))

}

// DestroyInstance: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyInstance.html
func DestroyInstance(instance Instance, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	execTrampoline(keyvkDestroyInstance, uintptr(instance), uintptr(unsafe.Pointer(pAllocator)))

}

// DestroyMicromapEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyMicromapEXT.html
func DestroyMicromapEXT(device Device, micromap MicromapEXT, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	execTrampoline(keyvkDestroyMicromapEXT, uintptr(device), uintptr(micromap), uintptr(unsafe.Pointer(pAllocator)))

}

// DestroyOpticalFlowSessionNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyOpticalFlowSessionNV.html
func DestroyOpticalFlowSessionNV(device Device, session OpticalFlowSessionNV, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	execTrampoline(keyvkDestroyOpticalFlowSessionNV, uintptr(device), uintptr(session), uintptr(unsafe.Pointer(pAllocator)))

}

// DestroyPipeline: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyPipeline.html
func DestroyPipeline(device Device, pipeline Pipeline, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	execTrampoline(keyvkDestroyPipeline, uintptr(device), uintptr(pipeline), uintptr(unsafe.Pointer(pAllocator)))

}

// DestroyPipelineCache: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyPipelineCache.html
func DestroyPipelineCache(device Device, pipelineCache PipelineCache, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	execTrampoline(keyvkDestroyPipelineCache, uintptr(device), uintptr(pipelineCache), uintptr(unsafe.Pointer(pAllocator)))

}

// DestroyPipelineLayout: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyPipelineLayout.html
func DestroyPipelineLayout(device Device, pipelineLayout PipelineLayout, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	execTrampoline(keyvkDestroyPipelineLayout, uintptr(device), uintptr(pipelineLayout), uintptr(unsafe.Pointer(pAllocator)))

}

// DestroyPrivateDataSlot: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyPrivateDataSlot.html
func DestroyPrivateDataSlot(device Device, privateDataSlot PrivateDataSlot, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	execTrampoline(keyvkDestroyPrivateDataSlot, uintptr(device), uintptr(privateDataSlot), uintptr(unsafe.Pointer(pAllocator)))

}

var DestroyPrivateDataSlotEXT = DestroyPrivateDataSlot

// DestroyQueryPool: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyQueryPool.html
func DestroyQueryPool(device Device, queryPool QueryPool, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	execTrampoline(keyvkDestroyQueryPool, uintptr(device), uintptr(queryPool), uintptr(unsafe.Pointer(pAllocator)))

}

// DestroyRenderPass: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyRenderPass.html
func DestroyRenderPass(device Device, renderPass RenderPass, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	execTrampoline(keyvkDestroyRenderPass, uintptr(device), uintptr(renderPass), uintptr(unsafe.Pointer(pAllocator)))

}

// DestroySampler: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroySampler.html
func DestroySampler(device Device, sampler Sampler, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	execTrampoline(keyvkDestroySampler, uintptr(device), uintptr(sampler), uintptr(unsafe.Pointer(pAllocator)))

}

// DestroySamplerYcbcrConversion: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroySamplerYcbcrConversion.html
func DestroySamplerYcbcrConversion(device Device, ycbcrConversion SamplerYcbcrConversion, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	execTrampoline(keyvkDestroySamplerYcbcrConversion, uintptr(device), uintptr(ycbcrConversion), uintptr(unsafe.Pointer(pAllocator)))

}

var DestroySamplerYcbcrConversionKHR = DestroySamplerYcbcrConversion

// DestroySemaphore: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroySemaphore.html
func DestroySemaphore(device Device, semaphore Semaphore, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	execTrampoline(keyvkDestroySemaphore, uintptr(device), uintptr(semaphore), uintptr(unsafe.Pointer(pAllocator)))

}

// DestroyShaderModule: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyShaderModule.html
func DestroyShaderModule(device Device, shaderModule ShaderModule, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	execTrampoline(keyvkDestroyShaderModule, uintptr(device), uintptr(shaderModule), uintptr(unsafe.Pointer(pAllocator)))

}

// DestroySurfaceKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroySurfaceKHR.html
func DestroySurfaceKHR(instance Instance, surface SurfaceKHR, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	execTrampoline(keyvkDestroySurfaceKHR, uintptr(instance), uintptr(surface), uintptr(unsafe.Pointer(pAllocator)))

}

// DestroySwapchainKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroySwapchainKHR.html
func DestroySwapchainKHR(device Device, swapchain SwapchainKHR, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	execTrampoline(keyvkDestroySwapchainKHR, uintptr(device), uintptr(swapchain), uintptr(unsafe.Pointer(pAllocator)))

}

// DestroyValidationCacheEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyValidationCacheEXT.html
func DestroyValidationCacheEXT(device Device, validationCache ValidationCacheEXT, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	execTrampoline(keyvkDestroyValidationCacheEXT, uintptr(device), uintptr(validationCache), uintptr(unsafe.Pointer(pAllocator)))

}

// DestroyVideoSessionKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyVideoSessionKHR.html
func DestroyVideoSessionKHR(device Device, videoSession VideoSessionKHR, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	execTrampoline(keyvkDestroyVideoSessionKHR, uintptr(device), uintptr(videoSession), uintptr(unsafe.Pointer(pAllocator)))

}

// DestroyVideoSessionParametersKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyVideoSessionParametersKHR.html
func DestroyVideoSessionParametersKHR(device Device, videoSessionParameters VideoSessionParametersKHR, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	execTrampoline(keyvkDestroyVideoSessionParametersKHR, uintptr(device), uintptr(videoSessionParameters), uintptr(unsafe.Pointer(pAllocator)))

}

// DeviceWaitIdle: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDeviceWaitIdle.html
func DeviceWaitIdle(device Device) (r Result) {

	r = Result(execTrampoline(keyvkDeviceWaitIdle, uintptr(device)))

	return
}

// DisplayPowerControlEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDisplayPowerControlEXT.html
func DisplayPowerControlEXT(device Device, display DisplayKHR, displayPowerInfo *DisplayPowerInfoEXT) (r Result) {
	// Parameter is a singular input, requires translation - displayPowerInfo
	var pDisplayPowerInfo *_vkDisplayPowerInfoEXT
	if displayPowerInfo != nil {
		pDisplayPowerInfo = displayPowerInfo.Vulkanize()
	}

	r = Result(execTrampoline(keyvkDisplayPowerControlEXT, uintptr(device), uintptr(display), uintptr(unsafe.Pointer(pDisplayPowerInfo))))

	return
}

// EndCommandBuffer: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkEndCommandBuffer.html
func EndCommandBuffer(commandBuffer CommandBuffer) (r Result) {

	r = Result(execTrampoline(keyvkEndCommandBuffer, uintptr(commandBuffer)))

	return
}

// EnumerateDeviceExtensionProperties: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkEnumerateDeviceExtensionProperties.html
func EnumerateDeviceExtensionProperties(physicalDevice PhysicalDevice, layerName string) (r Result, properties []ExtensionProperties) {
	// Parameter is a singular input, requires translation - layerName
	var pLayerName *byte
	if layerName != "" {
		pLayerName = sys_stringToBytePointer(layerName)
	}

	// properties is a double-call array output
	var propertyCount uint32
	pPropertyCount := &propertyCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pProperties *_vkExtensionProperties

	r = Result(execTrampoline(keyvkEnumerateDeviceExtensionProperties, uintptr(physicalDevice), uintptr(unsafe.Pointer(pLayerName)), uintptr(unsafe.Pointer(pPropertyCount)), uintptr(unsafe.Pointer(pProperties))))

	sl_pProperties := make([]_vkExtensionProperties, propertyCount)
	properties = make([]ExtensionProperties, propertyCount)
	pProperties = &sl_pProperties[0]

	// Trampoline call after last array allocation
	r = Result(execTrampoline(keyvkEnumerateDeviceExtensionProperties, uintptr(physicalDevice), uintptr(unsafe.Pointer(pLayerName)), uintptr(unsafe.Pointer(pPropertyCount)), uintptr(unsafe.Pointer(pProperties))))

	for i := range sl_pProperties {
		properties[i] = *sl_pProperties[i].Goify()
	}
	return
}

// EnumerateDeviceLayerProperties: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkEnumerateDeviceLayerProperties.html
func EnumerateDeviceLayerProperties(physicalDevice PhysicalDevice) (r Result, properties []LayerProperties) {
	// properties is a double-call array output
	var propertyCount uint32
	pPropertyCount := &propertyCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pProperties *_vkLayerProperties

	r = Result(execTrampoline(keyvkEnumerateDeviceLayerProperties, uintptr(physicalDevice), uintptr(unsafe.Pointer(pPropertyCount)), uintptr(unsafe.Pointer(pProperties))))

	sl_pProperties := make([]_vkLayerProperties, propertyCount)
	properties = make([]LayerProperties, propertyCount)
	pProperties = &sl_pProperties[0]

	// Trampoline call after last array allocation
	r = Result(execTrampoline(keyvkEnumerateDeviceLayerProperties, uintptr(physicalDevice), uintptr(unsafe.Pointer(pPropertyCount)), uintptr(unsafe.Pointer(pProperties))))

	for i := range sl_pProperties {
		properties[i] = *sl_pProperties[i].Goify()
	}
	return
}

// EnumerateInstanceExtensionProperties: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkEnumerateInstanceExtensionProperties.html
func EnumerateInstanceExtensionProperties(layerName string) (r Result, properties []ExtensionProperties) {
	// Parameter is a singular input, requires translation - layerName
	var pLayerName *byte
	if layerName != "" {
		pLayerName = sys_stringToBytePointer(layerName)
	}

	// properties is a double-call array output
	var propertyCount uint32
	pPropertyCount := &propertyCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pProperties *_vkExtensionProperties

	r = Result(execTrampoline(keyvkEnumerateInstanceExtensionProperties, uintptr(unsafe.Pointer(pLayerName)), uintptr(unsafe.Pointer(pPropertyCount)), uintptr(unsafe.Pointer(pProperties))))

	sl_pProperties := make([]_vkExtensionProperties, propertyCount)
	properties = make([]ExtensionProperties, propertyCount)
	pProperties = &sl_pProperties[0]

	// Trampoline call after last array allocation
	r = Result(execTrampoline(keyvkEnumerateInstanceExtensionProperties, uintptr(unsafe.Pointer(pLayerName)), uintptr(unsafe.Pointer(pPropertyCount)), uintptr(unsafe.Pointer(pProperties))))

	for i := range sl_pProperties {
		properties[i] = *sl_pProperties[i].Goify()
	}
	return
}

// EnumerateInstanceLayerProperties: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkEnumerateInstanceLayerProperties.html
func EnumerateInstanceLayerProperties() (r Result, properties []LayerProperties) {
	// properties is a double-call array output
	var propertyCount uint32
	pPropertyCount := &propertyCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pProperties *_vkLayerProperties

	r = Result(execTrampoline(keyvkEnumerateInstanceLayerProperties, uintptr(unsafe.Pointer(pPropertyCount)), uintptr(unsafe.Pointer(pProperties))))

	sl_pProperties := make([]_vkLayerProperties, propertyCount)
	properties = make([]LayerProperties, propertyCount)
	pProperties = &sl_pProperties[0]

	// Trampoline call after last array allocation
	r = Result(execTrampoline(keyvkEnumerateInstanceLayerProperties, uintptr(unsafe.Pointer(pPropertyCount)), uintptr(unsafe.Pointer(pProperties))))

	for i := range sl_pProperties {
		properties[i] = *sl_pProperties[i].Goify()
	}
	return
}

// EnumerateInstanceVersion: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkEnumerateInstanceVersion.html
func EnumerateInstanceVersion() (r Result, apiVersion uint32) {
	// apiVersion is a binding-allocated single return value and will be populated by Vulkan
	ptr_pApiVersion := &apiVersion

	r = Result(execTrampoline(keyvkEnumerateInstanceVersion, uintptr(unsafe.Pointer(ptr_pApiVersion))))

	return
}

// EnumeratePhysicalDeviceGroups: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkEnumeratePhysicalDeviceGroups.html
func EnumeratePhysicalDeviceGroups(instance Instance) (r Result, physicalDeviceGroupProperties []PhysicalDeviceGroupProperties) {
	// physicalDeviceGroupProperties is a double-call array output
	var physicalDeviceGroupCount uint32
	pPhysicalDeviceGroupCount := &physicalDeviceGroupCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pPhysicalDeviceGroupProperties *_vkPhysicalDeviceGroupProperties

	r = Result(execTrampoline(keyvkEnumeratePhysicalDeviceGroups, uintptr(instance), uintptr(unsafe.Pointer(pPhysicalDeviceGroupCount)), uintptr(unsafe.Pointer(pPhysicalDeviceGroupProperties))))

	sl_pPhysicalDeviceGroupProperties := make([]_vkPhysicalDeviceGroupProperties, physicalDeviceGroupCount)
	physicalDeviceGroupProperties = make([]PhysicalDeviceGroupProperties, physicalDeviceGroupCount)
	pPhysicalDeviceGroupProperties = &sl_pPhysicalDeviceGroupProperties[0]

	// Trampoline call after last array allocation
	r = Result(execTrampoline(keyvkEnumeratePhysicalDeviceGroups, uintptr(instance), uintptr(unsafe.Pointer(pPhysicalDeviceGroupCount)), uintptr(unsafe.Pointer(pPhysicalDeviceGroupProperties))))

	for i := range sl_pPhysicalDeviceGroupProperties {
		physicalDeviceGroupProperties[i] = *sl_pPhysicalDeviceGroupProperties[i].Goify()
	}
	return
}

var EnumeratePhysicalDeviceGroupsKHR = EnumeratePhysicalDeviceGroups

// EnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR.html
func EnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR(physicalDevice PhysicalDevice, queueFamilyIndex uint32) (r Result, counters []PerformanceCounterKHR, counterDescriptions []PerformanceCounterDescriptionKHR) {
	// counters is a double-call array output
	var counterCount uint32
	pCounterCount := &counterCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pCounters *_vkPerformanceCounterKHR
	// NOT identical internal and external, result needs translation
	var pCounterDescriptions *_vkPerformanceCounterDescriptionKHR

	r = Result(execTrampoline(keyvkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR, uintptr(physicalDevice), uintptr(queueFamilyIndex), uintptr(unsafe.Pointer(pCounterCount)), uintptr(unsafe.Pointer(pCounters)), uintptr(unsafe.Pointer(pCounterDescriptions))))

	sl_pCounters := make([]_vkPerformanceCounterKHR, counterCount)
	counters = make([]PerformanceCounterKHR, counterCount)
	pCounters = &sl_pCounters[0]

	sl_pCounterDescriptions := make([]_vkPerformanceCounterDescriptionKHR, counterCount)
	counterDescriptions = make([]PerformanceCounterDescriptionKHR, counterCount)
	pCounterDescriptions = &sl_pCounterDescriptions[0]

	// Trampoline call after last array allocation
	r = Result(execTrampoline(keyvkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR, uintptr(physicalDevice), uintptr(queueFamilyIndex), uintptr(unsafe.Pointer(pCounterCount)), uintptr(unsafe.Pointer(pCounters)), uintptr(unsafe.Pointer(pCounterDescriptions))))

	for i := range sl_pCounters {
		counters[i] = *sl_pCounters[i].Goify()
	}
	for i := range sl_pCounterDescriptions {
		counterDescriptions[i] = *sl_pCounterDescriptions[i].Goify()
	}
	return
}

// EnumeratePhysicalDevices: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkEnumeratePhysicalDevices.html
func EnumeratePhysicalDevices(instance Instance) (r Result, physicalDevices []PhysicalDevice) {
	// physicalDevices is a double-call array output
	var physicalDeviceCount uint32
	pPhysicalDeviceCount := &physicalDeviceCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pPhysicalDevices *PhysicalDevice

	r = Result(execTrampoline(keyvkEnumeratePhysicalDevices, uintptr(instance), uintptr(unsafe.Pointer(pPhysicalDeviceCount)), uintptr(unsafe.Pointer(pPhysicalDevices))))

	sl_pPhysicalDevices := make([]PhysicalDevice, physicalDeviceCount)
	physicalDevices = make([]PhysicalDevice, physicalDeviceCount)
	pPhysicalDevices = &sl_pPhysicalDevices[0]

	// Trampoline call after last array allocation
	r = Result(execTrampoline(keyvkEnumeratePhysicalDevices, uintptr(instance), uintptr(unsafe.Pointer(pPhysicalDeviceCount)), uintptr(unsafe.Pointer(pPhysicalDevices))))

	for i := range sl_pPhysicalDevices {
		physicalDevices[i] = *&sl_pPhysicalDevices[i]
	}
	return
}

// FlushMappedMemoryRanges: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkFlushMappedMemoryRanges.html
func FlushMappedMemoryRanges(device Device, memoryRanges []MappedMemoryRange) (r Result) {
	memoryRangeCount := len(memoryRanges)
	// memoryRanges is an input slice that requires translation to an internal type
	var pMemoryRanges unsafe.Pointer
	if len(memoryRanges) > 0 {
		sl_memoryRanges := make([]_vkMappedMemoryRange, memoryRangeCount)
		for i, v := range memoryRanges {
			sl_memoryRanges[i] = *(v.Vulkanize())
		}
		pMemoryRanges = unsafe.Pointer(&sl_memoryRanges[0])
	}

	r = Result(execTrampoline(keyvkFlushMappedMemoryRanges, uintptr(device), uintptr(memoryRangeCount), uintptr(unsafe.Pointer(pMemoryRanges))))

	return
}

// FreeCommandBuffers: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkFreeCommandBuffers.html
func FreeCommandBuffers(device Device, commandPool CommandPool, commandBuffers []CommandBuffer) {
	commandBufferCount := len(commandBuffers)
	// commandBuffers is an input slice of values that do not need translation used
	var pCommandBuffers unsafe.Pointer
	if commandBuffers != nil {
		pCommandBuffers = unsafe.Pointer(&commandBuffers[0])
	}

	execTrampoline(keyvkFreeCommandBuffers, uintptr(device), uintptr(commandPool), uintptr(commandBufferCount), uintptr(unsafe.Pointer(pCommandBuffers)))

}

// FreeDescriptorSets: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkFreeDescriptorSets.html
func FreeDescriptorSets(device Device, descriptorPool DescriptorPool, descriptorSets []DescriptorSet) (r Result) {
	descriptorSetCount := len(descriptorSets)
	// descriptorSets is an input slice of values that do not need translation used
	var pDescriptorSets unsafe.Pointer
	if descriptorSets != nil {
		pDescriptorSets = unsafe.Pointer(&descriptorSets[0])
	}

	r = Result(execTrampoline(keyvkFreeDescriptorSets, uintptr(device), uintptr(descriptorPool), uintptr(descriptorSetCount), uintptr(unsafe.Pointer(pDescriptorSets))))

	return
}

// FreeMemory: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkFreeMemory.html
func FreeMemory(device Device, memory DeviceMemory, allocator *AllocationCallbacks) {
	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	execTrampoline(keyvkFreeMemory, uintptr(device), uintptr(memory), uintptr(unsafe.Pointer(pAllocator)))

}

// GetAccelerationStructureBuildSizesKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetAccelerationStructureBuildSizesKHR.html
func GetAccelerationStructureBuildSizesKHR(device Device, buildType AccelerationStructureBuildTypeKHR, buildInfo *AccelerationStructureBuildGeometryInfoKHR, maxPrimitiveCounts []uint32) (sizeInfo AccelerationStructureBuildSizesInfoKHR) {
	// Parameter is a singular input, requires translation - buildInfo
	var pBuildInfo *_vkAccelerationStructureBuildGeometryInfoKHR
	if buildInfo != nil {
		pBuildInfo = buildInfo.Vulkanize()
	}

	// maxPrimitiveCounts is an input slice that requires translation to an internal type; length is embedded in pBuildInfo
	pMaxPrimitiveCounts := unsafe.Pointer(nil)
	// WARNING TODO - passing nil pointer to get to a version that will compile. THIS VULKAN CALL WILL FAIL!// sizeInfo is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pSizeInfo *_vkAccelerationStructureBuildSizesInfoKHR = sizeInfo.Vulkanize()

	execTrampoline(keyvkGetAccelerationStructureBuildSizesKHR, uintptr(device), uintptr(buildType), uintptr(unsafe.Pointer(pBuildInfo)), uintptr(unsafe.Pointer(pMaxPrimitiveCounts)), uintptr(unsafe.Pointer(pSizeInfo)))

	sizeInfo = *(pSizeInfo.Goify())
	return
}

// GetAccelerationStructureDeviceAddressKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetAccelerationStructureDeviceAddressKHR.html
func GetAccelerationStructureDeviceAddressKHR(device Device, info *AccelerationStructureDeviceAddressInfoKHR) (deviceAddress DeviceAddress) {
	// Parameter is a singular input, requires translation - info
	var pInfo *_vkAccelerationStructureDeviceAddressInfoKHR
	if info != nil {
		pInfo = info.Vulkanize()
	}

	deviceAddress = DeviceAddress(execTrampoline(keyvkGetAccelerationStructureDeviceAddressKHR, uintptr(device), uintptr(unsafe.Pointer(pInfo))))

	return
}

// GetAccelerationStructureHandleNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetAccelerationStructureHandleNV.html
func GetAccelerationStructureHandleNV(device Device, accelerationStructure AccelerationStructureNV, data []byte) (r Result) {
	dataSize := len(data)
	// data is a user-allocated array input that will be written to
	pData := unsafe.Pointer(&data[0])

	r = Result(execTrampoline(keyvkGetAccelerationStructureHandleNV, uintptr(device), uintptr(accelerationStructure), uintptr(dataSize), uintptr(unsafe.Pointer(pData))))

	return
}

// GetAccelerationStructureMemoryRequirementsNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetAccelerationStructureMemoryRequirementsNV.html
func GetAccelerationStructureMemoryRequirementsNV(device Device, info *AccelerationStructureMemoryRequirementsInfoNV) (memoryRequirements MemoryRequirements2KHR) {
	// Parameter is a singular input, requires translation - info
	var pInfo *_vkAccelerationStructureMemoryRequirementsInfoNV
	if info != nil {
		pInfo = info.Vulkanize()
	}

	// memoryRequirements is a binding-allocated single return value and will be populated by Vulkan
	ptr_pMemoryRequirements := &memoryRequirements

	execTrampoline(keyvkGetAccelerationStructureMemoryRequirementsNV, uintptr(device), uintptr(unsafe.Pointer(pInfo)), uintptr(unsafe.Pointer(ptr_pMemoryRequirements)))

	return
}

// GetAccelerationStructureOpaqueCaptureDescriptorDataEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT.html
func GetAccelerationStructureOpaqueCaptureDescriptorDataEXT(device Device, info *AccelerationStructureCaptureDescriptorDataInfoEXT) (r Result, data byte) {
	// Parameter is a singular input, requires translation - info
	var pInfo *_vkAccelerationStructureCaptureDescriptorDataInfoEXT
	if info != nil {
		pInfo = info.Vulkanize()
	}

	// data is a binding-allocated single return value and will be populated by Vulkan
	ptr_pData := &data

	r = Result(execTrampoline(keyvkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT, uintptr(device), uintptr(unsafe.Pointer(pInfo)), uintptr(unsafe.Pointer(ptr_pData))))

	return
}

// GetBufferDeviceAddress: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetBufferDeviceAddress.html
func GetBufferDeviceAddress(device Device, info *BufferDeviceAddressInfo) (deviceAddress DeviceAddress) {
	// Parameter is a singular input, requires translation - info
	var pInfo *_vkBufferDeviceAddressInfo
	if info != nil {
		pInfo = info.Vulkanize()
	}

	deviceAddress = DeviceAddress(execTrampoline(keyvkGetBufferDeviceAddress, uintptr(device), uintptr(unsafe.Pointer(pInfo))))

	return
}

var GetBufferDeviceAddressEXT = GetBufferDeviceAddress

var GetBufferDeviceAddressKHR = GetBufferDeviceAddress

// GetBufferMemoryRequirements: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetBufferMemoryRequirements.html
func GetBufferMemoryRequirements(device Device, buffer Buffer) (memoryRequirements MemoryRequirements) {
	// memoryRequirements is a binding-allocated single return value and will be populated by Vulkan
	ptr_pMemoryRequirements := &memoryRequirements

	execTrampoline(keyvkGetBufferMemoryRequirements, uintptr(device), uintptr(buffer), uintptr(unsafe.Pointer(ptr_pMemoryRequirements)))

	return
}

// GetBufferMemoryRequirements2: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetBufferMemoryRequirements2.html
func GetBufferMemoryRequirements2(device Device, info *BufferMemoryRequirementsInfo2) (memoryRequirements MemoryRequirements2) {
	// Parameter is a singular input, requires translation - info
	var pInfo *_vkBufferMemoryRequirementsInfo2
	if info != nil {
		pInfo = info.Vulkanize()
	}

	// memoryRequirements is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pMemoryRequirements *_vkMemoryRequirements2 = memoryRequirements.Vulkanize()

	execTrampoline(keyvkGetBufferMemoryRequirements2, uintptr(device), uintptr(unsafe.Pointer(pInfo)), uintptr(unsafe.Pointer(pMemoryRequirements)))

	memoryRequirements = *(pMemoryRequirements.Goify())
	return
}

var GetBufferMemoryRequirements2KHR = GetBufferMemoryRequirements2

// GetBufferOpaqueCaptureAddress: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetBufferOpaqueCaptureAddress.html
func GetBufferOpaqueCaptureAddress(device Device, info *BufferDeviceAddressInfo) (r uint64) {
	// Parameter is a singular input, requires translation - info
	var pInfo *_vkBufferDeviceAddressInfo
	if info != nil {
		pInfo = info.Vulkanize()
	}

	r = uint64(execTrampoline(keyvkGetBufferOpaqueCaptureAddress, uintptr(device), uintptr(unsafe.Pointer(pInfo))))

	return
}

var GetBufferOpaqueCaptureAddressKHR = GetBufferOpaqueCaptureAddress

// GetBufferOpaqueCaptureDescriptorDataEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetBufferOpaqueCaptureDescriptorDataEXT.html
func GetBufferOpaqueCaptureDescriptorDataEXT(device Device, info *BufferCaptureDescriptorDataInfoEXT) (r Result, data byte) {
	// Parameter is a singular input, requires translation - info
	var pInfo *_vkBufferCaptureDescriptorDataInfoEXT
	if info != nil {
		pInfo = info.Vulkanize()
	}

	// data is a binding-allocated single return value and will be populated by Vulkan
	ptr_pData := &data

	r = Result(execTrampoline(keyvkGetBufferOpaqueCaptureDescriptorDataEXT, uintptr(device), uintptr(unsafe.Pointer(pInfo)), uintptr(unsafe.Pointer(ptr_pData))))

	return
}

// GetCalibratedTimestampsEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetCalibratedTimestampsEXT.html
func GetCalibratedTimestampsEXT(device Device, timestampInfos []CalibratedTimestampInfoEXT) (r Result, timestamps []uint64, maxDeviation uint64) {
	timestampCount := len(timestampInfos)
	// timestampInfos is an input slice that requires translation to an internal type
	var pTimestampInfos unsafe.Pointer
	if len(timestampInfos) > 0 {
		sl_timestampInfos := make([]_vkCalibratedTimestampInfoEXT, timestampCount)
		for i, v := range timestampInfos {
			sl_timestampInfos[i] = *(v.Vulkanize())
		}
		pTimestampInfos = unsafe.Pointer(&sl_timestampInfos[0])
	}

	// timestamps is an output array that will be allocated by the binding, len is from timestampCount
	timestamps = make([]uint64, timestampCount)
	pTimestamps := unsafe.Pointer(&timestamps[0])

	// maxDeviation is a binding-allocated single return value and will be populated by Vulkan
	ptr_pMaxDeviation := &maxDeviation

	r = Result(execTrampoline(keyvkGetCalibratedTimestampsEXT, uintptr(device), uintptr(timestampCount), uintptr(unsafe.Pointer(pTimestampInfos)), uintptr(unsafe.Pointer(pTimestamps)), uintptr(unsafe.Pointer(ptr_pMaxDeviation))))

	return
}

// GetDeferredOperationMaxConcurrencyKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeferredOperationMaxConcurrencyKHR.html
func GetDeferredOperationMaxConcurrencyKHR(device Device, operation DeferredOperationKHR) (r uint32) {

	r = uint32(execTrampoline(keyvkGetDeferredOperationMaxConcurrencyKHR, uintptr(device), uintptr(operation)))

	return
}

// GetDeferredOperationResultKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeferredOperationResultKHR.html
func GetDeferredOperationResultKHR(device Device, operation DeferredOperationKHR) (r Result) {

	r = Result(execTrampoline(keyvkGetDeferredOperationResultKHR, uintptr(device), uintptr(operation)))

	return
}

// GetDescriptorEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDescriptorEXT.html
func GetDescriptorEXT(device Device, descriptorInfo *DescriptorGetInfoEXT, descriptor []byte) {
	// Parameter is a singular input, requires translation - descriptorInfo
	var pDescriptorInfo *_vkDescriptorGetInfoEXT
	if descriptorInfo != nil {
		pDescriptorInfo = descriptorInfo.Vulkanize()
	}

	dataSize := len(descriptor)
	// descriptor is a user-allocated array input that will be written to
	pDescriptor := unsafe.Pointer(&descriptor[0])

	execTrampoline(keyvkGetDescriptorEXT, uintptr(device), uintptr(unsafe.Pointer(pDescriptorInfo)), uintptr(dataSize), uintptr(unsafe.Pointer(pDescriptor)))

}

// GetDescriptorSetHostMappingVALVE: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDescriptorSetHostMappingVALVE.html
func GetDescriptorSetHostMappingVALVE(device Device, descriptorSet DescriptorSet) (pData *byte) {
	// pData is a binding-allocated single return value and will be populated by Vulkan
	ptr_ppData := &pData

	execTrampoline(keyvkGetDescriptorSetHostMappingVALVE, uintptr(device), uintptr(descriptorSet), uintptr(unsafe.Pointer(ptr_ppData)))

	return
}

// GetDescriptorSetLayoutBindingOffsetEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDescriptorSetLayoutBindingOffsetEXT.html
func GetDescriptorSetLayoutBindingOffsetEXT(device Device, layout DescriptorSetLayout, binding uint32) (offset DeviceSize) {
	// offset is a binding-allocated single return value and will be populated by Vulkan
	ptr_pOffset := &offset

	execTrampoline(keyvkGetDescriptorSetLayoutBindingOffsetEXT, uintptr(device), uintptr(layout), uintptr(binding), uintptr(unsafe.Pointer(ptr_pOffset)))

	return
}

// GetDescriptorSetLayoutHostMappingInfoVALVE: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDescriptorSetLayoutHostMappingInfoVALVE.html
func GetDescriptorSetLayoutHostMappingInfoVALVE(device Device, bindingReference *DescriptorSetBindingReferenceVALVE) (hostMapping DescriptorSetLayoutHostMappingInfoVALVE) {
	// Parameter is a singular input, requires translation - bindingReference
	var pBindingReference *_vkDescriptorSetBindingReferenceVALVE
	if bindingReference != nil {
		pBindingReference = bindingReference.Vulkanize()
	}

	// hostMapping is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pHostMapping *_vkDescriptorSetLayoutHostMappingInfoVALVE = hostMapping.Vulkanize()

	execTrampoline(keyvkGetDescriptorSetLayoutHostMappingInfoVALVE, uintptr(device), uintptr(unsafe.Pointer(pBindingReference)), uintptr(unsafe.Pointer(pHostMapping)))

	hostMapping = *(pHostMapping.Goify())
	return
}

// GetDescriptorSetLayoutSizeEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDescriptorSetLayoutSizeEXT.html
func GetDescriptorSetLayoutSizeEXT(device Device, layout DescriptorSetLayout) (layoutSizeInBytes DeviceSize) {
	// layoutSizeInBytes is a binding-allocated single return value and will be populated by Vulkan
	ptr_pLayoutSizeInBytes := &layoutSizeInBytes

	execTrampoline(keyvkGetDescriptorSetLayoutSizeEXT, uintptr(device), uintptr(layout), uintptr(unsafe.Pointer(ptr_pLayoutSizeInBytes)))

	return
}

// GetDescriptorSetLayoutSupport: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDescriptorSetLayoutSupport.html
func GetDescriptorSetLayoutSupport(device Device, createInfo *DescriptorSetLayoutCreateInfo) (support DescriptorSetLayoutSupport) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkDescriptorSetLayoutCreateInfo
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// support is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pSupport *_vkDescriptorSetLayoutSupport = support.Vulkanize()

	execTrampoline(keyvkGetDescriptorSetLayoutSupport, uintptr(device), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pSupport)))

	support = *(pSupport.Goify())
	return
}

var GetDescriptorSetLayoutSupportKHR = GetDescriptorSetLayoutSupport

// GetDeviceAccelerationStructureCompatibilityKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeviceAccelerationStructureCompatibilityKHR.html
func GetDeviceAccelerationStructureCompatibilityKHR(device Device, versionInfo *AccelerationStructureVersionInfoKHR) (compatibility AccelerationStructureCompatibilityKHR) {
	// Parameter is a singular input, requires translation - versionInfo
	var pVersionInfo *_vkAccelerationStructureVersionInfoKHR
	if versionInfo != nil {
		pVersionInfo = versionInfo.Vulkanize()
	}

	// compatibility is a binding-allocated single return value and will be populated by Vulkan
	ptr_pCompatibility := &compatibility

	execTrampoline(keyvkGetDeviceAccelerationStructureCompatibilityKHR, uintptr(device), uintptr(unsafe.Pointer(pVersionInfo)), uintptr(unsafe.Pointer(ptr_pCompatibility)))

	return
}

// GetDeviceBufferMemoryRequirements: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeviceBufferMemoryRequirements.html
func GetDeviceBufferMemoryRequirements(device Device, info *DeviceBufferMemoryRequirements) (memoryRequirements MemoryRequirements2) {
	// Parameter is a singular input, requires translation - info
	var pInfo *_vkDeviceBufferMemoryRequirements
	if info != nil {
		pInfo = info.Vulkanize()
	}

	// memoryRequirements is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pMemoryRequirements *_vkMemoryRequirements2 = memoryRequirements.Vulkanize()

	execTrampoline(keyvkGetDeviceBufferMemoryRequirements, uintptr(device), uintptr(unsafe.Pointer(pInfo)), uintptr(unsafe.Pointer(pMemoryRequirements)))

	memoryRequirements = *(pMemoryRequirements.Goify())
	return
}

var GetDeviceBufferMemoryRequirementsKHR = GetDeviceBufferMemoryRequirements

// GetDeviceFaultInfoEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeviceFaultInfoEXT.html
func GetDeviceFaultInfoEXT(device Device) (r Result, faultCounts DeviceFaultCountsEXT, faultInfo DeviceFaultInfoEXT) {
	// faultCounts is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pFaultCounts *_vkDeviceFaultCountsEXT = faultCounts.Vulkanize()

	// faultInfo is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pFaultInfo *_vkDeviceFaultInfoEXT = faultInfo.Vulkanize()

	r = Result(execTrampoline(keyvkGetDeviceFaultInfoEXT, uintptr(device), uintptr(unsafe.Pointer(pFaultCounts)), uintptr(unsafe.Pointer(pFaultInfo))))

	faultCounts = *(pFaultCounts.Goify())
	faultInfo = *(pFaultInfo.Goify())
	return
}

// GetDeviceGroupPeerMemoryFeatures: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeviceGroupPeerMemoryFeatures.html
func GetDeviceGroupPeerMemoryFeatures(device Device, heapIndex uint32, localDeviceIndex uint32, remoteDeviceIndex uint32) (peerMemoryFeatures PeerMemoryFeatureFlags) {
	// peerMemoryFeatures is a binding-allocated single return value and will be populated by Vulkan
	ptr_pPeerMemoryFeatures := &peerMemoryFeatures

	execTrampoline(keyvkGetDeviceGroupPeerMemoryFeatures, uintptr(device), uintptr(heapIndex), uintptr(localDeviceIndex), uintptr(remoteDeviceIndex), uintptr(unsafe.Pointer(ptr_pPeerMemoryFeatures)))

	return
}

var GetDeviceGroupPeerMemoryFeaturesKHR = GetDeviceGroupPeerMemoryFeatures

// GetDeviceGroupPresentCapabilitiesKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeviceGroupPresentCapabilitiesKHR.html
func GetDeviceGroupPresentCapabilitiesKHR(device Device) (r Result, deviceGroupPresentCapabilities DeviceGroupPresentCapabilitiesKHR) {
	// deviceGroupPresentCapabilities is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pDeviceGroupPresentCapabilities *_vkDeviceGroupPresentCapabilitiesKHR = deviceGroupPresentCapabilities.Vulkanize()

	r = Result(execTrampoline(keyvkGetDeviceGroupPresentCapabilitiesKHR, uintptr(device), uintptr(unsafe.Pointer(pDeviceGroupPresentCapabilities))))

	deviceGroupPresentCapabilities = *(pDeviceGroupPresentCapabilities.Goify())
	return
}

// GetDeviceGroupSurfacePresentModesKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeviceGroupSurfacePresentModesKHR.html
func GetDeviceGroupSurfacePresentModesKHR(device Device, surface SurfaceKHR) (r Result, modes DeviceGroupPresentModeFlagsKHR) {
	// modes is a binding-allocated single return value and will be populated by Vulkan
	ptr_pModes := &modes

	r = Result(execTrampoline(keyvkGetDeviceGroupSurfacePresentModesKHR, uintptr(device), uintptr(surface), uintptr(unsafe.Pointer(ptr_pModes))))

	return
}

// GetDeviceImageMemoryRequirements: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeviceImageMemoryRequirements.html
func GetDeviceImageMemoryRequirements(device Device, info *DeviceImageMemoryRequirements) (memoryRequirements MemoryRequirements2) {
	// Parameter is a singular input, requires translation - info
	var pInfo *_vkDeviceImageMemoryRequirements
	if info != nil {
		pInfo = info.Vulkanize()
	}

	// memoryRequirements is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pMemoryRequirements *_vkMemoryRequirements2 = memoryRequirements.Vulkanize()

	execTrampoline(keyvkGetDeviceImageMemoryRequirements, uintptr(device), uintptr(unsafe.Pointer(pInfo)), uintptr(unsafe.Pointer(pMemoryRequirements)))

	memoryRequirements = *(pMemoryRequirements.Goify())
	return
}

var GetDeviceImageMemoryRequirementsKHR = GetDeviceImageMemoryRequirements

// GetDeviceImageSparseMemoryRequirements: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeviceImageSparseMemoryRequirements.html
func GetDeviceImageSparseMemoryRequirements(device Device, info *DeviceImageMemoryRequirements) (sparseMemoryRequirements []SparseImageMemoryRequirements2) {
	// Parameter is a singular input, requires translation - info
	var pInfo *_vkDeviceImageMemoryRequirements
	if info != nil {
		pInfo = info.Vulkanize()
	}

	// sparseMemoryRequirements is a double-call array output
	var sparseMemoryRequirementCount uint32
	pSparseMemoryRequirementCount := &sparseMemoryRequirementCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pSparseMemoryRequirements *_vkSparseImageMemoryRequirements2

	execTrampoline(keyvkGetDeviceImageSparseMemoryRequirements, uintptr(device), uintptr(unsafe.Pointer(pInfo)), uintptr(unsafe.Pointer(pSparseMemoryRequirementCount)), uintptr(unsafe.Pointer(pSparseMemoryRequirements)))

	sl_pSparseMemoryRequirements := make([]_vkSparseImageMemoryRequirements2, sparseMemoryRequirementCount)
	sparseMemoryRequirements = make([]SparseImageMemoryRequirements2, sparseMemoryRequirementCount)
	pSparseMemoryRequirements = &sl_pSparseMemoryRequirements[0]

	// Trampoline call after last array allocation
	execTrampoline(keyvkGetDeviceImageSparseMemoryRequirements, uintptr(device), uintptr(unsafe.Pointer(pInfo)), uintptr(unsafe.Pointer(pSparseMemoryRequirementCount)), uintptr(unsafe.Pointer(pSparseMemoryRequirements)))

	for i := range sl_pSparseMemoryRequirements {
		sparseMemoryRequirements[i] = *sl_pSparseMemoryRequirements[i].Goify()
	}
	return
}

var GetDeviceImageSparseMemoryRequirementsKHR = GetDeviceImageSparseMemoryRequirements

// GetDeviceMemoryCommitment: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeviceMemoryCommitment.html
func GetDeviceMemoryCommitment(device Device, memory DeviceMemory) (committedMemoryInBytes DeviceSize) {
	// committedMemoryInBytes is a binding-allocated single return value and will be populated by Vulkan
	ptr_pCommittedMemoryInBytes := &committedMemoryInBytes

	execTrampoline(keyvkGetDeviceMemoryCommitment, uintptr(device), uintptr(memory), uintptr(unsafe.Pointer(ptr_pCommittedMemoryInBytes)))

	return
}

// GetDeviceMemoryOpaqueCaptureAddress: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeviceMemoryOpaqueCaptureAddress.html
func GetDeviceMemoryOpaqueCaptureAddress(device Device, info *DeviceMemoryOpaqueCaptureAddressInfo) (r uint64) {
	// Parameter is a singular input, requires translation - info
	var pInfo *_vkDeviceMemoryOpaqueCaptureAddressInfo
	if info != nil {
		pInfo = info.Vulkanize()
	}

	r = uint64(execTrampoline(keyvkGetDeviceMemoryOpaqueCaptureAddress, uintptr(device), uintptr(unsafe.Pointer(pInfo))))

	return
}

var GetDeviceMemoryOpaqueCaptureAddressKHR = GetDeviceMemoryOpaqueCaptureAddress

// GetDeviceMicromapCompatibilityEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeviceMicromapCompatibilityEXT.html
func GetDeviceMicromapCompatibilityEXT(device Device, versionInfo *MicromapVersionInfoEXT) (compatibility AccelerationStructureCompatibilityKHR) {
	// Parameter is a singular input, requires translation - versionInfo
	var pVersionInfo *_vkMicromapVersionInfoEXT
	if versionInfo != nil {
		pVersionInfo = versionInfo.Vulkanize()
	}

	// compatibility is a binding-allocated single return value and will be populated by Vulkan
	ptr_pCompatibility := &compatibility

	execTrampoline(keyvkGetDeviceMicromapCompatibilityEXT, uintptr(device), uintptr(unsafe.Pointer(pVersionInfo)), uintptr(unsafe.Pointer(ptr_pCompatibility)))

	return
}

// GetDeviceProcAddr: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeviceProcAddr.html
func GetDeviceProcAddr(device Device, name string) (fn PFN_vkVoidFunction) {
	// Parameter is a singular input, requires translation - name
	var pName *byte
	if name != "" {
		pName = sys_stringToBytePointer(name)
	}

	fn = PFN_vkVoidFunction(execTrampoline(keyvkGetDeviceProcAddr, uintptr(device), uintptr(unsafe.Pointer(pName))))

	return
}

// GetDeviceQueue: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeviceQueue.html
func GetDeviceQueue(device Device, queueFamilyIndex uint32, queueIndex uint32) (queue Queue) {
	// queue is a binding-allocated single return value and will be populated by Vulkan
	ptr_pQueue := &queue

	execTrampoline(keyvkGetDeviceQueue, uintptr(device), uintptr(queueFamilyIndex), uintptr(queueIndex), uintptr(unsafe.Pointer(ptr_pQueue)))

	return
}

// GetDeviceQueue2: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeviceQueue2.html
func GetDeviceQueue2(device Device, queueInfo *DeviceQueueInfo2) (queue Queue) {
	// Parameter is a singular input, requires translation - queueInfo
	var pQueueInfo *_vkDeviceQueueInfo2
	if queueInfo != nil {
		pQueueInfo = queueInfo.Vulkanize()
	}

	// queue is a binding-allocated single return value and will be populated by Vulkan
	ptr_pQueue := &queue

	execTrampoline(keyvkGetDeviceQueue2, uintptr(device), uintptr(unsafe.Pointer(pQueueInfo)), uintptr(unsafe.Pointer(ptr_pQueue)))

	return
}

// GetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI.html
func GetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI(device Device, renderpass RenderPass) (r Result, maxWorkgroupSize Extent2D) {
	// maxWorkgroupSize is a binding-allocated single return value and will be populated by Vulkan
	ptr_pMaxWorkgroupSize := &maxWorkgroupSize

	r = Result(execTrampoline(keyvkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI, uintptr(device), uintptr(renderpass), uintptr(unsafe.Pointer(ptr_pMaxWorkgroupSize))))

	return
}

// GetDisplayModeProperties2KHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDisplayModeProperties2KHR.html
func GetDisplayModeProperties2KHR(physicalDevice PhysicalDevice, display DisplayKHR) (r Result, properties []DisplayModeProperties2KHR) {
	// properties is a double-call array output
	var propertyCount uint32
	pPropertyCount := &propertyCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pProperties *_vkDisplayModeProperties2KHR

	r = Result(execTrampoline(keyvkGetDisplayModeProperties2KHR, uintptr(physicalDevice), uintptr(display), uintptr(unsafe.Pointer(pPropertyCount)), uintptr(unsafe.Pointer(pProperties))))

	sl_pProperties := make([]_vkDisplayModeProperties2KHR, propertyCount)
	properties = make([]DisplayModeProperties2KHR, propertyCount)
	pProperties = &sl_pProperties[0]

	// Trampoline call after last array allocation
	r = Result(execTrampoline(keyvkGetDisplayModeProperties2KHR, uintptr(physicalDevice), uintptr(display), uintptr(unsafe.Pointer(pPropertyCount)), uintptr(unsafe.Pointer(pProperties))))

	for i := range sl_pProperties {
		properties[i] = *sl_pProperties[i].Goify()
	}
	return
}

// GetDisplayModePropertiesKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDisplayModePropertiesKHR.html
func GetDisplayModePropertiesKHR(physicalDevice PhysicalDevice, display DisplayKHR) (r Result, properties []DisplayModePropertiesKHR) {
	// properties is a double-call array output
	var propertyCount uint32
	pPropertyCount := &propertyCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pProperties *_vkDisplayModePropertiesKHR

	r = Result(execTrampoline(keyvkGetDisplayModePropertiesKHR, uintptr(physicalDevice), uintptr(display), uintptr(unsafe.Pointer(pPropertyCount)), uintptr(unsafe.Pointer(pProperties))))

	sl_pProperties := make([]_vkDisplayModePropertiesKHR, propertyCount)
	properties = make([]DisplayModePropertiesKHR, propertyCount)
	pProperties = &sl_pProperties[0]

	// Trampoline call after last array allocation
	r = Result(execTrampoline(keyvkGetDisplayModePropertiesKHR, uintptr(physicalDevice), uintptr(display), uintptr(unsafe.Pointer(pPropertyCount)), uintptr(unsafe.Pointer(pProperties))))

	for i := range sl_pProperties {
		properties[i] = *sl_pProperties[i].Goify()
	}
	return
}

// GetDisplayPlaneCapabilities2KHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDisplayPlaneCapabilities2KHR.html
func GetDisplayPlaneCapabilities2KHR(physicalDevice PhysicalDevice, displayPlaneInfo *DisplayPlaneInfo2KHR) (r Result, capabilities DisplayPlaneCapabilities2KHR) {
	// Parameter is a singular input, requires translation - displayPlaneInfo
	var pDisplayPlaneInfo *_vkDisplayPlaneInfo2KHR
	if displayPlaneInfo != nil {
		pDisplayPlaneInfo = displayPlaneInfo.Vulkanize()
	}

	// capabilities is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pCapabilities *_vkDisplayPlaneCapabilities2KHR = capabilities.Vulkanize()

	r = Result(execTrampoline(keyvkGetDisplayPlaneCapabilities2KHR, uintptr(physicalDevice), uintptr(unsafe.Pointer(pDisplayPlaneInfo)), uintptr(unsafe.Pointer(pCapabilities))))

	capabilities = *(pCapabilities.Goify())
	return
}

// GetDisplayPlaneCapabilitiesKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDisplayPlaneCapabilitiesKHR.html
func GetDisplayPlaneCapabilitiesKHR(physicalDevice PhysicalDevice, mode DisplayModeKHR, planeIndex uint32) (r Result, capabilities DisplayPlaneCapabilitiesKHR) {
	// capabilities is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pCapabilities *_vkDisplayPlaneCapabilitiesKHR = capabilities.Vulkanize()

	r = Result(execTrampoline(keyvkGetDisplayPlaneCapabilitiesKHR, uintptr(physicalDevice), uintptr(mode), uintptr(planeIndex), uintptr(unsafe.Pointer(pCapabilities))))

	capabilities = *(pCapabilities.Goify())
	return
}

// GetDisplayPlaneSupportedDisplaysKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDisplayPlaneSupportedDisplaysKHR.html
func GetDisplayPlaneSupportedDisplaysKHR(physicalDevice PhysicalDevice, planeIndex uint32) (r Result, displays []DisplayKHR) {
	// displays is a double-call array output
	var displayCount uint32
	pDisplayCount := &displayCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pDisplays *DisplayKHR

	r = Result(execTrampoline(keyvkGetDisplayPlaneSupportedDisplaysKHR, uintptr(physicalDevice), uintptr(planeIndex), uintptr(unsafe.Pointer(pDisplayCount)), uintptr(unsafe.Pointer(pDisplays))))

	sl_pDisplays := make([]DisplayKHR, displayCount)
	displays = make([]DisplayKHR, displayCount)
	pDisplays = &sl_pDisplays[0]

	// Trampoline call after last array allocation
	r = Result(execTrampoline(keyvkGetDisplayPlaneSupportedDisplaysKHR, uintptr(physicalDevice), uintptr(planeIndex), uintptr(unsafe.Pointer(pDisplayCount)), uintptr(unsafe.Pointer(pDisplays))))

	for i := range sl_pDisplays {
		displays[i] = *&sl_pDisplays[i]
	}
	return
}

// GetDrmDisplayEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDrmDisplayEXT.html
func GetDrmDisplayEXT(physicalDevice PhysicalDevice, drmFd int32, connectorId uint32) (r Result, display DisplayKHR) {
	// display is a binding-allocated single return value and will be populated by Vulkan
	ptr_display := &display

	r = Result(execTrampoline(keyvkGetDrmDisplayEXT, uintptr(physicalDevice), uintptr(drmFd), uintptr(connectorId), uintptr(unsafe.Pointer(ptr_display))))

	return
}

// GetDynamicRenderingTilePropertiesQCOM: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDynamicRenderingTilePropertiesQCOM.html
func GetDynamicRenderingTilePropertiesQCOM(device Device, renderingInfo *RenderingInfo) (r Result, properties TilePropertiesQCOM) {
	// Parameter is a singular input, requires translation - renderingInfo
	var pRenderingInfo *_vkRenderingInfo
	if renderingInfo != nil {
		pRenderingInfo = renderingInfo.Vulkanize()
	}

	// properties is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pProperties *_vkTilePropertiesQCOM = properties.Vulkanize()

	r = Result(execTrampoline(keyvkGetDynamicRenderingTilePropertiesQCOM, uintptr(device), uintptr(unsafe.Pointer(pRenderingInfo)), uintptr(unsafe.Pointer(pProperties))))

	properties = *(pProperties.Goify())
	return
}

// GetEventStatus: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetEventStatus.html
func GetEventStatus(device Device, event Event) (r Result) {

	r = Result(execTrampoline(keyvkGetEventStatus, uintptr(device), uintptr(event)))

	return
}

// GetFenceFdKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetFenceFdKHR.html
func GetFenceFdKHR(device Device, getFdInfo *FenceGetFdInfoKHR) (r Result, fd int32) {
	// Parameter is a singular input, requires translation - getFdInfo
	var pGetFdInfo *_vkFenceGetFdInfoKHR
	if getFdInfo != nil {
		pGetFdInfo = getFdInfo.Vulkanize()
	}

	// fd is a binding-allocated single return value and will be populated by Vulkan
	ptr_pFd := &fd

	r = Result(execTrampoline(keyvkGetFenceFdKHR, uintptr(device), uintptr(unsafe.Pointer(pGetFdInfo)), uintptr(unsafe.Pointer(ptr_pFd))))

	return
}

// GetFenceStatus: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetFenceStatus.html
func GetFenceStatus(device Device, fence Fence) (r Result) {

	r = Result(execTrampoline(keyvkGetFenceStatus, uintptr(device), uintptr(fence)))

	return
}

// GetFramebufferTilePropertiesQCOM: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetFramebufferTilePropertiesQCOM.html
func GetFramebufferTilePropertiesQCOM(device Device, framebuffer Framebuffer) (r Result, properties []TilePropertiesQCOM) {
	// properties is a double-call array output
	var propertiesCount uint32
	pPropertiesCount := &propertiesCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pProperties *_vkTilePropertiesQCOM

	r = Result(execTrampoline(keyvkGetFramebufferTilePropertiesQCOM, uintptr(device), uintptr(framebuffer), uintptr(unsafe.Pointer(pPropertiesCount)), uintptr(unsafe.Pointer(pProperties))))

	sl_pProperties := make([]_vkTilePropertiesQCOM, propertiesCount)
	properties = make([]TilePropertiesQCOM, propertiesCount)
	pProperties = &sl_pProperties[0]

	// Trampoline call after last array allocation
	r = Result(execTrampoline(keyvkGetFramebufferTilePropertiesQCOM, uintptr(device), uintptr(framebuffer), uintptr(unsafe.Pointer(pPropertiesCount)), uintptr(unsafe.Pointer(pProperties))))

	for i := range sl_pProperties {
		properties[i] = *sl_pProperties[i].Goify()
	}
	return
}

// GetGeneratedCommandsMemoryRequirementsNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetGeneratedCommandsMemoryRequirementsNV.html
func GetGeneratedCommandsMemoryRequirementsNV(device Device, info *GeneratedCommandsMemoryRequirementsInfoNV) (memoryRequirements MemoryRequirements2) {
	// Parameter is a singular input, requires translation - info
	var pInfo *_vkGeneratedCommandsMemoryRequirementsInfoNV
	if info != nil {
		pInfo = info.Vulkanize()
	}

	// memoryRequirements is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pMemoryRequirements *_vkMemoryRequirements2 = memoryRequirements.Vulkanize()

	execTrampoline(keyvkGetGeneratedCommandsMemoryRequirementsNV, uintptr(device), uintptr(unsafe.Pointer(pInfo)), uintptr(unsafe.Pointer(pMemoryRequirements)))

	memoryRequirements = *(pMemoryRequirements.Goify())
	return
}

// GetImageDrmFormatModifierPropertiesEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetImageDrmFormatModifierPropertiesEXT.html
func GetImageDrmFormatModifierPropertiesEXT(device Device, image Image) (r Result, properties ImageDrmFormatModifierPropertiesEXT) {
	// properties is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pProperties *_vkImageDrmFormatModifierPropertiesEXT = properties.Vulkanize()

	r = Result(execTrampoline(keyvkGetImageDrmFormatModifierPropertiesEXT, uintptr(device), uintptr(image), uintptr(unsafe.Pointer(pProperties))))

	properties = *(pProperties.Goify())
	return
}

// GetImageMemoryRequirements: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetImageMemoryRequirements.html
func GetImageMemoryRequirements(device Device, image Image) (memoryRequirements MemoryRequirements) {
	// memoryRequirements is a binding-allocated single return value and will be populated by Vulkan
	ptr_pMemoryRequirements := &memoryRequirements

	execTrampoline(keyvkGetImageMemoryRequirements, uintptr(device), uintptr(image), uintptr(unsafe.Pointer(ptr_pMemoryRequirements)))

	return
}

// GetImageMemoryRequirements2: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetImageMemoryRequirements2.html
func GetImageMemoryRequirements2(device Device, info *ImageMemoryRequirementsInfo2) (memoryRequirements MemoryRequirements2) {
	// Parameter is a singular input, requires translation - info
	var pInfo *_vkImageMemoryRequirementsInfo2
	if info != nil {
		pInfo = info.Vulkanize()
	}

	// memoryRequirements is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pMemoryRequirements *_vkMemoryRequirements2 = memoryRequirements.Vulkanize()

	execTrampoline(keyvkGetImageMemoryRequirements2, uintptr(device), uintptr(unsafe.Pointer(pInfo)), uintptr(unsafe.Pointer(pMemoryRequirements)))

	memoryRequirements = *(pMemoryRequirements.Goify())
	return
}

var GetImageMemoryRequirements2KHR = GetImageMemoryRequirements2

// GetImageOpaqueCaptureDescriptorDataEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetImageOpaqueCaptureDescriptorDataEXT.html
func GetImageOpaqueCaptureDescriptorDataEXT(device Device, info *ImageCaptureDescriptorDataInfoEXT) (r Result, data byte) {
	// Parameter is a singular input, requires translation - info
	var pInfo *_vkImageCaptureDescriptorDataInfoEXT
	if info != nil {
		pInfo = info.Vulkanize()
	}

	// data is a binding-allocated single return value and will be populated by Vulkan
	ptr_pData := &data

	r = Result(execTrampoline(keyvkGetImageOpaqueCaptureDescriptorDataEXT, uintptr(device), uintptr(unsafe.Pointer(pInfo)), uintptr(unsafe.Pointer(ptr_pData))))

	return
}

// GetImageSparseMemoryRequirements: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetImageSparseMemoryRequirements.html
func GetImageSparseMemoryRequirements(device Device, image Image) (sparseMemoryRequirements []SparseImageMemoryRequirements) {
	// sparseMemoryRequirements is a double-call array output
	var sparseMemoryRequirementCount uint32
	pSparseMemoryRequirementCount := &sparseMemoryRequirementCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pSparseMemoryRequirements *_vkSparseImageMemoryRequirements

	execTrampoline(keyvkGetImageSparseMemoryRequirements, uintptr(device), uintptr(image), uintptr(unsafe.Pointer(pSparseMemoryRequirementCount)), uintptr(unsafe.Pointer(pSparseMemoryRequirements)))

	sl_pSparseMemoryRequirements := make([]_vkSparseImageMemoryRequirements, sparseMemoryRequirementCount)
	sparseMemoryRequirements = make([]SparseImageMemoryRequirements, sparseMemoryRequirementCount)
	pSparseMemoryRequirements = &sl_pSparseMemoryRequirements[0]

	// Trampoline call after last array allocation
	execTrampoline(keyvkGetImageSparseMemoryRequirements, uintptr(device), uintptr(image), uintptr(unsafe.Pointer(pSparseMemoryRequirementCount)), uintptr(unsafe.Pointer(pSparseMemoryRequirements)))

	for i := range sl_pSparseMemoryRequirements {
		sparseMemoryRequirements[i] = *sl_pSparseMemoryRequirements[i].Goify()
	}
	return
}

// GetImageSparseMemoryRequirements2: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetImageSparseMemoryRequirements2.html
func GetImageSparseMemoryRequirements2(device Device, info *ImageSparseMemoryRequirementsInfo2) (sparseMemoryRequirements []SparseImageMemoryRequirements2) {
	// Parameter is a singular input, requires translation - info
	var pInfo *_vkImageSparseMemoryRequirementsInfo2
	if info != nil {
		pInfo = info.Vulkanize()
	}

	// sparseMemoryRequirements is a double-call array output
	var sparseMemoryRequirementCount uint32
	pSparseMemoryRequirementCount := &sparseMemoryRequirementCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pSparseMemoryRequirements *_vkSparseImageMemoryRequirements2

	execTrampoline(keyvkGetImageSparseMemoryRequirements2, uintptr(device), uintptr(unsafe.Pointer(pInfo)), uintptr(unsafe.Pointer(pSparseMemoryRequirementCount)), uintptr(unsafe.Pointer(pSparseMemoryRequirements)))

	sl_pSparseMemoryRequirements := make([]_vkSparseImageMemoryRequirements2, sparseMemoryRequirementCount)
	sparseMemoryRequirements = make([]SparseImageMemoryRequirements2, sparseMemoryRequirementCount)
	pSparseMemoryRequirements = &sl_pSparseMemoryRequirements[0]

	// Trampoline call after last array allocation
	execTrampoline(keyvkGetImageSparseMemoryRequirements2, uintptr(device), uintptr(unsafe.Pointer(pInfo)), uintptr(unsafe.Pointer(pSparseMemoryRequirementCount)), uintptr(unsafe.Pointer(pSparseMemoryRequirements)))

	for i := range sl_pSparseMemoryRequirements {
		sparseMemoryRequirements[i] = *sl_pSparseMemoryRequirements[i].Goify()
	}
	return
}

var GetImageSparseMemoryRequirements2KHR = GetImageSparseMemoryRequirements2

// GetImageSubresourceLayout: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetImageSubresourceLayout.html
func GetImageSubresourceLayout(device Device, image Image, subresource *ImageSubresource) (layout SubresourceLayout) {
	// Parameter is a singular input, pass direct - subresource
	var pSubresource unsafe.Pointer
	if subresource != nil {
		pSubresource = unsafe.Pointer(subresource)
	}

	// layout is a binding-allocated single return value and will be populated by Vulkan
	ptr_pLayout := &layout

	execTrampoline(keyvkGetImageSubresourceLayout, uintptr(device), uintptr(image), uintptr(unsafe.Pointer(pSubresource)), uintptr(unsafe.Pointer(ptr_pLayout)))

	return
}

// GetImageSubresourceLayout2EXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetImageSubresourceLayout2EXT.html
func GetImageSubresourceLayout2EXT(device Device, image Image, subresource *ImageSubresource2EXT) (layout SubresourceLayout2EXT) {
	// Parameter is a singular input, requires translation - subresource
	var pSubresource *_vkImageSubresource2EXT
	if subresource != nil {
		pSubresource = subresource.Vulkanize()
	}

	// layout is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pLayout *_vkSubresourceLayout2EXT = layout.Vulkanize()

	execTrampoline(keyvkGetImageSubresourceLayout2EXT, uintptr(device), uintptr(image), uintptr(unsafe.Pointer(pSubresource)), uintptr(unsafe.Pointer(pLayout)))

	layout = *(pLayout.Goify())
	return
}

// GetImageViewAddressNVX: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetImageViewAddressNVX.html
func GetImageViewAddressNVX(device Device, imageView ImageView) (r Result, properties ImageViewAddressPropertiesNVX) {
	// properties is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pProperties *_vkImageViewAddressPropertiesNVX = properties.Vulkanize()

	r = Result(execTrampoline(keyvkGetImageViewAddressNVX, uintptr(device), uintptr(imageView), uintptr(unsafe.Pointer(pProperties))))

	properties = *(pProperties.Goify())
	return
}

// GetImageViewHandleNVX: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetImageViewHandleNVX.html
func GetImageViewHandleNVX(device Device, info *ImageViewHandleInfoNVX) (r uint32) {
	// Parameter is a singular input, requires translation - info
	var pInfo *_vkImageViewHandleInfoNVX
	if info != nil {
		pInfo = info.Vulkanize()
	}

	r = uint32(execTrampoline(keyvkGetImageViewHandleNVX, uintptr(device), uintptr(unsafe.Pointer(pInfo))))

	return
}

// GetImageViewOpaqueCaptureDescriptorDataEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetImageViewOpaqueCaptureDescriptorDataEXT.html
func GetImageViewOpaqueCaptureDescriptorDataEXT(device Device, info *ImageViewCaptureDescriptorDataInfoEXT) (r Result, data byte) {
	// Parameter is a singular input, requires translation - info
	var pInfo *_vkImageViewCaptureDescriptorDataInfoEXT
	if info != nil {
		pInfo = info.Vulkanize()
	}

	// data is a binding-allocated single return value and will be populated by Vulkan
	ptr_pData := &data

	r = Result(execTrampoline(keyvkGetImageViewOpaqueCaptureDescriptorDataEXT, uintptr(device), uintptr(unsafe.Pointer(pInfo)), uintptr(unsafe.Pointer(ptr_pData))))

	return
}

// GetInstanceProcAddr: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetInstanceProcAddr.html
func GetInstanceProcAddr(instance Instance, name string) (fn PFN_vkVoidFunction) {
	// Parameter is a singular input, requires translation - name
	var pName *byte
	if name != "" {
		pName = sys_stringToBytePointer(name)
	}

	fn = PFN_vkVoidFunction(execTrampoline(keyvkGetInstanceProcAddr, uintptr(instance), uintptr(unsafe.Pointer(pName))))

	return
}

// GetMemoryFdKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetMemoryFdKHR.html
func GetMemoryFdKHR(device Device, getFdInfo *MemoryGetFdInfoKHR) (r Result, fd int32) {
	// Parameter is a singular input, requires translation - getFdInfo
	var pGetFdInfo *_vkMemoryGetFdInfoKHR
	if getFdInfo != nil {
		pGetFdInfo = getFdInfo.Vulkanize()
	}

	// fd is a binding-allocated single return value and will be populated by Vulkan
	ptr_pFd := &fd

	r = Result(execTrampoline(keyvkGetMemoryFdKHR, uintptr(device), uintptr(unsafe.Pointer(pGetFdInfo)), uintptr(unsafe.Pointer(ptr_pFd))))

	return
}

// GetMemoryFdPropertiesKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetMemoryFdPropertiesKHR.html
func GetMemoryFdPropertiesKHR(device Device, handleType ExternalMemoryHandleTypeFlagBits, fd int32) (r Result, memoryFdProperties MemoryFdPropertiesKHR) {
	// memoryFdProperties is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pMemoryFdProperties *_vkMemoryFdPropertiesKHR = memoryFdProperties.Vulkanize()

	r = Result(execTrampoline(keyvkGetMemoryFdPropertiesKHR, uintptr(device), uintptr(handleType), uintptr(fd), uintptr(unsafe.Pointer(pMemoryFdProperties))))

	memoryFdProperties = *(pMemoryFdProperties.Goify())
	return
}

// GetMemoryHostPointerPropertiesEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetMemoryHostPointerPropertiesEXT.html
func GetMemoryHostPointerPropertiesEXT(device Device, handleType ExternalMemoryHandleTypeFlagBits, hostPointer *byte) (r Result, memoryHostPointerProperties MemoryHostPointerPropertiesEXT) {
	// Parameter is a singular input, pass direct - hostPointer
	var pHostPointer unsafe.Pointer
	if hostPointer != nil {
		pHostPointer = unsafe.Pointer(hostPointer)
	}

	// memoryHostPointerProperties is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pMemoryHostPointerProperties *_vkMemoryHostPointerPropertiesEXT = memoryHostPointerProperties.Vulkanize()

	r = Result(execTrampoline(keyvkGetMemoryHostPointerPropertiesEXT, uintptr(device), uintptr(handleType), uintptr(unsafe.Pointer(pHostPointer)), uintptr(unsafe.Pointer(pMemoryHostPointerProperties))))

	memoryHostPointerProperties = *(pMemoryHostPointerProperties.Goify())
	return
}

// GetMemoryRemoteAddressNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetMemoryRemoteAddressNV.html
func GetMemoryRemoteAddressNV(device Device, memoryGetRemoteAddressInfo *MemoryGetRemoteAddressInfoNV) (r Result, address RemoteAddressNV) {
	// Parameter is a singular input, requires translation - memoryGetRemoteAddressInfo
	var pMemoryGetRemoteAddressInfo *_vkMemoryGetRemoteAddressInfoNV
	if memoryGetRemoteAddressInfo != nil {
		pMemoryGetRemoteAddressInfo = memoryGetRemoteAddressInfo.Vulkanize()
	}

	// address is a binding-allocated single return value and will be populated by Vulkan
	ptr_pAddress := &address

	r = Result(execTrampoline(keyvkGetMemoryRemoteAddressNV, uintptr(device), uintptr(unsafe.Pointer(pMemoryGetRemoteAddressInfo)), uintptr(unsafe.Pointer(ptr_pAddress))))

	return
}

// GetMicromapBuildSizesEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetMicromapBuildSizesEXT.html
func GetMicromapBuildSizesEXT(device Device, buildType AccelerationStructureBuildTypeKHR, buildInfo *MicromapBuildInfoEXT) (sizeInfo MicromapBuildSizesInfoEXT) {
	// Parameter is a singular input, requires translation - buildInfo
	var pBuildInfo *_vkMicromapBuildInfoEXT
	if buildInfo != nil {
		pBuildInfo = buildInfo.Vulkanize()
	}

	// sizeInfo is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pSizeInfo *_vkMicromapBuildSizesInfoEXT = sizeInfo.Vulkanize()

	execTrampoline(keyvkGetMicromapBuildSizesEXT, uintptr(device), uintptr(buildType), uintptr(unsafe.Pointer(pBuildInfo)), uintptr(unsafe.Pointer(pSizeInfo)))

	sizeInfo = *(pSizeInfo.Goify())
	return
}

// GetPastPresentationTimingGOOGLE: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPastPresentationTimingGOOGLE.html
func GetPastPresentationTimingGOOGLE(device Device, swapchain SwapchainKHR) (r Result, presentationTimings []PastPresentationTimingGOOGLE) {
	// presentationTimings is a double-call array output
	var presentationTimingCount uint32
	pPresentationTimingCount := &presentationTimingCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pPresentationTimings *_vkPastPresentationTimingGOOGLE

	r = Result(execTrampoline(keyvkGetPastPresentationTimingGOOGLE, uintptr(device), uintptr(swapchain), uintptr(unsafe.Pointer(pPresentationTimingCount)), uintptr(unsafe.Pointer(pPresentationTimings))))

	sl_pPresentationTimings := make([]_vkPastPresentationTimingGOOGLE, presentationTimingCount)
	presentationTimings = make([]PastPresentationTimingGOOGLE, presentationTimingCount)
	pPresentationTimings = &sl_pPresentationTimings[0]

	// Trampoline call after last array allocation
	r = Result(execTrampoline(keyvkGetPastPresentationTimingGOOGLE, uintptr(device), uintptr(swapchain), uintptr(unsafe.Pointer(pPresentationTimingCount)), uintptr(unsafe.Pointer(pPresentationTimings))))

	for i := range sl_pPresentationTimings {
		presentationTimings[i] = *sl_pPresentationTimings[i].Goify()
	}
	return
}

// GetPerformanceParameterINTEL: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPerformanceParameterINTEL.html
func GetPerformanceParameterINTEL(device Device, parameter PerformanceParameterTypeINTEL) (r Result, value PerformanceValueINTEL) {
	// value is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pValue *_vkPerformanceValueINTEL = value.Vulkanize()

	r = Result(execTrampoline(keyvkGetPerformanceParameterINTEL, uintptr(device), uintptr(parameter), uintptr(unsafe.Pointer(pValue))))

	value = *(pValue.Goify())
	return
}

// GetPhysicalDeviceCalibrateableTimeDomainsEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceCalibrateableTimeDomainsEXT.html
func GetPhysicalDeviceCalibrateableTimeDomainsEXT(physicalDevice PhysicalDevice) (r Result, timeDomains []TimeDomainEXT) {
	// timeDomains is a double-call array output
	var timeDomainCount uint32
	pTimeDomainCount := &timeDomainCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pTimeDomains *TimeDomainEXT

	r = Result(execTrampoline(keyvkGetPhysicalDeviceCalibrateableTimeDomainsEXT, uintptr(physicalDevice), uintptr(unsafe.Pointer(pTimeDomainCount)), uintptr(unsafe.Pointer(pTimeDomains))))

	sl_pTimeDomains := make([]TimeDomainEXT, timeDomainCount)
	timeDomains = make([]TimeDomainEXT, timeDomainCount)
	pTimeDomains = &sl_pTimeDomains[0]

	// Trampoline call after last array allocation
	r = Result(execTrampoline(keyvkGetPhysicalDeviceCalibrateableTimeDomainsEXT, uintptr(physicalDevice), uintptr(unsafe.Pointer(pTimeDomainCount)), uintptr(unsafe.Pointer(pTimeDomains))))

	for i := range sl_pTimeDomains {
		timeDomains[i] = *&sl_pTimeDomains[i]
	}
	return
}

// GetPhysicalDeviceCooperativeMatrixPropertiesNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceCooperativeMatrixPropertiesNV.html
func GetPhysicalDeviceCooperativeMatrixPropertiesNV(physicalDevice PhysicalDevice) (r Result, properties []CooperativeMatrixPropertiesNV) {
	// properties is a double-call array output
	var propertyCount uint32
	pPropertyCount := &propertyCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pProperties *_vkCooperativeMatrixPropertiesNV

	r = Result(execTrampoline(keyvkGetPhysicalDeviceCooperativeMatrixPropertiesNV, uintptr(physicalDevice), uintptr(unsafe.Pointer(pPropertyCount)), uintptr(unsafe.Pointer(pProperties))))

	sl_pProperties := make([]_vkCooperativeMatrixPropertiesNV, propertyCount)
	properties = make([]CooperativeMatrixPropertiesNV, propertyCount)
	pProperties = &sl_pProperties[0]

	// Trampoline call after last array allocation
	r = Result(execTrampoline(keyvkGetPhysicalDeviceCooperativeMatrixPropertiesNV, uintptr(physicalDevice), uintptr(unsafe.Pointer(pPropertyCount)), uintptr(unsafe.Pointer(pProperties))))

	for i := range sl_pProperties {
		properties[i] = *sl_pProperties[i].Goify()
	}
	return
}

// GetPhysicalDeviceDisplayPlaneProperties2KHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceDisplayPlaneProperties2KHR.html
func GetPhysicalDeviceDisplayPlaneProperties2KHR(physicalDevice PhysicalDevice) (r Result, properties []DisplayPlaneProperties2KHR) {
	// properties is a double-call array output
	var propertyCount uint32
	pPropertyCount := &propertyCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pProperties *_vkDisplayPlaneProperties2KHR

	r = Result(execTrampoline(keyvkGetPhysicalDeviceDisplayPlaneProperties2KHR, uintptr(physicalDevice), uintptr(unsafe.Pointer(pPropertyCount)), uintptr(unsafe.Pointer(pProperties))))

	sl_pProperties := make([]_vkDisplayPlaneProperties2KHR, propertyCount)
	properties = make([]DisplayPlaneProperties2KHR, propertyCount)
	pProperties = &sl_pProperties[0]

	// Trampoline call after last array allocation
	r = Result(execTrampoline(keyvkGetPhysicalDeviceDisplayPlaneProperties2KHR, uintptr(physicalDevice), uintptr(unsafe.Pointer(pPropertyCount)), uintptr(unsafe.Pointer(pProperties))))

	for i := range sl_pProperties {
		properties[i] = *sl_pProperties[i].Goify()
	}
	return
}

// GetPhysicalDeviceDisplayPlanePropertiesKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceDisplayPlanePropertiesKHR.html
func GetPhysicalDeviceDisplayPlanePropertiesKHR(physicalDevice PhysicalDevice) (r Result, properties []DisplayPlanePropertiesKHR) {
	// properties is a double-call array output
	var propertyCount uint32
	pPropertyCount := &propertyCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pProperties *_vkDisplayPlanePropertiesKHR

	r = Result(execTrampoline(keyvkGetPhysicalDeviceDisplayPlanePropertiesKHR, uintptr(physicalDevice), uintptr(unsafe.Pointer(pPropertyCount)), uintptr(unsafe.Pointer(pProperties))))

	sl_pProperties := make([]_vkDisplayPlanePropertiesKHR, propertyCount)
	properties = make([]DisplayPlanePropertiesKHR, propertyCount)
	pProperties = &sl_pProperties[0]

	// Trampoline call after last array allocation
	r = Result(execTrampoline(keyvkGetPhysicalDeviceDisplayPlanePropertiesKHR, uintptr(physicalDevice), uintptr(unsafe.Pointer(pPropertyCount)), uintptr(unsafe.Pointer(pProperties))))

	for i := range sl_pProperties {
		properties[i] = *sl_pProperties[i].Goify()
	}
	return
}

// GetPhysicalDeviceDisplayProperties2KHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceDisplayProperties2KHR.html
func GetPhysicalDeviceDisplayProperties2KHR(physicalDevice PhysicalDevice) (r Result, properties []DisplayProperties2KHR) {
	// properties is a double-call array output
	var propertyCount uint32
	pPropertyCount := &propertyCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pProperties *_vkDisplayProperties2KHR

	r = Result(execTrampoline(keyvkGetPhysicalDeviceDisplayProperties2KHR, uintptr(physicalDevice), uintptr(unsafe.Pointer(pPropertyCount)), uintptr(unsafe.Pointer(pProperties))))

	sl_pProperties := make([]_vkDisplayProperties2KHR, propertyCount)
	properties = make([]DisplayProperties2KHR, propertyCount)
	pProperties = &sl_pProperties[0]

	// Trampoline call after last array allocation
	r = Result(execTrampoline(keyvkGetPhysicalDeviceDisplayProperties2KHR, uintptr(physicalDevice), uintptr(unsafe.Pointer(pPropertyCount)), uintptr(unsafe.Pointer(pProperties))))

	for i := range sl_pProperties {
		properties[i] = *sl_pProperties[i].Goify()
	}
	return
}

// GetPhysicalDeviceDisplayPropertiesKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceDisplayPropertiesKHR.html
func GetPhysicalDeviceDisplayPropertiesKHR(physicalDevice PhysicalDevice) (r Result, properties []DisplayPropertiesKHR) {
	// properties is a double-call array output
	var propertyCount uint32
	pPropertyCount := &propertyCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pProperties *_vkDisplayPropertiesKHR

	r = Result(execTrampoline(keyvkGetPhysicalDeviceDisplayPropertiesKHR, uintptr(physicalDevice), uintptr(unsafe.Pointer(pPropertyCount)), uintptr(unsafe.Pointer(pProperties))))

	sl_pProperties := make([]_vkDisplayPropertiesKHR, propertyCount)
	properties = make([]DisplayPropertiesKHR, propertyCount)
	pProperties = &sl_pProperties[0]

	// Trampoline call after last array allocation
	r = Result(execTrampoline(keyvkGetPhysicalDeviceDisplayPropertiesKHR, uintptr(physicalDevice), uintptr(unsafe.Pointer(pPropertyCount)), uintptr(unsafe.Pointer(pProperties))))

	for i := range sl_pProperties {
		properties[i] = *sl_pProperties[i].Goify()
	}
	return
}

// GetPhysicalDeviceExternalBufferProperties: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceExternalBufferProperties.html
func GetPhysicalDeviceExternalBufferProperties(physicalDevice PhysicalDevice, externalBufferInfo *PhysicalDeviceExternalBufferInfo) (externalBufferProperties ExternalBufferProperties) {
	// Parameter is a singular input, requires translation - externalBufferInfo
	var pExternalBufferInfo *_vkPhysicalDeviceExternalBufferInfo
	if externalBufferInfo != nil {
		pExternalBufferInfo = externalBufferInfo.Vulkanize()
	}

	// externalBufferProperties is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pExternalBufferProperties *_vkExternalBufferProperties = externalBufferProperties.Vulkanize()

	execTrampoline(keyvkGetPhysicalDeviceExternalBufferProperties, uintptr(physicalDevice), uintptr(unsafe.Pointer(pExternalBufferInfo)), uintptr(unsafe.Pointer(pExternalBufferProperties)))

	externalBufferProperties = *(pExternalBufferProperties.Goify())
	return
}

var GetPhysicalDeviceExternalBufferPropertiesKHR = GetPhysicalDeviceExternalBufferProperties

// GetPhysicalDeviceExternalFenceProperties: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceExternalFenceProperties.html
func GetPhysicalDeviceExternalFenceProperties(physicalDevice PhysicalDevice, externalFenceInfo *PhysicalDeviceExternalFenceInfo) (externalFenceProperties ExternalFenceProperties) {
	// Parameter is a singular input, requires translation - externalFenceInfo
	var pExternalFenceInfo *_vkPhysicalDeviceExternalFenceInfo
	if externalFenceInfo != nil {
		pExternalFenceInfo = externalFenceInfo.Vulkanize()
	}

	// externalFenceProperties is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pExternalFenceProperties *_vkExternalFenceProperties = externalFenceProperties.Vulkanize()

	execTrampoline(keyvkGetPhysicalDeviceExternalFenceProperties, uintptr(physicalDevice), uintptr(unsafe.Pointer(pExternalFenceInfo)), uintptr(unsafe.Pointer(pExternalFenceProperties)))

	externalFenceProperties = *(pExternalFenceProperties.Goify())
	return
}

var GetPhysicalDeviceExternalFencePropertiesKHR = GetPhysicalDeviceExternalFenceProperties

// GetPhysicalDeviceExternalImageFormatPropertiesNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceExternalImageFormatPropertiesNV.html
func GetPhysicalDeviceExternalImageFormatPropertiesNV(physicalDevice PhysicalDevice, format Format, typ ImageType, tiling ImageTiling, usage ImageUsageFlags, flags ImageCreateFlags, externalHandleType ExternalMemoryHandleTypeFlagsNV) (r Result, externalImageFormatProperties ExternalImageFormatPropertiesNV) {
	// externalImageFormatProperties is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pExternalImageFormatProperties *_vkExternalImageFormatPropertiesNV = externalImageFormatProperties.Vulkanize()

	r = Result(execTrampoline(keyvkGetPhysicalDeviceExternalImageFormatPropertiesNV, uintptr(physicalDevice), uintptr(format), uintptr(typ), uintptr(tiling), uintptr(usage), uintptr(flags), uintptr(externalHandleType), uintptr(unsafe.Pointer(pExternalImageFormatProperties))))

	externalImageFormatProperties = *(pExternalImageFormatProperties.Goify())
	return
}

// GetPhysicalDeviceExternalSemaphoreProperties: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceExternalSemaphoreProperties.html
func GetPhysicalDeviceExternalSemaphoreProperties(physicalDevice PhysicalDevice, externalSemaphoreInfo *PhysicalDeviceExternalSemaphoreInfo) (externalSemaphoreProperties ExternalSemaphoreProperties) {
	// Parameter is a singular input, requires translation - externalSemaphoreInfo
	var pExternalSemaphoreInfo *_vkPhysicalDeviceExternalSemaphoreInfo
	if externalSemaphoreInfo != nil {
		pExternalSemaphoreInfo = externalSemaphoreInfo.Vulkanize()
	}

	// externalSemaphoreProperties is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pExternalSemaphoreProperties *_vkExternalSemaphoreProperties = externalSemaphoreProperties.Vulkanize()

	execTrampoline(keyvkGetPhysicalDeviceExternalSemaphoreProperties, uintptr(physicalDevice), uintptr(unsafe.Pointer(pExternalSemaphoreInfo)), uintptr(unsafe.Pointer(pExternalSemaphoreProperties)))

	externalSemaphoreProperties = *(pExternalSemaphoreProperties.Goify())
	return
}

var GetPhysicalDeviceExternalSemaphorePropertiesKHR = GetPhysicalDeviceExternalSemaphoreProperties

// GetPhysicalDeviceFeatures: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceFeatures.html
func GetPhysicalDeviceFeatures(physicalDevice PhysicalDevice) (features PhysicalDeviceFeatures) {
	// features is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pFeatures *_vkPhysicalDeviceFeatures = features.Vulkanize()

	execTrampoline(keyvkGetPhysicalDeviceFeatures, uintptr(physicalDevice), uintptr(unsafe.Pointer(pFeatures)))

	features = *(pFeatures.Goify())
	return
}

// GetPhysicalDeviceFeatures2: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceFeatures2.html
func GetPhysicalDeviceFeatures2(physicalDevice PhysicalDevice) (features PhysicalDeviceFeatures2) {
	// features is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pFeatures *_vkPhysicalDeviceFeatures2 = features.Vulkanize()

	execTrampoline(keyvkGetPhysicalDeviceFeatures2, uintptr(physicalDevice), uintptr(unsafe.Pointer(pFeatures)))

	features = *(pFeatures.Goify())
	return
}

var GetPhysicalDeviceFeatures2KHR = GetPhysicalDeviceFeatures2

// GetPhysicalDeviceFormatProperties: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceFormatProperties.html
func GetPhysicalDeviceFormatProperties(physicalDevice PhysicalDevice, format Format) (formatProperties FormatProperties) {
	// formatProperties is a binding-allocated single return value and will be populated by Vulkan
	ptr_pFormatProperties := &formatProperties

	execTrampoline(keyvkGetPhysicalDeviceFormatProperties, uintptr(physicalDevice), uintptr(format), uintptr(unsafe.Pointer(ptr_pFormatProperties)))

	return
}

// GetPhysicalDeviceFormatProperties2: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceFormatProperties2.html
func GetPhysicalDeviceFormatProperties2(physicalDevice PhysicalDevice, format Format) (formatProperties FormatProperties2) {
	// formatProperties is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pFormatProperties *_vkFormatProperties2 = formatProperties.Vulkanize()

	execTrampoline(keyvkGetPhysicalDeviceFormatProperties2, uintptr(physicalDevice), uintptr(format), uintptr(unsafe.Pointer(pFormatProperties)))

	formatProperties = *(pFormatProperties.Goify())
	return
}

var GetPhysicalDeviceFormatProperties2KHR = GetPhysicalDeviceFormatProperties2

// GetPhysicalDeviceFragmentShadingRatesKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceFragmentShadingRatesKHR.html
func GetPhysicalDeviceFragmentShadingRatesKHR(physicalDevice PhysicalDevice) (r Result, fragmentShadingRates []PhysicalDeviceFragmentShadingRateKHR) {
	// fragmentShadingRates is a double-call array output
	var fragmentShadingRateCount uint32
	pFragmentShadingRateCount := &fragmentShadingRateCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pFragmentShadingRates *_vkPhysicalDeviceFragmentShadingRateKHR

	r = Result(execTrampoline(keyvkGetPhysicalDeviceFragmentShadingRatesKHR, uintptr(physicalDevice), uintptr(unsafe.Pointer(pFragmentShadingRateCount)), uintptr(unsafe.Pointer(pFragmentShadingRates))))

	sl_pFragmentShadingRates := make([]_vkPhysicalDeviceFragmentShadingRateKHR, fragmentShadingRateCount)
	fragmentShadingRates = make([]PhysicalDeviceFragmentShadingRateKHR, fragmentShadingRateCount)
	pFragmentShadingRates = &sl_pFragmentShadingRates[0]

	// Trampoline call after last array allocation
	r = Result(execTrampoline(keyvkGetPhysicalDeviceFragmentShadingRatesKHR, uintptr(physicalDevice), uintptr(unsafe.Pointer(pFragmentShadingRateCount)), uintptr(unsafe.Pointer(pFragmentShadingRates))))

	for i := range sl_pFragmentShadingRates {
		fragmentShadingRates[i] = *sl_pFragmentShadingRates[i].Goify()
	}
	return
}

// GetPhysicalDeviceImageFormatProperties: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceImageFormatProperties.html
func GetPhysicalDeviceImageFormatProperties(physicalDevice PhysicalDevice, format Format, typ ImageType, tiling ImageTiling, usage ImageUsageFlags, flags ImageCreateFlags) (r Result, imageFormatProperties ImageFormatProperties) {
	// imageFormatProperties is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pImageFormatProperties *_vkImageFormatProperties = imageFormatProperties.Vulkanize()

	r = Result(execTrampoline(keyvkGetPhysicalDeviceImageFormatProperties, uintptr(physicalDevice), uintptr(format), uintptr(typ), uintptr(tiling), uintptr(usage), uintptr(flags), uintptr(unsafe.Pointer(pImageFormatProperties))))

	imageFormatProperties = *(pImageFormatProperties.Goify())
	return
}

// GetPhysicalDeviceImageFormatProperties2: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceImageFormatProperties2.html
func GetPhysicalDeviceImageFormatProperties2(physicalDevice PhysicalDevice, imageFormatInfo *PhysicalDeviceImageFormatInfo2) (r Result, imageFormatProperties ImageFormatProperties2) {
	// Parameter is a singular input, requires translation - imageFormatInfo
	var pImageFormatInfo *_vkPhysicalDeviceImageFormatInfo2
	if imageFormatInfo != nil {
		pImageFormatInfo = imageFormatInfo.Vulkanize()
	}

	// imageFormatProperties is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pImageFormatProperties *_vkImageFormatProperties2 = imageFormatProperties.Vulkanize()

	r = Result(execTrampoline(keyvkGetPhysicalDeviceImageFormatProperties2, uintptr(physicalDevice), uintptr(unsafe.Pointer(pImageFormatInfo)), uintptr(unsafe.Pointer(pImageFormatProperties))))

	imageFormatProperties = *(pImageFormatProperties.Goify())
	return
}

var GetPhysicalDeviceImageFormatProperties2KHR = GetPhysicalDeviceImageFormatProperties2

// GetPhysicalDeviceMemoryProperties: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceMemoryProperties.html
func GetPhysicalDeviceMemoryProperties(physicalDevice PhysicalDevice) (memoryProperties PhysicalDeviceMemoryProperties) {
	// memoryProperties is a binding-allocated single return value and will be populated by Vulkan
	ptr_pMemoryProperties := &memoryProperties

	execTrampoline(keyvkGetPhysicalDeviceMemoryProperties, uintptr(physicalDevice), uintptr(unsafe.Pointer(ptr_pMemoryProperties)))

	return
}

// GetPhysicalDeviceMemoryProperties2: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceMemoryProperties2.html
func GetPhysicalDeviceMemoryProperties2(physicalDevice PhysicalDevice) (memoryProperties PhysicalDeviceMemoryProperties2) {
	// memoryProperties is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pMemoryProperties *_vkPhysicalDeviceMemoryProperties2 = memoryProperties.Vulkanize()

	execTrampoline(keyvkGetPhysicalDeviceMemoryProperties2, uintptr(physicalDevice), uintptr(unsafe.Pointer(pMemoryProperties)))

	memoryProperties = *(pMemoryProperties.Goify())
	return
}

var GetPhysicalDeviceMemoryProperties2KHR = GetPhysicalDeviceMemoryProperties2

// GetPhysicalDeviceMultisamplePropertiesEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceMultisamplePropertiesEXT.html
func GetPhysicalDeviceMultisamplePropertiesEXT(physicalDevice PhysicalDevice, samples SampleCountFlagBits) (multisampleProperties MultisamplePropertiesEXT) {
	// multisampleProperties is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pMultisampleProperties *_vkMultisamplePropertiesEXT = multisampleProperties.Vulkanize()

	execTrampoline(keyvkGetPhysicalDeviceMultisamplePropertiesEXT, uintptr(physicalDevice), uintptr(samples), uintptr(unsafe.Pointer(pMultisampleProperties)))

	multisampleProperties = *(pMultisampleProperties.Goify())
	return
}

// GetPhysicalDeviceOpticalFlowImageFormatsNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceOpticalFlowImageFormatsNV.html
func GetPhysicalDeviceOpticalFlowImageFormatsNV(physicalDevice PhysicalDevice, opticalFlowImageFormatInfo *OpticalFlowImageFormatInfoNV) (r Result, imageFormatProperties []OpticalFlowImageFormatPropertiesNV) {
	// Parameter is a singular input, requires translation - opticalFlowImageFormatInfo
	var pOpticalFlowImageFormatInfo *_vkOpticalFlowImageFormatInfoNV
	if opticalFlowImageFormatInfo != nil {
		pOpticalFlowImageFormatInfo = opticalFlowImageFormatInfo.Vulkanize()
	}

	// imageFormatProperties is a double-call array output
	var formatCount uint32
	pFormatCount := &formatCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pImageFormatProperties *_vkOpticalFlowImageFormatPropertiesNV

	r = Result(execTrampoline(keyvkGetPhysicalDeviceOpticalFlowImageFormatsNV, uintptr(physicalDevice), uintptr(unsafe.Pointer(pOpticalFlowImageFormatInfo)), uintptr(unsafe.Pointer(pFormatCount)), uintptr(unsafe.Pointer(pImageFormatProperties))))

	sl_pImageFormatProperties := make([]_vkOpticalFlowImageFormatPropertiesNV, formatCount)
	imageFormatProperties = make([]OpticalFlowImageFormatPropertiesNV, formatCount)
	pImageFormatProperties = &sl_pImageFormatProperties[0]

	// Trampoline call after last array allocation
	r = Result(execTrampoline(keyvkGetPhysicalDeviceOpticalFlowImageFormatsNV, uintptr(physicalDevice), uintptr(unsafe.Pointer(pOpticalFlowImageFormatInfo)), uintptr(unsafe.Pointer(pFormatCount)), uintptr(unsafe.Pointer(pImageFormatProperties))))

	for i := range sl_pImageFormatProperties {
		imageFormatProperties[i] = *sl_pImageFormatProperties[i].Goify()
	}
	return
}

// GetPhysicalDevicePresentRectanglesKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDevicePresentRectanglesKHR.html
func GetPhysicalDevicePresentRectanglesKHR(physicalDevice PhysicalDevice, surface SurfaceKHR) (r Result, rects []Rect2D) {
	// rects is a double-call array output
	var rectCount uint32
	pRectCount := &rectCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pRects *_vkRect2D

	r = Result(execTrampoline(keyvkGetPhysicalDevicePresentRectanglesKHR, uintptr(physicalDevice), uintptr(surface), uintptr(unsafe.Pointer(pRectCount)), uintptr(unsafe.Pointer(pRects))))

	sl_pRects := make([]_vkRect2D, rectCount)
	rects = make([]Rect2D, rectCount)
	pRects = &sl_pRects[0]

	// Trampoline call after last array allocation
	r = Result(execTrampoline(keyvkGetPhysicalDevicePresentRectanglesKHR, uintptr(physicalDevice), uintptr(surface), uintptr(unsafe.Pointer(pRectCount)), uintptr(unsafe.Pointer(pRects))))

	for i := range sl_pRects {
		rects[i] = *sl_pRects[i].Goify()
	}
	return
}

// GetPhysicalDeviceProperties: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceProperties.html
func GetPhysicalDeviceProperties(physicalDevice PhysicalDevice) (properties PhysicalDeviceProperties) {
	// properties is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pProperties *_vkPhysicalDeviceProperties = properties.Vulkanize()

	execTrampoline(keyvkGetPhysicalDeviceProperties, uintptr(physicalDevice), uintptr(unsafe.Pointer(pProperties)))

	properties = *(pProperties.Goify())
	return
}

// GetPhysicalDeviceProperties2: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceProperties2.html
func GetPhysicalDeviceProperties2(physicalDevice PhysicalDevice) (properties PhysicalDeviceProperties2) {
	// properties is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pProperties *_vkPhysicalDeviceProperties2 = properties.Vulkanize()

	execTrampoline(keyvkGetPhysicalDeviceProperties2, uintptr(physicalDevice), uintptr(unsafe.Pointer(pProperties)))

	properties = *(pProperties.Goify())
	return
}

var GetPhysicalDeviceProperties2KHR = GetPhysicalDeviceProperties2

// GetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR.html
func GetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR(physicalDevice PhysicalDevice, performanceQueryCreateInfo *QueryPoolPerformanceCreateInfoKHR) (numPasses uint32) {
	// Parameter is a singular input, requires translation - performanceQueryCreateInfo
	var pPerformanceQueryCreateInfo *_vkQueryPoolPerformanceCreateInfoKHR
	if performanceQueryCreateInfo != nil {
		pPerformanceQueryCreateInfo = performanceQueryCreateInfo.Vulkanize()
	}

	// numPasses is a binding-allocated single return value and will be populated by Vulkan
	ptr_pNumPasses := &numPasses

	execTrampoline(keyvkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR, uintptr(physicalDevice), uintptr(unsafe.Pointer(pPerformanceQueryCreateInfo)), uintptr(unsafe.Pointer(ptr_pNumPasses)))

	return
}

// GetPhysicalDeviceQueueFamilyProperties: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceQueueFamilyProperties.html
func GetPhysicalDeviceQueueFamilyProperties(physicalDevice PhysicalDevice) (queueFamilyProperties []QueueFamilyProperties) {
	// queueFamilyProperties is a double-call array output
	var queueFamilyPropertyCount uint32
	pQueueFamilyPropertyCount := &queueFamilyPropertyCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pQueueFamilyProperties *_vkQueueFamilyProperties

	execTrampoline(keyvkGetPhysicalDeviceQueueFamilyProperties, uintptr(physicalDevice), uintptr(unsafe.Pointer(pQueueFamilyPropertyCount)), uintptr(unsafe.Pointer(pQueueFamilyProperties)))

	sl_pQueueFamilyProperties := make([]_vkQueueFamilyProperties, queueFamilyPropertyCount)
	queueFamilyProperties = make([]QueueFamilyProperties, queueFamilyPropertyCount)
	pQueueFamilyProperties = &sl_pQueueFamilyProperties[0]

	// Trampoline call after last array allocation
	execTrampoline(keyvkGetPhysicalDeviceQueueFamilyProperties, uintptr(physicalDevice), uintptr(unsafe.Pointer(pQueueFamilyPropertyCount)), uintptr(unsafe.Pointer(pQueueFamilyProperties)))

	for i := range sl_pQueueFamilyProperties {
		queueFamilyProperties[i] = *sl_pQueueFamilyProperties[i].Goify()
	}
	return
}

// GetPhysicalDeviceQueueFamilyProperties2: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceQueueFamilyProperties2.html
func GetPhysicalDeviceQueueFamilyProperties2(physicalDevice PhysicalDevice) (queueFamilyProperties []QueueFamilyProperties2) {
	// queueFamilyProperties is a double-call array output
	var queueFamilyPropertyCount uint32
	pQueueFamilyPropertyCount := &queueFamilyPropertyCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pQueueFamilyProperties *_vkQueueFamilyProperties2

	execTrampoline(keyvkGetPhysicalDeviceQueueFamilyProperties2, uintptr(physicalDevice), uintptr(unsafe.Pointer(pQueueFamilyPropertyCount)), uintptr(unsafe.Pointer(pQueueFamilyProperties)))

	sl_pQueueFamilyProperties := make([]_vkQueueFamilyProperties2, queueFamilyPropertyCount)
	queueFamilyProperties = make([]QueueFamilyProperties2, queueFamilyPropertyCount)
	pQueueFamilyProperties = &sl_pQueueFamilyProperties[0]

	// Trampoline call after last array allocation
	execTrampoline(keyvkGetPhysicalDeviceQueueFamilyProperties2, uintptr(physicalDevice), uintptr(unsafe.Pointer(pQueueFamilyPropertyCount)), uintptr(unsafe.Pointer(pQueueFamilyProperties)))

	for i := range sl_pQueueFamilyProperties {
		queueFamilyProperties[i] = *sl_pQueueFamilyProperties[i].Goify()
	}
	return
}

var GetPhysicalDeviceQueueFamilyProperties2KHR = GetPhysicalDeviceQueueFamilyProperties2

// GetPhysicalDeviceSparseImageFormatProperties: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceSparseImageFormatProperties.html
func GetPhysicalDeviceSparseImageFormatProperties(physicalDevice PhysicalDevice, format Format, typ ImageType, samples SampleCountFlagBits, usage ImageUsageFlags, tiling ImageTiling) (properties []SparseImageFormatProperties) {
	// properties is a double-call array output
	var propertyCount uint32
	pPropertyCount := &propertyCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pProperties *_vkSparseImageFormatProperties

	execTrampoline(keyvkGetPhysicalDeviceSparseImageFormatProperties, uintptr(physicalDevice), uintptr(format), uintptr(typ), uintptr(samples), uintptr(usage), uintptr(tiling), uintptr(unsafe.Pointer(pPropertyCount)), uintptr(unsafe.Pointer(pProperties)))

	sl_pProperties := make([]_vkSparseImageFormatProperties, propertyCount)
	properties = make([]SparseImageFormatProperties, propertyCount)
	pProperties = &sl_pProperties[0]

	// Trampoline call after last array allocation
	execTrampoline(keyvkGetPhysicalDeviceSparseImageFormatProperties, uintptr(physicalDevice), uintptr(format), uintptr(typ), uintptr(samples), uintptr(usage), uintptr(tiling), uintptr(unsafe.Pointer(pPropertyCount)), uintptr(unsafe.Pointer(pProperties)))

	for i := range sl_pProperties {
		properties[i] = *sl_pProperties[i].Goify()
	}
	return
}

// GetPhysicalDeviceSparseImageFormatProperties2: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceSparseImageFormatProperties2.html
func GetPhysicalDeviceSparseImageFormatProperties2(physicalDevice PhysicalDevice, formatInfo *PhysicalDeviceSparseImageFormatInfo2) (properties []SparseImageFormatProperties2) {
	// Parameter is a singular input, requires translation - formatInfo
	var pFormatInfo *_vkPhysicalDeviceSparseImageFormatInfo2
	if formatInfo != nil {
		pFormatInfo = formatInfo.Vulkanize()
	}

	// properties is a double-call array output
	var propertyCount uint32
	pPropertyCount := &propertyCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pProperties *_vkSparseImageFormatProperties2

	execTrampoline(keyvkGetPhysicalDeviceSparseImageFormatProperties2, uintptr(physicalDevice), uintptr(unsafe.Pointer(pFormatInfo)), uintptr(unsafe.Pointer(pPropertyCount)), uintptr(unsafe.Pointer(pProperties)))

	sl_pProperties := make([]_vkSparseImageFormatProperties2, propertyCount)
	properties = make([]SparseImageFormatProperties2, propertyCount)
	pProperties = &sl_pProperties[0]

	// Trampoline call after last array allocation
	execTrampoline(keyvkGetPhysicalDeviceSparseImageFormatProperties2, uintptr(physicalDevice), uintptr(unsafe.Pointer(pFormatInfo)), uintptr(unsafe.Pointer(pPropertyCount)), uintptr(unsafe.Pointer(pProperties)))

	for i := range sl_pProperties {
		properties[i] = *sl_pProperties[i].Goify()
	}
	return
}

var GetPhysicalDeviceSparseImageFormatProperties2KHR = GetPhysicalDeviceSparseImageFormatProperties2

// GetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV.html
func GetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV(physicalDevice PhysicalDevice) (r Result, combinations []FramebufferMixedSamplesCombinationNV) {
	// combinations is a double-call array output
	var combinationCount uint32
	pCombinationCount := &combinationCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pCombinations *_vkFramebufferMixedSamplesCombinationNV

	r = Result(execTrampoline(keyvkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV, uintptr(physicalDevice), uintptr(unsafe.Pointer(pCombinationCount)), uintptr(unsafe.Pointer(pCombinations))))

	sl_pCombinations := make([]_vkFramebufferMixedSamplesCombinationNV, combinationCount)
	combinations = make([]FramebufferMixedSamplesCombinationNV, combinationCount)
	pCombinations = &sl_pCombinations[0]

	// Trampoline call after last array allocation
	r = Result(execTrampoline(keyvkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV, uintptr(physicalDevice), uintptr(unsafe.Pointer(pCombinationCount)), uintptr(unsafe.Pointer(pCombinations))))

	for i := range sl_pCombinations {
		combinations[i] = *sl_pCombinations[i].Goify()
	}
	return
}

// GetPhysicalDeviceSurfaceCapabilities2EXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceSurfaceCapabilities2EXT.html
func GetPhysicalDeviceSurfaceCapabilities2EXT(physicalDevice PhysicalDevice, surface SurfaceKHR) (r Result, surfaceCapabilities SurfaceCapabilities2EXT) {
	// surfaceCapabilities is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pSurfaceCapabilities *_vkSurfaceCapabilities2EXT = surfaceCapabilities.Vulkanize()

	r = Result(execTrampoline(keyvkGetPhysicalDeviceSurfaceCapabilities2EXT, uintptr(physicalDevice), uintptr(surface), uintptr(unsafe.Pointer(pSurfaceCapabilities))))

	surfaceCapabilities = *(pSurfaceCapabilities.Goify())
	return
}

// GetPhysicalDeviceSurfaceCapabilities2KHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceSurfaceCapabilities2KHR.html
func GetPhysicalDeviceSurfaceCapabilities2KHR(physicalDevice PhysicalDevice, surfaceInfo *PhysicalDeviceSurfaceInfo2KHR) (r Result, surfaceCapabilities SurfaceCapabilities2KHR) {
	// Parameter is a singular input, requires translation - surfaceInfo
	var pSurfaceInfo *_vkPhysicalDeviceSurfaceInfo2KHR
	if surfaceInfo != nil {
		pSurfaceInfo = surfaceInfo.Vulkanize()
	}

	// surfaceCapabilities is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pSurfaceCapabilities *_vkSurfaceCapabilities2KHR = surfaceCapabilities.Vulkanize()

	r = Result(execTrampoline(keyvkGetPhysicalDeviceSurfaceCapabilities2KHR, uintptr(physicalDevice), uintptr(unsafe.Pointer(pSurfaceInfo)), uintptr(unsafe.Pointer(pSurfaceCapabilities))))

	surfaceCapabilities = *(pSurfaceCapabilities.Goify())
	return
}

// GetPhysicalDeviceSurfaceCapabilitiesKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceSurfaceCapabilitiesKHR.html
func GetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice PhysicalDevice, surface SurfaceKHR) (r Result, surfaceCapabilities SurfaceCapabilitiesKHR) {
	// surfaceCapabilities is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pSurfaceCapabilities *_vkSurfaceCapabilitiesKHR = surfaceCapabilities.Vulkanize()

	r = Result(execTrampoline(keyvkGetPhysicalDeviceSurfaceCapabilitiesKHR, uintptr(physicalDevice), uintptr(surface), uintptr(unsafe.Pointer(pSurfaceCapabilities))))

	surfaceCapabilities = *(pSurfaceCapabilities.Goify())
	return
}

// GetPhysicalDeviceSurfaceFormats2KHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceSurfaceFormats2KHR.html
func GetPhysicalDeviceSurfaceFormats2KHR(physicalDevice PhysicalDevice, surfaceInfo *PhysicalDeviceSurfaceInfo2KHR) (r Result, surfaceFormats []SurfaceFormat2KHR) {
	// Parameter is a singular input, requires translation - surfaceInfo
	var pSurfaceInfo *_vkPhysicalDeviceSurfaceInfo2KHR
	if surfaceInfo != nil {
		pSurfaceInfo = surfaceInfo.Vulkanize()
	}

	// surfaceFormats is a double-call array output
	var surfaceFormatCount uint32
	pSurfaceFormatCount := &surfaceFormatCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pSurfaceFormats *_vkSurfaceFormat2KHR

	r = Result(execTrampoline(keyvkGetPhysicalDeviceSurfaceFormats2KHR, uintptr(physicalDevice), uintptr(unsafe.Pointer(pSurfaceInfo)), uintptr(unsafe.Pointer(pSurfaceFormatCount)), uintptr(unsafe.Pointer(pSurfaceFormats))))

	sl_pSurfaceFormats := make([]_vkSurfaceFormat2KHR, surfaceFormatCount)
	surfaceFormats = make([]SurfaceFormat2KHR, surfaceFormatCount)
	pSurfaceFormats = &sl_pSurfaceFormats[0]

	// Trampoline call after last array allocation
	r = Result(execTrampoline(keyvkGetPhysicalDeviceSurfaceFormats2KHR, uintptr(physicalDevice), uintptr(unsafe.Pointer(pSurfaceInfo)), uintptr(unsafe.Pointer(pSurfaceFormatCount)), uintptr(unsafe.Pointer(pSurfaceFormats))))

	for i := range sl_pSurfaceFormats {
		surfaceFormats[i] = *sl_pSurfaceFormats[i].Goify()
	}
	return
}

// GetPhysicalDeviceSurfaceFormatsKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceSurfaceFormatsKHR.html
func GetPhysicalDeviceSurfaceFormatsKHR(physicalDevice PhysicalDevice, surface SurfaceKHR) (r Result, surfaceFormats []SurfaceFormatKHR) {
	// surfaceFormats is a double-call array output
	var surfaceFormatCount uint32
	pSurfaceFormatCount := &surfaceFormatCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pSurfaceFormats *_vkSurfaceFormatKHR

	r = Result(execTrampoline(keyvkGetPhysicalDeviceSurfaceFormatsKHR, uintptr(physicalDevice), uintptr(surface), uintptr(unsafe.Pointer(pSurfaceFormatCount)), uintptr(unsafe.Pointer(pSurfaceFormats))))

	sl_pSurfaceFormats := make([]_vkSurfaceFormatKHR, surfaceFormatCount)
	surfaceFormats = make([]SurfaceFormatKHR, surfaceFormatCount)
	pSurfaceFormats = &sl_pSurfaceFormats[0]

	// Trampoline call after last array allocation
	r = Result(execTrampoline(keyvkGetPhysicalDeviceSurfaceFormatsKHR, uintptr(physicalDevice), uintptr(surface), uintptr(unsafe.Pointer(pSurfaceFormatCount)), uintptr(unsafe.Pointer(pSurfaceFormats))))

	for i := range sl_pSurfaceFormats {
		surfaceFormats[i] = *sl_pSurfaceFormats[i].Goify()
	}
	return
}

// GetPhysicalDeviceSurfacePresentModesKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceSurfacePresentModesKHR.html
func GetPhysicalDeviceSurfacePresentModesKHR(physicalDevice PhysicalDevice, surface SurfaceKHR) (r Result, presentModes []PresentModeKHR) {
	// presentModes is a double-call array output
	var presentModeCount uint32
	pPresentModeCount := &presentModeCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pPresentModes *PresentModeKHR

	r = Result(execTrampoline(keyvkGetPhysicalDeviceSurfacePresentModesKHR, uintptr(physicalDevice), uintptr(surface), uintptr(unsafe.Pointer(pPresentModeCount)), uintptr(unsafe.Pointer(pPresentModes))))

	sl_pPresentModes := make([]PresentModeKHR, presentModeCount)
	presentModes = make([]PresentModeKHR, presentModeCount)
	pPresentModes = &sl_pPresentModes[0]

	// Trampoline call after last array allocation
	r = Result(execTrampoline(keyvkGetPhysicalDeviceSurfacePresentModesKHR, uintptr(physicalDevice), uintptr(surface), uintptr(unsafe.Pointer(pPresentModeCount)), uintptr(unsafe.Pointer(pPresentModes))))

	for i := range sl_pPresentModes {
		presentModes[i] = *&sl_pPresentModes[i]
	}
	return
}

// GetPhysicalDeviceSurfaceSupportKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceSurfaceSupportKHR.html
func GetPhysicalDeviceSurfaceSupportKHR(physicalDevice PhysicalDevice, queueFamilyIndex uint32, surface SurfaceKHR) (r Result, supported bool) {
	// supported is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var internal_supported Bool32 = translateInternal_Bool32(supported)
	var pSupported = &internal_supported

	r = Result(execTrampoline(keyvkGetPhysicalDeviceSurfaceSupportKHR, uintptr(physicalDevice), uintptr(queueFamilyIndex), uintptr(surface), uintptr(unsafe.Pointer(pSupported))))

	supported = translatePublic_Bool32(internal_supported)
	return
}

// GetPhysicalDeviceToolProperties: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceToolProperties.html
func GetPhysicalDeviceToolProperties(physicalDevice PhysicalDevice) (r Result, toolProperties []PhysicalDeviceToolProperties) {
	// toolProperties is a double-call array output
	var toolCount uint32
	pToolCount := &toolCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pToolProperties *_vkPhysicalDeviceToolProperties

	r = Result(execTrampoline(keyvkGetPhysicalDeviceToolProperties, uintptr(physicalDevice), uintptr(unsafe.Pointer(pToolCount)), uintptr(unsafe.Pointer(pToolProperties))))

	sl_pToolProperties := make([]_vkPhysicalDeviceToolProperties, toolCount)
	toolProperties = make([]PhysicalDeviceToolProperties, toolCount)
	pToolProperties = &sl_pToolProperties[0]

	// Trampoline call after last array allocation
	r = Result(execTrampoline(keyvkGetPhysicalDeviceToolProperties, uintptr(physicalDevice), uintptr(unsafe.Pointer(pToolCount)), uintptr(unsafe.Pointer(pToolProperties))))

	for i := range sl_pToolProperties {
		toolProperties[i] = *sl_pToolProperties[i].Goify()
	}
	return
}

var GetPhysicalDeviceToolPropertiesEXT = GetPhysicalDeviceToolProperties

// GetPhysicalDeviceVideoCapabilitiesKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceVideoCapabilitiesKHR.html
func GetPhysicalDeviceVideoCapabilitiesKHR(physicalDevice PhysicalDevice, videoProfile *VideoProfileInfoKHR) (r Result, capabilities VideoCapabilitiesKHR) {
	// Parameter is a singular input, requires translation - videoProfile
	var pVideoProfile *_vkVideoProfileInfoKHR
	if videoProfile != nil {
		pVideoProfile = videoProfile.Vulkanize()
	}

	// capabilities is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pCapabilities *_vkVideoCapabilitiesKHR = capabilities.Vulkanize()

	r = Result(execTrampoline(keyvkGetPhysicalDeviceVideoCapabilitiesKHR, uintptr(physicalDevice), uintptr(unsafe.Pointer(pVideoProfile)), uintptr(unsafe.Pointer(pCapabilities))))

	capabilities = *(pCapabilities.Goify())
	return
}

// GetPhysicalDeviceVideoFormatPropertiesKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceVideoFormatPropertiesKHR.html
func GetPhysicalDeviceVideoFormatPropertiesKHR(physicalDevice PhysicalDevice, videoFormatInfo *PhysicalDeviceVideoFormatInfoKHR) (r Result, videoFormatProperties []VideoFormatPropertiesKHR) {
	// Parameter is a singular input, requires translation - videoFormatInfo
	var pVideoFormatInfo *_vkPhysicalDeviceVideoFormatInfoKHR
	if videoFormatInfo != nil {
		pVideoFormatInfo = videoFormatInfo.Vulkanize()
	}

	// videoFormatProperties is a double-call array output
	var videoFormatPropertyCount uint32
	pVideoFormatPropertyCount := &videoFormatPropertyCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pVideoFormatProperties *_vkVideoFormatPropertiesKHR

	r = Result(execTrampoline(keyvkGetPhysicalDeviceVideoFormatPropertiesKHR, uintptr(physicalDevice), uintptr(unsafe.Pointer(pVideoFormatInfo)), uintptr(unsafe.Pointer(pVideoFormatPropertyCount)), uintptr(unsafe.Pointer(pVideoFormatProperties))))

	sl_pVideoFormatProperties := make([]_vkVideoFormatPropertiesKHR, videoFormatPropertyCount)
	videoFormatProperties = make([]VideoFormatPropertiesKHR, videoFormatPropertyCount)
	pVideoFormatProperties = &sl_pVideoFormatProperties[0]

	// Trampoline call after last array allocation
	r = Result(execTrampoline(keyvkGetPhysicalDeviceVideoFormatPropertiesKHR, uintptr(physicalDevice), uintptr(unsafe.Pointer(pVideoFormatInfo)), uintptr(unsafe.Pointer(pVideoFormatPropertyCount)), uintptr(unsafe.Pointer(pVideoFormatProperties))))

	for i := range sl_pVideoFormatProperties {
		videoFormatProperties[i] = *sl_pVideoFormatProperties[i].Goify()
	}
	return
}

// GetPipelineCacheData: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPipelineCacheData.html
func GetPipelineCacheData(device Device, pipelineCache PipelineCache) (r Result, data []byte) {
	// data is a double-call array output
	var dataSize uintptr
	pDataSize := &dataSize
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pData *byte

	r = Result(execTrampoline(keyvkGetPipelineCacheData, uintptr(device), uintptr(pipelineCache), uintptr(unsafe.Pointer(pDataSize)), uintptr(unsafe.Pointer(pData))))

	sl_pData := make([]byte, dataSize)
	data = make([]byte, dataSize)
	pData = &sl_pData[0]

	// Trampoline call after last array allocation
	r = Result(execTrampoline(keyvkGetPipelineCacheData, uintptr(device), uintptr(pipelineCache), uintptr(unsafe.Pointer(pDataSize)), uintptr(unsafe.Pointer(pData))))

	for i := range sl_pData {
		data[i] = *&sl_pData[i]
	}
	return
}

// GetPipelineExecutableInternalRepresentationsKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPipelineExecutableInternalRepresentationsKHR.html
func GetPipelineExecutableInternalRepresentationsKHR(device Device, executableInfo *PipelineExecutableInfoKHR) (r Result, internalRepresentations []PipelineExecutableInternalRepresentationKHR) {
	// Parameter is a singular input, requires translation - executableInfo
	var pExecutableInfo *_vkPipelineExecutableInfoKHR
	if executableInfo != nil {
		pExecutableInfo = executableInfo.Vulkanize()
	}

	// internalRepresentations is a double-call array output
	var internalRepresentationCount uint32
	pInternalRepresentationCount := &internalRepresentationCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pInternalRepresentations *_vkPipelineExecutableInternalRepresentationKHR

	r = Result(execTrampoline(keyvkGetPipelineExecutableInternalRepresentationsKHR, uintptr(device), uintptr(unsafe.Pointer(pExecutableInfo)), uintptr(unsafe.Pointer(pInternalRepresentationCount)), uintptr(unsafe.Pointer(pInternalRepresentations))))

	sl_pInternalRepresentations := make([]_vkPipelineExecutableInternalRepresentationKHR, internalRepresentationCount)
	internalRepresentations = make([]PipelineExecutableInternalRepresentationKHR, internalRepresentationCount)
	pInternalRepresentations = &sl_pInternalRepresentations[0]

	// Trampoline call after last array allocation
	r = Result(execTrampoline(keyvkGetPipelineExecutableInternalRepresentationsKHR, uintptr(device), uintptr(unsafe.Pointer(pExecutableInfo)), uintptr(unsafe.Pointer(pInternalRepresentationCount)), uintptr(unsafe.Pointer(pInternalRepresentations))))

	for i := range sl_pInternalRepresentations {
		internalRepresentations[i] = *sl_pInternalRepresentations[i].Goify()
	}
	return
}

// GetPipelineExecutablePropertiesKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPipelineExecutablePropertiesKHR.html
func GetPipelineExecutablePropertiesKHR(device Device, pipelineInfo *PipelineInfoKHR) (r Result, properties []PipelineExecutablePropertiesKHR) {
	// Parameter is a singular input, requires translation - pipelineInfo
	var pPipelineInfo *_vkPipelineInfoKHR
	if pipelineInfo != nil {
		pPipelineInfo = pipelineInfo.Vulkanize()
	}

	// properties is a double-call array output
	var executableCount uint32
	pExecutableCount := &executableCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pProperties *_vkPipelineExecutablePropertiesKHR

	r = Result(execTrampoline(keyvkGetPipelineExecutablePropertiesKHR, uintptr(device), uintptr(unsafe.Pointer(pPipelineInfo)), uintptr(unsafe.Pointer(pExecutableCount)), uintptr(unsafe.Pointer(pProperties))))

	sl_pProperties := make([]_vkPipelineExecutablePropertiesKHR, executableCount)
	properties = make([]PipelineExecutablePropertiesKHR, executableCount)
	pProperties = &sl_pProperties[0]

	// Trampoline call after last array allocation
	r = Result(execTrampoline(keyvkGetPipelineExecutablePropertiesKHR, uintptr(device), uintptr(unsafe.Pointer(pPipelineInfo)), uintptr(unsafe.Pointer(pExecutableCount)), uintptr(unsafe.Pointer(pProperties))))

	for i := range sl_pProperties {
		properties[i] = *sl_pProperties[i].Goify()
	}
	return
}

// GetPipelineExecutableStatisticsKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPipelineExecutableStatisticsKHR.html
func GetPipelineExecutableStatisticsKHR(device Device, executableInfo *PipelineExecutableInfoKHR) (r Result, statistics []PipelineExecutableStatisticKHR) {
	// Parameter is a singular input, requires translation - executableInfo
	var pExecutableInfo *_vkPipelineExecutableInfoKHR
	if executableInfo != nil {
		pExecutableInfo = executableInfo.Vulkanize()
	}

	// statistics is a double-call array output
	var statisticCount uint32
	pStatisticCount := &statisticCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pStatistics *_vkPipelineExecutableStatisticKHR

	r = Result(execTrampoline(keyvkGetPipelineExecutableStatisticsKHR, uintptr(device), uintptr(unsafe.Pointer(pExecutableInfo)), uintptr(unsafe.Pointer(pStatisticCount)), uintptr(unsafe.Pointer(pStatistics))))

	sl_pStatistics := make([]_vkPipelineExecutableStatisticKHR, statisticCount)
	statistics = make([]PipelineExecutableStatisticKHR, statisticCount)
	pStatistics = &sl_pStatistics[0]

	// Trampoline call after last array allocation
	r = Result(execTrampoline(keyvkGetPipelineExecutableStatisticsKHR, uintptr(device), uintptr(unsafe.Pointer(pExecutableInfo)), uintptr(unsafe.Pointer(pStatisticCount)), uintptr(unsafe.Pointer(pStatistics))))

	for i := range sl_pStatistics {
		statistics[i] = *sl_pStatistics[i].Goify()
	}
	return
}

// GetPipelinePropertiesEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPipelinePropertiesEXT.html
func GetPipelinePropertiesEXT(device Device, pipelineInfo *PipelineInfoEXT) (r Result, pipelineProperties BaseOutStructure) {
	// Parameter is a singular input, pass direct - pipelineInfo
	var pPipelineInfo unsafe.Pointer
	if pipelineInfo != nil {
		pPipelineInfo = unsafe.Pointer(pipelineInfo)
	}

	// pipelineProperties is a binding-allocated single return value and will be populated by Vulkan
	ptr_pPipelineProperties := &pipelineProperties

	r = Result(execTrampoline(keyvkGetPipelinePropertiesEXT, uintptr(device), uintptr(unsafe.Pointer(pPipelineInfo)), uintptr(unsafe.Pointer(ptr_pPipelineProperties))))

	return
}

// GetPrivateData: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPrivateData.html
func GetPrivateData(device Device, objectType ObjectType, objectHandle uint64, privateDataSlot PrivateDataSlot) (data uint64) {
	// data is a binding-allocated single return value and will be populated by Vulkan
	ptr_pData := &data

	execTrampoline(keyvkGetPrivateData, uintptr(device), uintptr(objectType), uintptr(objectHandle), uintptr(privateDataSlot), uintptr(unsafe.Pointer(ptr_pData)))

	return
}

var GetPrivateDataEXT = GetPrivateData

// GetQueryPoolResults: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetQueryPoolResults.html
func GetQueryPoolResults(device Device, queryPool QueryPool, firstQuery uint32, queryCount uint32, data []byte, stride DeviceSize, flags QueryResultFlags) (r Result) {
	dataSize := len(data)
	// data is a user-allocated array input that will be written to
	pData := unsafe.Pointer(&data[0])

	r = Result(execTrampoline(keyvkGetQueryPoolResults, uintptr(device), uintptr(queryPool), uintptr(firstQuery), uintptr(queryCount), uintptr(dataSize), uintptr(unsafe.Pointer(pData)), uintptr(stride), uintptr(flags)))

	return
}

// GetQueueCheckpointData2NV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetQueueCheckpointData2NV.html
func GetQueueCheckpointData2NV(queue Queue) (checkpointData []CheckpointData2NV) {
	// checkpointData is a double-call array output
	var checkpointDataCount uint32
	pCheckpointDataCount := &checkpointDataCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pCheckpointData *_vkCheckpointData2NV

	execTrampoline(keyvkGetQueueCheckpointData2NV, uintptr(queue), uintptr(unsafe.Pointer(pCheckpointDataCount)), uintptr(unsafe.Pointer(pCheckpointData)))

	sl_pCheckpointData := make([]_vkCheckpointData2NV, checkpointDataCount)
	checkpointData = make([]CheckpointData2NV, checkpointDataCount)
	pCheckpointData = &sl_pCheckpointData[0]

	// Trampoline call after last array allocation
	execTrampoline(keyvkGetQueueCheckpointData2NV, uintptr(queue), uintptr(unsafe.Pointer(pCheckpointDataCount)), uintptr(unsafe.Pointer(pCheckpointData)))

	for i := range sl_pCheckpointData {
		checkpointData[i] = *sl_pCheckpointData[i].Goify()
	}
	return
}

// GetQueueCheckpointDataNV: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetQueueCheckpointDataNV.html
func GetQueueCheckpointDataNV(queue Queue) (checkpointData []CheckpointDataNV) {
	// checkpointData is a double-call array output
	var checkpointDataCount uint32
	pCheckpointDataCount := &checkpointDataCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pCheckpointData *_vkCheckpointDataNV

	execTrampoline(keyvkGetQueueCheckpointDataNV, uintptr(queue), uintptr(unsafe.Pointer(pCheckpointDataCount)), uintptr(unsafe.Pointer(pCheckpointData)))

	sl_pCheckpointData := make([]_vkCheckpointDataNV, checkpointDataCount)
	checkpointData = make([]CheckpointDataNV, checkpointDataCount)
	pCheckpointData = &sl_pCheckpointData[0]

	// Trampoline call after last array allocation
	execTrampoline(keyvkGetQueueCheckpointDataNV, uintptr(queue), uintptr(unsafe.Pointer(pCheckpointDataCount)), uintptr(unsafe.Pointer(pCheckpointData)))

	for i := range sl_pCheckpointData {
		checkpointData[i] = *sl_pCheckpointData[i].Goify()
	}
	return
}

// GetRayTracingCaptureReplayShaderGroupHandlesKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetRayTracingCaptureReplayShaderGroupHandlesKHR.html
func GetRayTracingCaptureReplayShaderGroupHandlesKHR(device Device, pipeline Pipeline, firstGroup uint32, groupCount uint32, data []byte) (r Result) {
	dataSize := len(data)
	// data is a user-allocated array input that will be written to
	pData := unsafe.Pointer(&data[0])

	r = Result(execTrampoline(keyvkGetRayTracingCaptureReplayShaderGroupHandlesKHR, uintptr(device), uintptr(pipeline), uintptr(firstGroup), uintptr(groupCount), uintptr(dataSize), uintptr(unsafe.Pointer(pData))))

	return
}

// GetRayTracingShaderGroupHandlesKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetRayTracingShaderGroupHandlesKHR.html
func GetRayTracingShaderGroupHandlesKHR(device Device, pipeline Pipeline, firstGroup uint32, groupCount uint32, data []byte) (r Result) {
	dataSize := len(data)
	// data is a user-allocated array input that will be written to
	pData := unsafe.Pointer(&data[0])

	r = Result(execTrampoline(keyvkGetRayTracingShaderGroupHandlesKHR, uintptr(device), uintptr(pipeline), uintptr(firstGroup), uintptr(groupCount), uintptr(dataSize), uintptr(unsafe.Pointer(pData))))

	return
}

var GetRayTracingShaderGroupHandlesNV = GetRayTracingShaderGroupHandlesKHR

// GetRayTracingShaderGroupStackSizeKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetRayTracingShaderGroupStackSizeKHR.html
func GetRayTracingShaderGroupStackSizeKHR(device Device, pipeline Pipeline, group uint32, groupShader ShaderGroupShaderKHR) (deviceSize DeviceSize) {

	deviceSize = DeviceSize(execTrampoline(keyvkGetRayTracingShaderGroupStackSizeKHR, uintptr(device), uintptr(pipeline), uintptr(group), uintptr(groupShader)))

	return
}

// GetRefreshCycleDurationGOOGLE: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetRefreshCycleDurationGOOGLE.html
func GetRefreshCycleDurationGOOGLE(device Device, swapchain SwapchainKHR) (r Result, displayTimingProperties RefreshCycleDurationGOOGLE) {
	// displayTimingProperties is a binding-allocated single return value and will be populated by Vulkan
	ptr_pDisplayTimingProperties := &displayTimingProperties

	r = Result(execTrampoline(keyvkGetRefreshCycleDurationGOOGLE, uintptr(device), uintptr(swapchain), uintptr(unsafe.Pointer(ptr_pDisplayTimingProperties))))

	return
}

// GetRenderAreaGranularity: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetRenderAreaGranularity.html
func GetRenderAreaGranularity(device Device, renderPass RenderPass) (granularity Extent2D) {
	// granularity is a binding-allocated single return value and will be populated by Vulkan
	ptr_pGranularity := &granularity

	execTrampoline(keyvkGetRenderAreaGranularity, uintptr(device), uintptr(renderPass), uintptr(unsafe.Pointer(ptr_pGranularity)))

	return
}

// GetSamplerOpaqueCaptureDescriptorDataEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetSamplerOpaqueCaptureDescriptorDataEXT.html
func GetSamplerOpaqueCaptureDescriptorDataEXT(device Device, info *SamplerCaptureDescriptorDataInfoEXT) (r Result, data byte) {
	// Parameter is a singular input, requires translation - info
	var pInfo *_vkSamplerCaptureDescriptorDataInfoEXT
	if info != nil {
		pInfo = info.Vulkanize()
	}

	// data is a binding-allocated single return value and will be populated by Vulkan
	ptr_pData := &data

	r = Result(execTrampoline(keyvkGetSamplerOpaqueCaptureDescriptorDataEXT, uintptr(device), uintptr(unsafe.Pointer(pInfo)), uintptr(unsafe.Pointer(ptr_pData))))

	return
}

// GetSemaphoreCounterValue: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetSemaphoreCounterValue.html
func GetSemaphoreCounterValue(device Device, semaphore Semaphore) (r Result, value uint64) {
	// value is a binding-allocated single return value and will be populated by Vulkan
	ptr_pValue := &value

	r = Result(execTrampoline(keyvkGetSemaphoreCounterValue, uintptr(device), uintptr(semaphore), uintptr(unsafe.Pointer(ptr_pValue))))

	return
}

var GetSemaphoreCounterValueKHR = GetSemaphoreCounterValue

// GetSemaphoreFdKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetSemaphoreFdKHR.html
func GetSemaphoreFdKHR(device Device, getFdInfo *SemaphoreGetFdInfoKHR) (r Result, fd int32) {
	// Parameter is a singular input, requires translation - getFdInfo
	var pGetFdInfo *_vkSemaphoreGetFdInfoKHR
	if getFdInfo != nil {
		pGetFdInfo = getFdInfo.Vulkanize()
	}

	// fd is a binding-allocated single return value and will be populated by Vulkan
	ptr_pFd := &fd

	r = Result(execTrampoline(keyvkGetSemaphoreFdKHR, uintptr(device), uintptr(unsafe.Pointer(pGetFdInfo)), uintptr(unsafe.Pointer(ptr_pFd))))

	return
}

// GetShaderInfoAMD: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetShaderInfoAMD.html
func GetShaderInfoAMD(device Device, pipeline Pipeline, shaderStage ShaderStageFlagBits, infoType ShaderInfoTypeAMD) (r Result, info []byte) {
	// info is a double-call array output
	var infoSize uintptr
	pInfoSize := &infoSize
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pInfo *byte

	r = Result(execTrampoline(keyvkGetShaderInfoAMD, uintptr(device), uintptr(pipeline), uintptr(shaderStage), uintptr(infoType), uintptr(unsafe.Pointer(pInfoSize)), uintptr(unsafe.Pointer(pInfo))))

	sl_pInfo := make([]byte, infoSize)
	info = make([]byte, infoSize)
	pInfo = &sl_pInfo[0]

	// Trampoline call after last array allocation
	r = Result(execTrampoline(keyvkGetShaderInfoAMD, uintptr(device), uintptr(pipeline), uintptr(shaderStage), uintptr(infoType), uintptr(unsafe.Pointer(pInfoSize)), uintptr(unsafe.Pointer(pInfo))))

	for i := range sl_pInfo {
		info[i] = *&sl_pInfo[i]
	}
	return
}

// GetShaderModuleCreateInfoIdentifierEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetShaderModuleCreateInfoIdentifierEXT.html
func GetShaderModuleCreateInfoIdentifierEXT(device Device, createInfo *ShaderModuleCreateInfo) (identifier ShaderModuleIdentifierEXT) {
	// Parameter is a singular input, requires translation - createInfo
	var pCreateInfo *_vkShaderModuleCreateInfo
	if createInfo != nil {
		pCreateInfo = createInfo.Vulkanize()
	}

	// identifier is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pIdentifier *_vkShaderModuleIdentifierEXT = identifier.Vulkanize()

	execTrampoline(keyvkGetShaderModuleCreateInfoIdentifierEXT, uintptr(device), uintptr(unsafe.Pointer(pCreateInfo)), uintptr(unsafe.Pointer(pIdentifier)))

	identifier = *(pIdentifier.Goify())
	return
}

// GetShaderModuleIdentifierEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetShaderModuleIdentifierEXT.html
func GetShaderModuleIdentifierEXT(device Device, shaderModule ShaderModule) (identifier ShaderModuleIdentifierEXT) {
	// identifier is a binding-allocated single return value and will be populated by Vulkan, but requiring translation
	var pIdentifier *_vkShaderModuleIdentifierEXT = identifier.Vulkanize()

	execTrampoline(keyvkGetShaderModuleIdentifierEXT, uintptr(device), uintptr(shaderModule), uintptr(unsafe.Pointer(pIdentifier)))

	identifier = *(pIdentifier.Goify())
	return
}

// GetSwapchainCounterEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetSwapchainCounterEXT.html
func GetSwapchainCounterEXT(device Device, swapchain SwapchainKHR, counter SurfaceCounterFlagBitsEXT) (r Result, counterValue uint64) {
	// counterValue is a binding-allocated single return value and will be populated by Vulkan
	ptr_pCounterValue := &counterValue

	r = Result(execTrampoline(keyvkGetSwapchainCounterEXT, uintptr(device), uintptr(swapchain), uintptr(counter), uintptr(unsafe.Pointer(ptr_pCounterValue))))

	return
}

// GetSwapchainImagesKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetSwapchainImagesKHR.html
func GetSwapchainImagesKHR(device Device, swapchain SwapchainKHR) (r Result, swapchainImages []Image) {
	// swapchainImages is a double-call array output
	var swapchainImageCount uint32
	pSwapchainImageCount := &swapchainImageCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pSwapchainImages *Image

	r = Result(execTrampoline(keyvkGetSwapchainImagesKHR, uintptr(device), uintptr(swapchain), uintptr(unsafe.Pointer(pSwapchainImageCount)), uintptr(unsafe.Pointer(pSwapchainImages))))

	sl_pSwapchainImages := make([]Image, swapchainImageCount)
	swapchainImages = make([]Image, swapchainImageCount)
	pSwapchainImages = &sl_pSwapchainImages[0]

	// Trampoline call after last array allocation
	r = Result(execTrampoline(keyvkGetSwapchainImagesKHR, uintptr(device), uintptr(swapchain), uintptr(unsafe.Pointer(pSwapchainImageCount)), uintptr(unsafe.Pointer(pSwapchainImages))))

	for i := range sl_pSwapchainImages {
		swapchainImages[i] = *&sl_pSwapchainImages[i]
	}
	return
}

// GetSwapchainStatusKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetSwapchainStatusKHR.html
func GetSwapchainStatusKHR(device Device, swapchain SwapchainKHR) (r Result) {

	r = Result(execTrampoline(keyvkGetSwapchainStatusKHR, uintptr(device), uintptr(swapchain)))

	return
}

// GetValidationCacheDataEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetValidationCacheDataEXT.html
func GetValidationCacheDataEXT(device Device, validationCache ValidationCacheEXT) (r Result, data []byte) {
	// data is a double-call array output
	var dataSize uintptr
	pDataSize := &dataSize
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pData *byte

	r = Result(execTrampoline(keyvkGetValidationCacheDataEXT, uintptr(device), uintptr(validationCache), uintptr(unsafe.Pointer(pDataSize)), uintptr(unsafe.Pointer(pData))))

	sl_pData := make([]byte, dataSize)
	data = make([]byte, dataSize)
	pData = &sl_pData[0]

	// Trampoline call after last array allocation
	r = Result(execTrampoline(keyvkGetValidationCacheDataEXT, uintptr(device), uintptr(validationCache), uintptr(unsafe.Pointer(pDataSize)), uintptr(unsafe.Pointer(pData))))

	for i := range sl_pData {
		data[i] = *&sl_pData[i]
	}
	return
}

// GetVideoSessionMemoryRequirementsKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetVideoSessionMemoryRequirementsKHR.html
func GetVideoSessionMemoryRequirementsKHR(device Device, videoSession VideoSessionKHR) (r Result, memoryRequirements []VideoSessionMemoryRequirementsKHR) {
	// memoryRequirements is a double-call array output
	var memoryRequirementsCount uint32
	pMemoryRequirementsCount := &memoryRequirementsCount
	// first trampoline happens here; also, still need to check returned Result value
	// NOT identical internal and external, result needs translation
	var pMemoryRequirements *_vkVideoSessionMemoryRequirementsKHR

	r = Result(execTrampoline(keyvkGetVideoSessionMemoryRequirementsKHR, uintptr(device), uintptr(videoSession), uintptr(unsafe.Pointer(pMemoryRequirementsCount)), uintptr(unsafe.Pointer(pMemoryRequirements))))

	sl_pMemoryRequirements := make([]_vkVideoSessionMemoryRequirementsKHR, memoryRequirementsCount)
	memoryRequirements = make([]VideoSessionMemoryRequirementsKHR, memoryRequirementsCount)
	pMemoryRequirements = &sl_pMemoryRequirements[0]

	// Trampoline call after last array allocation
	r = Result(execTrampoline(keyvkGetVideoSessionMemoryRequirementsKHR, uintptr(device), uintptr(videoSession), uintptr(unsafe.Pointer(pMemoryRequirementsCount)), uintptr(unsafe.Pointer(pMemoryRequirements))))

	for i := range sl_pMemoryRequirements {
		memoryRequirements[i] = *sl_pMemoryRequirements[i].Goify()
	}
	return
}

// ImportFenceFdKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkImportFenceFdKHR.html
func ImportFenceFdKHR(device Device, importFenceFdInfo *ImportFenceFdInfoKHR) (r Result) {
	// Parameter is a singular input, requires translation - importFenceFdInfo
	var pImportFenceFdInfo *_vkImportFenceFdInfoKHR
	if importFenceFdInfo != nil {
		pImportFenceFdInfo = importFenceFdInfo.Vulkanize()
	}

	r = Result(execTrampoline(keyvkImportFenceFdKHR, uintptr(device), uintptr(unsafe.Pointer(pImportFenceFdInfo))))

	return
}

// ImportSemaphoreFdKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkImportSemaphoreFdKHR.html
func ImportSemaphoreFdKHR(device Device, importSemaphoreFdInfo *ImportSemaphoreFdInfoKHR) (r Result) {
	// Parameter is a singular input, requires translation - importSemaphoreFdInfo
	var pImportSemaphoreFdInfo *_vkImportSemaphoreFdInfoKHR
	if importSemaphoreFdInfo != nil {
		pImportSemaphoreFdInfo = importSemaphoreFdInfo.Vulkanize()
	}

	r = Result(execTrampoline(keyvkImportSemaphoreFdKHR, uintptr(device), uintptr(unsafe.Pointer(pImportSemaphoreFdInfo))))

	return
}

// InitializePerformanceApiINTEL: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkInitializePerformanceApiINTEL.html
func InitializePerformanceApiINTEL(device Device, initializeInfo *InitializePerformanceApiInfoINTEL) (r Result) {
	// Parameter is a singular input, requires translation - initializeInfo
	var pInitializeInfo *_vkInitializePerformanceApiInfoINTEL
	if initializeInfo != nil {
		pInitializeInfo = initializeInfo.Vulkanize()
	}

	r = Result(execTrampoline(keyvkInitializePerformanceApiINTEL, uintptr(device), uintptr(unsafe.Pointer(pInitializeInfo))))

	return
}

// InvalidateMappedMemoryRanges: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkInvalidateMappedMemoryRanges.html
func InvalidateMappedMemoryRanges(device Device, memoryRanges []MappedMemoryRange) (r Result) {
	memoryRangeCount := len(memoryRanges)
	// memoryRanges is an input slice that requires translation to an internal type
	var pMemoryRanges unsafe.Pointer
	if len(memoryRanges) > 0 {
		sl_memoryRanges := make([]_vkMappedMemoryRange, memoryRangeCount)
		for i, v := range memoryRanges {
			sl_memoryRanges[i] = *(v.Vulkanize())
		}
		pMemoryRanges = unsafe.Pointer(&sl_memoryRanges[0])
	}

	r = Result(execTrampoline(keyvkInvalidateMappedMemoryRanges, uintptr(device), uintptr(memoryRangeCount), uintptr(unsafe.Pointer(pMemoryRanges))))

	return
}

// MapMemory: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkMapMemory.html
func MapMemory(device Device, memory DeviceMemory, offset DeviceSize, size DeviceSize, flags MemoryMapFlags) (r Result, pData *byte) {
	// pData is a binding-allocated single return value and will be populated by Vulkan
	ptr_ppData := &pData

	r = Result(execTrampoline(keyvkMapMemory, uintptr(device), uintptr(memory), uintptr(offset), uintptr(size), uintptr(flags), uintptr(unsafe.Pointer(ptr_ppData))))

	return
}

// MergePipelineCaches: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkMergePipelineCaches.html
func MergePipelineCaches(device Device, dstCache PipelineCache, srcCaches []PipelineCache) (r Result) {
	srcCacheCount := len(srcCaches)
	// srcCaches is an input slice of values that do not need translation used
	var pSrcCaches unsafe.Pointer
	if srcCaches != nil {
		pSrcCaches = unsafe.Pointer(&srcCaches[0])
	}

	r = Result(execTrampoline(keyvkMergePipelineCaches, uintptr(device), uintptr(dstCache), uintptr(srcCacheCount), uintptr(unsafe.Pointer(pSrcCaches))))

	return
}

// MergeValidationCachesEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkMergeValidationCachesEXT.html
func MergeValidationCachesEXT(device Device, dstCache ValidationCacheEXT, srcCaches []ValidationCacheEXT) (r Result) {
	srcCacheCount := len(srcCaches)
	// srcCaches is an input slice of values that do not need translation used
	var pSrcCaches unsafe.Pointer
	if srcCaches != nil {
		pSrcCaches = unsafe.Pointer(&srcCaches[0])
	}

	r = Result(execTrampoline(keyvkMergeValidationCachesEXT, uintptr(device), uintptr(dstCache), uintptr(srcCacheCount), uintptr(unsafe.Pointer(pSrcCaches))))

	return
}

// QueueBeginDebugUtilsLabelEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkQueueBeginDebugUtilsLabelEXT.html
func QueueBeginDebugUtilsLabelEXT(queue Queue, labelInfo *DebugUtilsLabelEXT) {
	// Parameter is a singular input, requires translation - labelInfo
	var pLabelInfo *_vkDebugUtilsLabelEXT
	if labelInfo != nil {
		pLabelInfo = labelInfo.Vulkanize()
	}

	execTrampoline(keyvkQueueBeginDebugUtilsLabelEXT, uintptr(queue), uintptr(unsafe.Pointer(pLabelInfo)))

}

// QueueBindSparse: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkQueueBindSparse.html
func QueueBindSparse(queue Queue, bindInfo []BindSparseInfo, fence Fence) (r Result) {
	bindInfoCount := len(bindInfo)
	// bindInfo is an input slice that requires translation to an internal type
	var pBindInfo unsafe.Pointer
	if len(bindInfo) > 0 {
		sl_bindInfo := make([]_vkBindSparseInfo, bindInfoCount)
		for i, v := range bindInfo {
			sl_bindInfo[i] = *(v.Vulkanize())
		}
		pBindInfo = unsafe.Pointer(&sl_bindInfo[0])
	}

	r = Result(execTrampoline(keyvkQueueBindSparse, uintptr(queue), uintptr(bindInfoCount), uintptr(unsafe.Pointer(pBindInfo)), uintptr(fence)))

	return
}

// QueueEndDebugUtilsLabelEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkQueueEndDebugUtilsLabelEXT.html
func QueueEndDebugUtilsLabelEXT(queue Queue) {

	execTrampoline(keyvkQueueEndDebugUtilsLabelEXT, uintptr(queue))

}

// QueueInsertDebugUtilsLabelEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkQueueInsertDebugUtilsLabelEXT.html
func QueueInsertDebugUtilsLabelEXT(queue Queue, labelInfo *DebugUtilsLabelEXT) {
	// Parameter is a singular input, requires translation - labelInfo
	var pLabelInfo *_vkDebugUtilsLabelEXT
	if labelInfo != nil {
		pLabelInfo = labelInfo.Vulkanize()
	}

	execTrampoline(keyvkQueueInsertDebugUtilsLabelEXT, uintptr(queue), uintptr(unsafe.Pointer(pLabelInfo)))

}

// QueuePresentKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkQueuePresentKHR.html
func QueuePresentKHR(queue Queue, presentInfo *PresentInfoKHR) (r Result) {
	// Parameter is a singular input, requires translation - presentInfo
	var pPresentInfo *_vkPresentInfoKHR
	if presentInfo != nil {
		pPresentInfo = presentInfo.Vulkanize()
	}

	r = Result(execTrampoline(keyvkQueuePresentKHR, uintptr(queue), uintptr(unsafe.Pointer(pPresentInfo))))

	return
}

// QueueSetPerformanceConfigurationINTEL: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkQueueSetPerformanceConfigurationINTEL.html
func QueueSetPerformanceConfigurationINTEL(queue Queue, configuration PerformanceConfigurationINTEL) (r Result) {

	r = Result(execTrampoline(keyvkQueueSetPerformanceConfigurationINTEL, uintptr(queue), uintptr(configuration)))

	return
}

// QueueSubmit: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkQueueSubmit.html
func QueueSubmit(queue Queue, submits []SubmitInfo, fence Fence) (r Result) {
	submitCount := len(submits)
	// submits is an input slice that requires translation to an internal type
	var pSubmits unsafe.Pointer
	if len(submits) > 0 {
		sl_submits := make([]_vkSubmitInfo, submitCount)
		for i, v := range submits {
			sl_submits[i] = *(v.Vulkanize())
		}
		pSubmits = unsafe.Pointer(&sl_submits[0])
	}

	r = Result(execTrampoline(keyvkQueueSubmit, uintptr(queue), uintptr(submitCount), uintptr(unsafe.Pointer(pSubmits)), uintptr(fence)))

	return
}

// QueueSubmit2: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkQueueSubmit2.html
func QueueSubmit2(queue Queue, submits []SubmitInfo2, fence Fence) (r Result) {
	submitCount := len(submits)
	// submits is an input slice that requires translation to an internal type
	var pSubmits unsafe.Pointer
	if len(submits) > 0 {
		sl_submits := make([]_vkSubmitInfo2, submitCount)
		for i, v := range submits {
			sl_submits[i] = *(v.Vulkanize())
		}
		pSubmits = unsafe.Pointer(&sl_submits[0])
	}

	r = Result(execTrampoline(keyvkQueueSubmit2, uintptr(queue), uintptr(submitCount), uintptr(unsafe.Pointer(pSubmits)), uintptr(fence)))

	return
}

var QueueSubmit2KHR = QueueSubmit2

// QueueWaitIdle: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkQueueWaitIdle.html
func QueueWaitIdle(queue Queue) (r Result) {

	r = Result(execTrampoline(keyvkQueueWaitIdle, uintptr(queue)))

	return
}

// RegisterDeviceEventEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkRegisterDeviceEventEXT.html
func RegisterDeviceEventEXT(device Device, deviceEventInfo *DeviceEventInfoEXT, allocator *AllocationCallbacks) (r Result, fence Fence) {
	// Parameter is a singular input, requires translation - deviceEventInfo
	var pDeviceEventInfo *_vkDeviceEventInfoEXT
	if deviceEventInfo != nil {
		pDeviceEventInfo = deviceEventInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// fence is a binding-allocated single return value and will be populated by Vulkan
	ptr_pFence := &fence

	r = Result(execTrampoline(keyvkRegisterDeviceEventEXT, uintptr(device), uintptr(unsafe.Pointer(pDeviceEventInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pFence))))

	return
}

// RegisterDisplayEventEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkRegisterDisplayEventEXT.html
func RegisterDisplayEventEXT(device Device, display DisplayKHR, displayEventInfo *DisplayEventInfoEXT, allocator *AllocationCallbacks) (r Result, fence Fence) {
	// Parameter is a singular input, requires translation - displayEventInfo
	var pDisplayEventInfo *_vkDisplayEventInfoEXT
	if displayEventInfo != nil {
		pDisplayEventInfo = displayEventInfo.Vulkanize()
	}

	// Parameter is a singular input, pass direct - allocator
	var pAllocator unsafe.Pointer
	if allocator != nil {
		pAllocator = unsafe.Pointer(allocator)
	}

	// fence is a binding-allocated single return value and will be populated by Vulkan
	ptr_pFence := &fence

	r = Result(execTrampoline(keyvkRegisterDisplayEventEXT, uintptr(device), uintptr(display), uintptr(unsafe.Pointer(pDisplayEventInfo)), uintptr(unsafe.Pointer(pAllocator)), uintptr(unsafe.Pointer(ptr_pFence))))

	return
}

// ReleaseDisplayEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkReleaseDisplayEXT.html
func ReleaseDisplayEXT(physicalDevice PhysicalDevice, display DisplayKHR) (r Result) {

	r = Result(execTrampoline(keyvkReleaseDisplayEXT, uintptr(physicalDevice), uintptr(display)))

	return
}

// ReleasePerformanceConfigurationINTEL: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkReleasePerformanceConfigurationINTEL.html
func ReleasePerformanceConfigurationINTEL(device Device, configuration PerformanceConfigurationINTEL) (r Result) {

	r = Result(execTrampoline(keyvkReleasePerformanceConfigurationINTEL, uintptr(device), uintptr(configuration)))

	return
}

// ReleaseProfilingLockKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkReleaseProfilingLockKHR.html
func ReleaseProfilingLockKHR(device Device) {

	execTrampoline(keyvkReleaseProfilingLockKHR, uintptr(device))

}

// ReleaseSwapchainImagesEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkReleaseSwapchainImagesEXT.html
func ReleaseSwapchainImagesEXT(device Device, releaseInfo *ReleaseSwapchainImagesInfoEXT) (r Result) {
	// Parameter is a singular input, requires translation - releaseInfo
	var pReleaseInfo *_vkReleaseSwapchainImagesInfoEXT
	if releaseInfo != nil {
		pReleaseInfo = releaseInfo.Vulkanize()
	}

	r = Result(execTrampoline(keyvkReleaseSwapchainImagesEXT, uintptr(device), uintptr(unsafe.Pointer(pReleaseInfo))))

	return
}

// ResetCommandBuffer: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkResetCommandBuffer.html
func ResetCommandBuffer(commandBuffer CommandBuffer, flags CommandBufferResetFlags) (r Result) {

	r = Result(execTrampoline(keyvkResetCommandBuffer, uintptr(commandBuffer), uintptr(flags)))

	return
}

// ResetCommandPool: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkResetCommandPool.html
func ResetCommandPool(device Device, commandPool CommandPool, flags CommandPoolResetFlags) (r Result) {

	r = Result(execTrampoline(keyvkResetCommandPool, uintptr(device), uintptr(commandPool), uintptr(flags)))

	return
}

// ResetDescriptorPool: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkResetDescriptorPool.html
func ResetDescriptorPool(device Device, descriptorPool DescriptorPool, flags DescriptorPoolResetFlags) (r Result) {

	r = Result(execTrampoline(keyvkResetDescriptorPool, uintptr(device), uintptr(descriptorPool), uintptr(flags)))

	return
}

// ResetEvent: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkResetEvent.html
func ResetEvent(device Device, event Event) (r Result) {

	r = Result(execTrampoline(keyvkResetEvent, uintptr(device), uintptr(event)))

	return
}

// ResetFences: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkResetFences.html
func ResetFences(device Device, fences []Fence) (r Result) {
	fenceCount := len(fences)
	// fences is an input slice of values that do not need translation used
	var pFences unsafe.Pointer
	if fences != nil {
		pFences = unsafe.Pointer(&fences[0])
	}

	r = Result(execTrampoline(keyvkResetFences, uintptr(device), uintptr(fenceCount), uintptr(unsafe.Pointer(pFences))))

	return
}

// ResetQueryPool: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkResetQueryPool.html
func ResetQueryPool(device Device, queryPool QueryPool, firstQuery uint32, queryCount uint32) {

	execTrampoline(keyvkResetQueryPool, uintptr(device), uintptr(queryPool), uintptr(firstQuery), uintptr(queryCount))

}

var ResetQueryPoolEXT = ResetQueryPool

// SetDebugUtilsObjectNameEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkSetDebugUtilsObjectNameEXT.html
func SetDebugUtilsObjectNameEXT(device Device, nameInfo *DebugUtilsObjectNameInfoEXT) (r Result) {
	// Parameter is a singular input, requires translation - nameInfo
	var pNameInfo *_vkDebugUtilsObjectNameInfoEXT
	if nameInfo != nil {
		pNameInfo = nameInfo.Vulkanize()
	}

	r = Result(execTrampoline(keyvkSetDebugUtilsObjectNameEXT, uintptr(device), uintptr(unsafe.Pointer(pNameInfo))))

	return
}

// SetDebugUtilsObjectTagEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkSetDebugUtilsObjectTagEXT.html
func SetDebugUtilsObjectTagEXT(device Device, tagInfo *DebugUtilsObjectTagInfoEXT) (r Result) {
	// Parameter is a singular input, requires translation - tagInfo
	var pTagInfo *_vkDebugUtilsObjectTagInfoEXT
	if tagInfo != nil {
		pTagInfo = tagInfo.Vulkanize()
	}

	r = Result(execTrampoline(keyvkSetDebugUtilsObjectTagEXT, uintptr(device), uintptr(unsafe.Pointer(pTagInfo))))

	return
}

// SetDeviceMemoryPriorityEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkSetDeviceMemoryPriorityEXT.html
func SetDeviceMemoryPriorityEXT(device Device, memory DeviceMemory, priority float32) {

	execTrampoline(keyvkSetDeviceMemoryPriorityEXT, uintptr(device), uintptr(memory), uintptr(priority))

}

// SetEvent: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkSetEvent.html
func SetEvent(device Device, event Event) (r Result) {

	r = Result(execTrampoline(keyvkSetEvent, uintptr(device), uintptr(event)))

	return
}

// SetHdrMetadataEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkSetHdrMetadataEXT.html
func SetHdrMetadataEXT(device Device, swapchains []SwapchainKHR, metadata []HdrMetadataEXT) {
	swapchainCount := len(swapchains)
	// swapchains is an input slice of values that do not need translation used
	var pSwapchains unsafe.Pointer
	if swapchains != nil {
		pSwapchains = unsafe.Pointer(&swapchains[0])
	}

	// metadata is an input slice that requires translation to an internal type
	var pMetadata unsafe.Pointer
	if len(metadata) > 0 {
		sl_metadata := make([]_vkHdrMetadataEXT, swapchainCount)
		for i, v := range metadata {
			sl_metadata[i] = *(v.Vulkanize())
		}
		pMetadata = unsafe.Pointer(&sl_metadata[0])
	}

	execTrampoline(keyvkSetHdrMetadataEXT, uintptr(device), uintptr(swapchainCount), uintptr(unsafe.Pointer(pSwapchains)), uintptr(unsafe.Pointer(pMetadata)))

}

// SetLocalDimmingAMD: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkSetLocalDimmingAMD.html
func SetLocalDimmingAMD(device Device, swapChain SwapchainKHR, localDimmingEnable bool) {
	localDimmingEnable_Bool32 := translateInternal_Bool32(localDimmingEnable)

	execTrampoline(keyvkSetLocalDimmingAMD, uintptr(device), uintptr(swapChain), uintptr(localDimmingEnable_Bool32))

}

// SetPrivateData: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkSetPrivateData.html
func SetPrivateData(device Device, objectType ObjectType, objectHandle uint64, privateDataSlot PrivateDataSlot, data uint64) (r Result) {

	r = Result(execTrampoline(keyvkSetPrivateData, uintptr(device), uintptr(objectType), uintptr(objectHandle), uintptr(privateDataSlot), uintptr(data)))

	return
}

var SetPrivateDataEXT = SetPrivateData

// SignalSemaphore: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkSignalSemaphore.html
func SignalSemaphore(device Device, signalInfo *SemaphoreSignalInfo) (r Result) {
	// Parameter is a singular input, requires translation - signalInfo
	var pSignalInfo *_vkSemaphoreSignalInfo
	if signalInfo != nil {
		pSignalInfo = signalInfo.Vulkanize()
	}

	r = Result(execTrampoline(keyvkSignalSemaphore, uintptr(device), uintptr(unsafe.Pointer(pSignalInfo))))

	return
}

var SignalSemaphoreKHR = SignalSemaphore

// SubmitDebugUtilsMessageEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkSubmitDebugUtilsMessageEXT.html
func SubmitDebugUtilsMessageEXT(instance Instance, messageSeverity DebugUtilsMessageSeverityFlagBitsEXT, messageTypes DebugUtilsMessageTypeFlagsEXT, callbackData *DebugUtilsMessengerCallbackDataEXT) {
	// Parameter is a singular input, requires translation - callbackData
	var pCallbackData *_vkDebugUtilsMessengerCallbackDataEXT
	if callbackData != nil {
		pCallbackData = callbackData.Vulkanize()
	}

	execTrampoline(keyvkSubmitDebugUtilsMessageEXT, uintptr(instance), uintptr(messageSeverity), uintptr(messageTypes), uintptr(unsafe.Pointer(pCallbackData)))

}

// TrimCommandPool: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkTrimCommandPool.html
func TrimCommandPool(device Device, commandPool CommandPool, flags CommandPoolTrimFlags) {

	execTrampoline(keyvkTrimCommandPool, uintptr(device), uintptr(commandPool), uintptr(flags))

}

var TrimCommandPoolKHR = TrimCommandPool

// UninitializePerformanceApiINTEL: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkUninitializePerformanceApiINTEL.html
func UninitializePerformanceApiINTEL(device Device) {

	execTrampoline(keyvkUninitializePerformanceApiINTEL, uintptr(device))

}

// UnmapMemory: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkUnmapMemory.html
func UnmapMemory(device Device, memory DeviceMemory) {

	execTrampoline(keyvkUnmapMemory, uintptr(device), uintptr(memory))

}

// UpdateDescriptorSetWithTemplate: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkUpdateDescriptorSetWithTemplate.html
func UpdateDescriptorSetWithTemplate(device Device, descriptorSet DescriptorSet, descriptorUpdateTemplate DescriptorUpdateTemplate, data *byte) {
	// Parameter is a singular input, pass direct - data
	var pData unsafe.Pointer
	if data != nil {
		pData = unsafe.Pointer(data)
	}

	execTrampoline(keyvkUpdateDescriptorSetWithTemplate, uintptr(device), uintptr(descriptorSet), uintptr(descriptorUpdateTemplate), uintptr(unsafe.Pointer(pData)))

}

var UpdateDescriptorSetWithTemplateKHR = UpdateDescriptorSetWithTemplate

// UpdateDescriptorSets: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkUpdateDescriptorSets.html
func UpdateDescriptorSets(device Device, descriptorWrites []WriteDescriptorSet, descriptorCopies []CopyDescriptorSet) {
	descriptorWriteCount := len(descriptorWrites)
	// descriptorWrites is an input slice that requires translation to an internal type
	var pDescriptorWrites unsafe.Pointer
	if len(descriptorWrites) > 0 {
		sl_descriptorWrites := make([]_vkWriteDescriptorSet, descriptorWriteCount)
		for i, v := range descriptorWrites {
			sl_descriptorWrites[i] = *(v.Vulkanize())
		}
		pDescriptorWrites = unsafe.Pointer(&sl_descriptorWrites[0])
	}

	descriptorCopyCount := len(descriptorCopies)
	// descriptorCopies is an input slice that requires translation to an internal type
	var pDescriptorCopies unsafe.Pointer
	if len(descriptorCopies) > 0 {
		sl_descriptorCopies := make([]_vkCopyDescriptorSet, descriptorCopyCount)
		for i, v := range descriptorCopies {
			sl_descriptorCopies[i] = *(v.Vulkanize())
		}
		pDescriptorCopies = unsafe.Pointer(&sl_descriptorCopies[0])
	}

	execTrampoline(keyvkUpdateDescriptorSets, uintptr(device), uintptr(descriptorWriteCount), uintptr(unsafe.Pointer(pDescriptorWrites)), uintptr(descriptorCopyCount), uintptr(unsafe.Pointer(pDescriptorCopies)))

}

// UpdateVideoSessionParametersKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkUpdateVideoSessionParametersKHR.html
func UpdateVideoSessionParametersKHR(device Device, videoSessionParameters VideoSessionParametersKHR, updateInfo *VideoSessionParametersUpdateInfoKHR) (r Result) {
	// Parameter is a singular input, requires translation - updateInfo
	var pUpdateInfo *_vkVideoSessionParametersUpdateInfoKHR
	if updateInfo != nil {
		pUpdateInfo = updateInfo.Vulkanize()
	}

	r = Result(execTrampoline(keyvkUpdateVideoSessionParametersKHR, uintptr(device), uintptr(videoSessionParameters), uintptr(unsafe.Pointer(pUpdateInfo))))

	return
}

// WaitForFences: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkWaitForFences.html
func WaitForFences(device Device, fences []Fence, waitAll bool, timeout uint64) (r Result) {
	fenceCount := len(fences)
	// fences is an input slice of values that do not need translation used
	var pFences unsafe.Pointer
	if fences != nil {
		pFences = unsafe.Pointer(&fences[0])
	}

	waitAll_Bool32 := translateInternal_Bool32(waitAll)

	r = Result(execTrampoline(keyvkWaitForFences, uintptr(device), uintptr(fenceCount), uintptr(unsafe.Pointer(pFences)), uintptr(waitAll_Bool32), uintptr(timeout)))

	return
}

// WaitForPresentKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkWaitForPresentKHR.html
func WaitForPresentKHR(device Device, swapchain SwapchainKHR, presentId uint64, timeout uint64) (r Result) {

	r = Result(execTrampoline(keyvkWaitForPresentKHR, uintptr(device), uintptr(swapchain), uintptr(presentId), uintptr(timeout)))

	return
}

// WaitSemaphores: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkWaitSemaphores.html
func WaitSemaphores(device Device, waitInfo *SemaphoreWaitInfo, timeout uint64) (r Result) {
	// Parameter is a singular input, requires translation - waitInfo
	var pWaitInfo *_vkSemaphoreWaitInfo
	if waitInfo != nil {
		pWaitInfo = waitInfo.Vulkanize()
	}

	r = Result(execTrampoline(keyvkWaitSemaphores, uintptr(device), uintptr(unsafe.Pointer(pWaitInfo)), uintptr(timeout)))

	return
}

var WaitSemaphoresKHR = WaitSemaphores

// WriteAccelerationStructuresPropertiesKHR: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkWriteAccelerationStructuresPropertiesKHR.html
func WriteAccelerationStructuresPropertiesKHR(device Device, accelerationStructures []AccelerationStructureKHR, queryType QueryType, data []byte, stride uintptr) (r Result) {
	accelerationStructureCount := len(accelerationStructures)
	// accelerationStructures is an input slice of values that do not need translation used
	var pAccelerationStructures unsafe.Pointer
	if accelerationStructures != nil {
		pAccelerationStructures = unsafe.Pointer(&accelerationStructures[0])
	}

	dataSize := len(data)
	// data is a user-allocated array input that will be written to
	pData := unsafe.Pointer(&data[0])

	r = Result(execTrampoline(keyvkWriteAccelerationStructuresPropertiesKHR, uintptr(device), uintptr(accelerationStructureCount), uintptr(unsafe.Pointer(pAccelerationStructures)), uintptr(queryType), uintptr(dataSize), uintptr(unsafe.Pointer(pData)), uintptr(stride)))

	return
}

// WriteMicromapsPropertiesEXT: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkWriteMicromapsPropertiesEXT.html
func WriteMicromapsPropertiesEXT(device Device, micromaps []MicromapEXT, queryType QueryType, data []byte, stride uintptr) (r Result) {
	micromapCount := len(micromaps)
	// micromaps is an input slice of values that do not need translation used
	var pMicromaps unsafe.Pointer
	if micromaps != nil {
		pMicromaps = unsafe.Pointer(&micromaps[0])
	}

	dataSize := len(data)
	// data is a user-allocated array input that will be written to
	pData := unsafe.Pointer(&data[0])

	r = Result(execTrampoline(keyvkWriteMicromapsPropertiesEXT, uintptr(device), uintptr(micromapCount), uintptr(unsafe.Pointer(pMicromaps)), uintptr(queryType), uintptr(dataSize), uintptr(unsafe.Pointer(pData)), uintptr(stride)))

	return
}
