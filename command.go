// Code generated by go-vk from vk.xml at 2023-01-14 10:53:48.4999135 -0600 CST m=+1.191210501. DO NOT EDIT.
package vk

import "unsafe"

const (
	keyvkAllocateCommandBuffers vkCommandKey = iota
	keyvkAllocateDescriptorSets
	keyvkAllocateMemory
	keyvkBeginCommandBuffer
	keyvkBindBufferMemory
	keyvkBindImageMemory
	keyvkCreateBuffer
	keyvkCreateBufferView
	keyvkCreateCommandPool
	keyvkCreateComputePipelines
	keyvkCreateDescriptorPool
	keyvkCreateDescriptorSetLayout
	keyvkCreateDevice
	keyvkCreateEvent
	keyvkCreateFence
	keyvkCreateFramebuffer
	keyvkCreateGraphicsPipelines
	keyvkCreateImage
	keyvkCreateImageView
	keyvkCreateInstance
	keyvkCreatePipelineCache
	keyvkCreatePipelineLayout
	keyvkCreateQueryPool
	keyvkCreateRenderPass
	keyvkCreateSampler
	keyvkCreateSemaphore
	keyvkCreateShaderModule
	keyvkDestroyBuffer
	keyvkDestroyBufferView
	keyvkDestroyCommandPool
	keyvkDestroyDescriptorPool
	keyvkDestroyDescriptorSetLayout
	keyvkDestroyDevice
	keyvkDestroyEvent
	keyvkDestroyFence
	keyvkDestroyFramebuffer
	keyvkDestroyImage
	keyvkDestroyImageView
	keyvkDestroyInstance
	keyvkDestroyPipeline
	keyvkDestroyPipelineCache
	keyvkDestroyPipelineLayout
	keyvkDestroyQueryPool
	keyvkDestroyRenderPass
	keyvkDestroySampler
	keyvkDestroySemaphore
	keyvkDestroyShaderModule
	keyvkDeviceWaitIdle
	keyvkEndCommandBuffer
	keyvkEnumerateDeviceExtensionProperties
	keyvkEnumerateDeviceLayerProperties
	keyvkEnumerateInstanceExtensionProperties
	keyvkEnumerateInstanceLayerProperties
	keyvkEnumeratePhysicalDevices
	keyvkFlushMappedMemoryRanges
	keyvkFreeCommandBuffers
	keyvkFreeDescriptorSets
	keyvkFreeMemory
	keyvkGetBufferMemoryRequirements
	keyvkGetDeviceMemoryCommitment
	keyvkGetDeviceProcAddr
	keyvkGetDeviceQueue
	keyvkGetEventStatus
	keyvkGetFenceStatus
	keyvkGetImageMemoryRequirements
	keyvkGetImageSparseMemoryRequirements
	keyvkGetImageSubresourceLayout
	keyvkGetInstanceProcAddr
	keyvkGetPhysicalDeviceFeatures
	keyvkGetPhysicalDeviceFormatProperties
	keyvkGetPhysicalDeviceImageFormatProperties
	keyvkGetPhysicalDeviceMemoryProperties
	keyvkGetPhysicalDeviceProperties
	keyvkGetPhysicalDeviceQueueFamilyProperties
	keyvkGetPhysicalDeviceSparseImageFormatProperties
	keyvkGetPipelineCacheData
	keyvkGetQueryPoolResults
	keyvkGetRenderAreaGranularity
	keyvkInvalidateMappedMemoryRanges
	keyvkMapMemory
	keyvkMergePipelineCaches
	keyvkQueueBindSparse
	keyvkQueueSubmit
	keyvkQueueWaitIdle
	keyvkResetCommandBuffer
	keyvkResetCommandPool
	keyvkResetDescriptorPool
	keyvkResetEvent
	keyvkResetFences
	keyvkSetEvent
	keyvkUnmapMemory
	keyvkUpdateDescriptorSets
	keyvkWaitForFences
)

func init() {
	lazyCommands[keyvkAllocateCommandBuffers] = vkCommand{"vkAllocateCommandBuffers", 3, true, nil}
	lazyCommands[keyvkAllocateDescriptorSets] = vkCommand{"vkAllocateDescriptorSets", 3, true, nil}
	lazyCommands[keyvkAllocateMemory] = vkCommand{"vkAllocateMemory", 4, true, nil}
	lazyCommands[keyvkBeginCommandBuffer] = vkCommand{"vkBeginCommandBuffer", 2, true, nil}
	lazyCommands[keyvkBindBufferMemory] = vkCommand{"vkBindBufferMemory", 4, true, nil}
	lazyCommands[keyvkBindImageMemory] = vkCommand{"vkBindImageMemory", 4, true, nil}
	lazyCommands[keyvkCreateBuffer] = vkCommand{"vkCreateBuffer", 4, true, nil}
	lazyCommands[keyvkCreateBufferView] = vkCommand{"vkCreateBufferView", 4, true, nil}
	lazyCommands[keyvkCreateCommandPool] = vkCommand{"vkCreateCommandPool", 4, true, nil}
	lazyCommands[keyvkCreateComputePipelines] = vkCommand{"vkCreateComputePipelines", 6, true, nil}
	lazyCommands[keyvkCreateDescriptorPool] = vkCommand{"vkCreateDescriptorPool", 4, true, nil}
	lazyCommands[keyvkCreateDescriptorSetLayout] = vkCommand{"vkCreateDescriptorSetLayout", 4, true, nil}
	lazyCommands[keyvkCreateDevice] = vkCommand{"vkCreateDevice", 4, true, nil}
	lazyCommands[keyvkCreateEvent] = vkCommand{"vkCreateEvent", 4, true, nil}
	lazyCommands[keyvkCreateFence] = vkCommand{"vkCreateFence", 4, true, nil}
	lazyCommands[keyvkCreateFramebuffer] = vkCommand{"vkCreateFramebuffer", 4, true, nil}
	lazyCommands[keyvkCreateGraphicsPipelines] = vkCommand{"vkCreateGraphicsPipelines", 6, true, nil}
	lazyCommands[keyvkCreateImage] = vkCommand{"vkCreateImage", 4, true, nil}
	lazyCommands[keyvkCreateImageView] = vkCommand{"vkCreateImageView", 4, true, nil}
	lazyCommands[keyvkCreateInstance] = vkCommand{"vkCreateInstance", 3, true, nil}
	lazyCommands[keyvkCreatePipelineCache] = vkCommand{"vkCreatePipelineCache", 4, true, nil}
	lazyCommands[keyvkCreatePipelineLayout] = vkCommand{"vkCreatePipelineLayout", 4, true, nil}
	lazyCommands[keyvkCreateQueryPool] = vkCommand{"vkCreateQueryPool", 4, true, nil}
	lazyCommands[keyvkCreateRenderPass] = vkCommand{"vkCreateRenderPass", 4, true, nil}
	lazyCommands[keyvkCreateSampler] = vkCommand{"vkCreateSampler", 4, true, nil}
	lazyCommands[keyvkCreateSemaphore] = vkCommand{"vkCreateSemaphore", 4, true, nil}
	lazyCommands[keyvkCreateShaderModule] = vkCommand{"vkCreateShaderModule", 4, true, nil}
	lazyCommands[keyvkDestroyBuffer] = vkCommand{"vkDestroyBuffer", 3, true, nil}
	lazyCommands[keyvkDestroyBufferView] = vkCommand{"vkDestroyBufferView", 3, true, nil}
	lazyCommands[keyvkDestroyCommandPool] = vkCommand{"vkDestroyCommandPool", 3, true, nil}
	lazyCommands[keyvkDestroyDescriptorPool] = vkCommand{"vkDestroyDescriptorPool", 3, true, nil}
	lazyCommands[keyvkDestroyDescriptorSetLayout] = vkCommand{"vkDestroyDescriptorSetLayout", 3, true, nil}
	lazyCommands[keyvkDestroyDevice] = vkCommand{"vkDestroyDevice", 2, true, nil}
	lazyCommands[keyvkDestroyEvent] = vkCommand{"vkDestroyEvent", 3, true, nil}
	lazyCommands[keyvkDestroyFence] = vkCommand{"vkDestroyFence", 3, true, nil}
	lazyCommands[keyvkDestroyFramebuffer] = vkCommand{"vkDestroyFramebuffer", 3, true, nil}
	lazyCommands[keyvkDestroyImage] = vkCommand{"vkDestroyImage", 3, true, nil}
	lazyCommands[keyvkDestroyImageView] = vkCommand{"vkDestroyImageView", 3, true, nil}
	lazyCommands[keyvkDestroyInstance] = vkCommand{"vkDestroyInstance", 2, true, nil}
	lazyCommands[keyvkDestroyPipeline] = vkCommand{"vkDestroyPipeline", 3, true, nil}
	lazyCommands[keyvkDestroyPipelineCache] = vkCommand{"vkDestroyPipelineCache", 3, true, nil}
	lazyCommands[keyvkDestroyPipelineLayout] = vkCommand{"vkDestroyPipelineLayout", 3, true, nil}
	lazyCommands[keyvkDestroyQueryPool] = vkCommand{"vkDestroyQueryPool", 3, true, nil}
	lazyCommands[keyvkDestroyRenderPass] = vkCommand{"vkDestroyRenderPass", 3, true, nil}
	lazyCommands[keyvkDestroySampler] = vkCommand{"vkDestroySampler", 3, true, nil}
	lazyCommands[keyvkDestroySemaphore] = vkCommand{"vkDestroySemaphore", 3, true, nil}
	lazyCommands[keyvkDestroyShaderModule] = vkCommand{"vkDestroyShaderModule", 3, true, nil}
	lazyCommands[keyvkDeviceWaitIdle] = vkCommand{"vkDeviceWaitIdle", 1, true, nil}
	lazyCommands[keyvkEndCommandBuffer] = vkCommand{"vkEndCommandBuffer", 1, true, nil}
	lazyCommands[keyvkEnumerateDeviceExtensionProperties] = vkCommand{"vkEnumerateDeviceExtensionProperties", 4, true, nil}
	lazyCommands[keyvkEnumerateDeviceLayerProperties] = vkCommand{"vkEnumerateDeviceLayerProperties", 3, true, nil}
	lazyCommands[keyvkEnumerateInstanceExtensionProperties] = vkCommand{"vkEnumerateInstanceExtensionProperties", 3, true, nil}
	lazyCommands[keyvkEnumerateInstanceLayerProperties] = vkCommand{"vkEnumerateInstanceLayerProperties", 2, true, nil}
	lazyCommands[keyvkEnumeratePhysicalDevices] = vkCommand{"vkEnumeratePhysicalDevices", 3, true, nil}
	lazyCommands[keyvkFlushMappedMemoryRanges] = vkCommand{"vkFlushMappedMemoryRanges", 3, true, nil}
	lazyCommands[keyvkFreeCommandBuffers] = vkCommand{"vkFreeCommandBuffers", 4, true, nil}
	lazyCommands[keyvkFreeDescriptorSets] = vkCommand{"vkFreeDescriptorSets", 4, true, nil}
	lazyCommands[keyvkFreeMemory] = vkCommand{"vkFreeMemory", 3, true, nil}
	lazyCommands[keyvkGetBufferMemoryRequirements] = vkCommand{"vkGetBufferMemoryRequirements", 3, true, nil}
	lazyCommands[keyvkGetDeviceMemoryCommitment] = vkCommand{"vkGetDeviceMemoryCommitment", 3, true, nil}
	lazyCommands[keyvkGetDeviceProcAddr] = vkCommand{"vkGetDeviceProcAddr", 2, true, nil}
	lazyCommands[keyvkGetDeviceQueue] = vkCommand{"vkGetDeviceQueue", 4, true, nil}
	lazyCommands[keyvkGetEventStatus] = vkCommand{"vkGetEventStatus", 2, true, nil}
	lazyCommands[keyvkGetFenceStatus] = vkCommand{"vkGetFenceStatus", 2, true, nil}
	lazyCommands[keyvkGetImageMemoryRequirements] = vkCommand{"vkGetImageMemoryRequirements", 3, true, nil}
	lazyCommands[keyvkGetImageSparseMemoryRequirements] = vkCommand{"vkGetImageSparseMemoryRequirements", 4, true, nil}
	lazyCommands[keyvkGetImageSubresourceLayout] = vkCommand{"vkGetImageSubresourceLayout", 4, true, nil}
	lazyCommands[keyvkGetInstanceProcAddr] = vkCommand{"vkGetInstanceProcAddr", 2, true, nil}
	lazyCommands[keyvkGetPhysicalDeviceFeatures] = vkCommand{"vkGetPhysicalDeviceFeatures", 2, true, nil}
	lazyCommands[keyvkGetPhysicalDeviceFormatProperties] = vkCommand{"vkGetPhysicalDeviceFormatProperties", 3, true, nil}
	lazyCommands[keyvkGetPhysicalDeviceImageFormatProperties] = vkCommand{"vkGetPhysicalDeviceImageFormatProperties", 7, true, nil}
	lazyCommands[keyvkGetPhysicalDeviceMemoryProperties] = vkCommand{"vkGetPhysicalDeviceMemoryProperties", 2, true, nil}
	lazyCommands[keyvkGetPhysicalDeviceProperties] = vkCommand{"vkGetPhysicalDeviceProperties", 2, true, nil}
	lazyCommands[keyvkGetPhysicalDeviceQueueFamilyProperties] = vkCommand{"vkGetPhysicalDeviceQueueFamilyProperties", 3, true, nil}
	lazyCommands[keyvkGetPhysicalDeviceSparseImageFormatProperties] = vkCommand{"vkGetPhysicalDeviceSparseImageFormatProperties", 8, true, nil}
	lazyCommands[keyvkGetPipelineCacheData] = vkCommand{"vkGetPipelineCacheData", 4, true, nil}
	lazyCommands[keyvkGetQueryPoolResults] = vkCommand{"vkGetQueryPoolResults", 8, true, nil}
	lazyCommands[keyvkGetRenderAreaGranularity] = vkCommand{"vkGetRenderAreaGranularity", 3, true, nil}
	lazyCommands[keyvkInvalidateMappedMemoryRanges] = vkCommand{"vkInvalidateMappedMemoryRanges", 3, true, nil}
	lazyCommands[keyvkMapMemory] = vkCommand{"vkMapMemory", 6, true, nil}
	lazyCommands[keyvkMergePipelineCaches] = vkCommand{"vkMergePipelineCaches", 4, true, nil}
	lazyCommands[keyvkQueueBindSparse] = vkCommand{"vkQueueBindSparse", 4, true, nil}
	lazyCommands[keyvkQueueSubmit] = vkCommand{"vkQueueSubmit", 4, true, nil}
	lazyCommands[keyvkQueueWaitIdle] = vkCommand{"vkQueueWaitIdle", 1, true, nil}
	lazyCommands[keyvkResetCommandBuffer] = vkCommand{"vkResetCommandBuffer", 2, true, nil}
	lazyCommands[keyvkResetCommandPool] = vkCommand{"vkResetCommandPool", 3, true, nil}
	lazyCommands[keyvkResetDescriptorPool] = vkCommand{"vkResetDescriptorPool", 3, true, nil}
	lazyCommands[keyvkResetEvent] = vkCommand{"vkResetEvent", 2, true, nil}
	lazyCommands[keyvkResetFences] = vkCommand{"vkResetFences", 3, true, nil}
	lazyCommands[keyvkSetEvent] = vkCommand{"vkSetEvent", 2, true, nil}
	lazyCommands[keyvkUnmapMemory] = vkCommand{"vkUnmapMemory", 2, true, nil}
	lazyCommands[keyvkUpdateDescriptorSets] = vkCommand{"vkUpdateDescriptorSets", 5, true, nil}
	lazyCommands[keyvkWaitForFences] = vkCommand{"vkWaitForFences", 5, true, nil}
}

// AllocateCommandBuffers: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkAllocateCommandBuffers.html
func AllocateCommandBuffers(device Device, allocateInfo *CommandBufferAllocateInfo) (r Result) {
	// Parameter is a singular input, requires translation - allocateInfo
	pAllocateInfo := unsafe.Pointer(unsafe.Pointer(allocateInfo.Vulkanize()))

	// Parameter is binding-allocated array populated by Vulkan; length is possibly embedded in a struct (pAllocateInfo->commandBufferCount) - commandBuffers

	r = Result(execTrampoline(keyvkAllocateCommandBuffers, uintptr(device), uintptr(pAllocateInfo)))

	return
}

// AllocateDescriptorSets: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkAllocateDescriptorSets.html
func AllocateDescriptorSets(device Device, allocateInfo *DescriptorSetAllocateInfo) (r Result) {
	// Parameter is a singular input, requires translation - allocateInfo
	pAllocateInfo := unsafe.Pointer(unsafe.Pointer(allocateInfo.Vulkanize()))

	// Parameter is binding-allocated array populated by Vulkan; length is possibly embedded in a struct (pAllocateInfo->descriptorSetCount) - descriptorSets

	r = Result(execTrampoline(keyvkAllocateDescriptorSets, uintptr(device), uintptr(pAllocateInfo)))

	return
}

// AllocateMemory: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkAllocateMemory.html
func AllocateMemory(device Device, allocateInfo *MemoryAllocateInfo, allocator *AllocationCallbacks) (r Result, memory DeviceMemory) {
	// Parameter is a singular input, requires translation - allocateInfo
	pAllocateInfo := unsafe.Pointer(unsafe.Pointer(allocateInfo.Vulkanize()))

	// Parameter is a singular input, requires translation - allocator
	pAllocator := unsafe.Pointer(unsafe.Pointer(allocator.Vulkanize()))

	// memory is a binding-allocated single return value and will be populated by Vulkan
	pMemory := unsafe.Pointer(&memory)

	r = Result(execTrampoline(keyvkAllocateMemory, uintptr(device), uintptr(pAllocateInfo), uintptr(pAllocator), uintptr(pMemory)))

	return
}

// BeginCommandBuffer: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkBeginCommandBuffer.html
func BeginCommandBuffer(commandBuffer CommandBuffer, beginInfo *CommandBufferBeginInfo) (r Result) {
	// Parameter is a singular input, requires translation - beginInfo
	pBeginInfo := unsafe.Pointer(unsafe.Pointer(beginInfo.Vulkanize()))

	r = Result(execTrampoline(keyvkBeginCommandBuffer, uintptr(commandBuffer), uintptr(pBeginInfo)))

	return
}

// BindBufferMemory: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkBindBufferMemory.html
func BindBufferMemory(device Device, buffer Buffer, memory DeviceMemory, memoryOffset DeviceSize) (r Result) {

	r = Result(execTrampoline(keyvkBindBufferMemory, uintptr(device), uintptr(buffer), uintptr(memory), uintptr(memoryOffset)))

	return
}

// BindImageMemory: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkBindImageMemory.html
func BindImageMemory(device Device, image Image, memory DeviceMemory, memoryOffset DeviceSize) (r Result) {

	r = Result(execTrampoline(keyvkBindImageMemory, uintptr(device), uintptr(image), uintptr(memory), uintptr(memoryOffset)))

	return
}

// CreateBuffer: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateBuffer.html
func CreateBuffer(device Device, createInfo *BufferCreateInfo, allocator *AllocationCallbacks) (r Result, buffer Buffer) {
	// Parameter is a singular input, requires translation - createInfo
	pCreateInfo := unsafe.Pointer(unsafe.Pointer(createInfo.Vulkanize()))

	// Parameter is a singular input, requires translation - allocator
	pAllocator := unsafe.Pointer(unsafe.Pointer(allocator.Vulkanize()))

	// buffer is a binding-allocated single return value and will be populated by Vulkan
	pBuffer := unsafe.Pointer(&buffer)

	r = Result(execTrampoline(keyvkCreateBuffer, uintptr(device), uintptr(pCreateInfo), uintptr(pAllocator), uintptr(pBuffer)))

	return
}

// CreateBufferView: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateBufferView.html
func CreateBufferView(device Device, createInfo *BufferViewCreateInfo, allocator *AllocationCallbacks) (r Result, view BufferView) {
	// Parameter is a singular input, requires translation - createInfo
	pCreateInfo := unsafe.Pointer(unsafe.Pointer(createInfo.Vulkanize()))

	// Parameter is a singular input, requires translation - allocator
	pAllocator := unsafe.Pointer(unsafe.Pointer(allocator.Vulkanize()))

	// view is a binding-allocated single return value and will be populated by Vulkan
	pView := unsafe.Pointer(&view)

	r = Result(execTrampoline(keyvkCreateBufferView, uintptr(device), uintptr(pCreateInfo), uintptr(pAllocator), uintptr(pView)))

	return
}

// CreateCommandPool: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateCommandPool.html
func CreateCommandPool(device Device, createInfo *CommandPoolCreateInfo, allocator *AllocationCallbacks) (r Result, commandPool CommandPool) {
	// Parameter is a singular input, requires translation - createInfo
	pCreateInfo := unsafe.Pointer(unsafe.Pointer(createInfo.Vulkanize()))

	// Parameter is a singular input, requires translation - allocator
	pAllocator := unsafe.Pointer(unsafe.Pointer(allocator.Vulkanize()))

	// commandPool is a binding-allocated single return value and will be populated by Vulkan
	pCommandPool := unsafe.Pointer(&commandPool)

	r = Result(execTrampoline(keyvkCreateCommandPool, uintptr(device), uintptr(pCreateInfo), uintptr(pAllocator), uintptr(pCommandPool)))

	return
}

// CreateComputePipelines: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateComputePipelines.html
func CreateComputePipelines(device Device, pipelineCache PipelineCache, createInfos []ComputePipelineCreateInfo, allocator *AllocationCallbacks) (r Result, pipelines []Pipeline) {
	createInfoCount := len(createInfos)
	// createInfos is an input slice that requires translation to an internal type
	sl_createInfos := make([]_vkComputePipelineCreateInfo, createInfoCount)
	for i, v := range createInfos {
		sl_createInfos[i] = *(v.Vulkanize())
	}
	pCreateInfos := unsafe.Pointer(&sl_createInfos[0])

	// Parameter is a singular input, requires translation - allocator
	pAllocator := unsafe.Pointer(unsafe.Pointer(allocator.Vulkanize()))

	// pipelines is an output array that will be allocated by the binding, len is from createInfoCount
	pipelines = make([]Pipeline, createInfoCount)
	pPipelines := unsafe.Pointer(&pipelines[0])

	r = Result(execTrampoline(keyvkCreateComputePipelines, uintptr(device), uintptr(pipelineCache), uintptr(createInfoCount), uintptr(pCreateInfos), uintptr(pAllocator), uintptr(pPipelines)))

	return
}

// CreateDescriptorPool: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateDescriptorPool.html
func CreateDescriptorPool(device Device, createInfo *DescriptorPoolCreateInfo, allocator *AllocationCallbacks) (r Result, descriptorPool DescriptorPool) {
	// Parameter is a singular input, requires translation - createInfo
	pCreateInfo := unsafe.Pointer(unsafe.Pointer(createInfo.Vulkanize()))

	// Parameter is a singular input, requires translation - allocator
	pAllocator := unsafe.Pointer(unsafe.Pointer(allocator.Vulkanize()))

	// descriptorPool is a binding-allocated single return value and will be populated by Vulkan
	pDescriptorPool := unsafe.Pointer(&descriptorPool)

	r = Result(execTrampoline(keyvkCreateDescriptorPool, uintptr(device), uintptr(pCreateInfo), uintptr(pAllocator), uintptr(pDescriptorPool)))

	return
}

// CreateDescriptorSetLayout: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateDescriptorSetLayout.html
func CreateDescriptorSetLayout(device Device, createInfo *DescriptorSetLayoutCreateInfo, allocator *AllocationCallbacks) (r Result, setLayout DescriptorSetLayout) {
	// Parameter is a singular input, requires translation - createInfo
	pCreateInfo := unsafe.Pointer(unsafe.Pointer(createInfo.Vulkanize()))

	// Parameter is a singular input, requires translation - allocator
	pAllocator := unsafe.Pointer(unsafe.Pointer(allocator.Vulkanize()))

	// setLayout is a binding-allocated single return value and will be populated by Vulkan
	pSetLayout := unsafe.Pointer(&setLayout)

	r = Result(execTrampoline(keyvkCreateDescriptorSetLayout, uintptr(device), uintptr(pCreateInfo), uintptr(pAllocator), uintptr(pSetLayout)))

	return
}

// CreateDevice: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateDevice.html
func CreateDevice(physicalDevice PhysicalDevice, createInfo *DeviceCreateInfo, allocator *AllocationCallbacks) (r Result, device Device) {
	// Parameter is a singular input, requires translation - createInfo
	pCreateInfo := unsafe.Pointer(unsafe.Pointer(createInfo.Vulkanize()))

	// Parameter is a singular input, requires translation - allocator
	pAllocator := unsafe.Pointer(unsafe.Pointer(allocator.Vulkanize()))

	// device is a binding-allocated single return value and will be populated by Vulkan
	pDevice := unsafe.Pointer(&device)

	r = Result(execTrampoline(keyvkCreateDevice, uintptr(physicalDevice), uintptr(pCreateInfo), uintptr(pAllocator), uintptr(pDevice)))

	return
}

// CreateEvent: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateEvent.html
func CreateEvent(device Device, createInfo *EventCreateInfo, allocator *AllocationCallbacks) (r Result, event Event) {
	// Parameter is a singular input, requires translation - createInfo
	pCreateInfo := unsafe.Pointer(unsafe.Pointer(createInfo.Vulkanize()))

	// Parameter is a singular input, requires translation - allocator
	pAllocator := unsafe.Pointer(unsafe.Pointer(allocator.Vulkanize()))

	// event is a binding-allocated single return value and will be populated by Vulkan
	pEvent := unsafe.Pointer(&event)

	r = Result(execTrampoline(keyvkCreateEvent, uintptr(device), uintptr(pCreateInfo), uintptr(pAllocator), uintptr(pEvent)))

	return
}

// CreateFence: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateFence.html
func CreateFence(device Device, createInfo *FenceCreateInfo, allocator *AllocationCallbacks) (r Result, fence Fence) {
	// Parameter is a singular input, requires translation - createInfo
	pCreateInfo := unsafe.Pointer(unsafe.Pointer(createInfo.Vulkanize()))

	// Parameter is a singular input, requires translation - allocator
	pAllocator := unsafe.Pointer(unsafe.Pointer(allocator.Vulkanize()))

	// fence is a binding-allocated single return value and will be populated by Vulkan
	pFence := unsafe.Pointer(&fence)

	r = Result(execTrampoline(keyvkCreateFence, uintptr(device), uintptr(pCreateInfo), uintptr(pAllocator), uintptr(pFence)))

	return
}

// CreateFramebuffer: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateFramebuffer.html
func CreateFramebuffer(device Device, createInfo *FramebufferCreateInfo, allocator *AllocationCallbacks) (r Result, framebuffer Framebuffer) {
	// Parameter is a singular input, requires translation - createInfo
	pCreateInfo := unsafe.Pointer(unsafe.Pointer(createInfo.Vulkanize()))

	// Parameter is a singular input, requires translation - allocator
	pAllocator := unsafe.Pointer(unsafe.Pointer(allocator.Vulkanize()))

	// framebuffer is a binding-allocated single return value and will be populated by Vulkan
	pFramebuffer := unsafe.Pointer(&framebuffer)

	r = Result(execTrampoline(keyvkCreateFramebuffer, uintptr(device), uintptr(pCreateInfo), uintptr(pAllocator), uintptr(pFramebuffer)))

	return
}

// CreateGraphicsPipelines: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateGraphicsPipelines.html
func CreateGraphicsPipelines(device Device, pipelineCache PipelineCache, createInfos []GraphicsPipelineCreateInfo, allocator *AllocationCallbacks) (r Result, pipelines []Pipeline) {
	createInfoCount := len(createInfos)
	// createInfos is an input slice that requires translation to an internal type
	sl_createInfos := make([]_vkGraphicsPipelineCreateInfo, createInfoCount)
	for i, v := range createInfos {
		sl_createInfos[i] = *(v.Vulkanize())
	}
	pCreateInfos := unsafe.Pointer(&sl_createInfos[0])

	// Parameter is a singular input, requires translation - allocator
	pAllocator := unsafe.Pointer(unsafe.Pointer(allocator.Vulkanize()))

	// pipelines is an output array that will be allocated by the binding, len is from createInfoCount
	pipelines = make([]Pipeline, createInfoCount)
	pPipelines := unsafe.Pointer(&pipelines[0])

	r = Result(execTrampoline(keyvkCreateGraphicsPipelines, uintptr(device), uintptr(pipelineCache), uintptr(createInfoCount), uintptr(pCreateInfos), uintptr(pAllocator), uintptr(pPipelines)))

	return
}

// CreateImage: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateImage.html
func CreateImage(device Device, createInfo *ImageCreateInfo, allocator *AllocationCallbacks) (r Result, image Image) {
	// Parameter is a singular input, requires translation - createInfo
	pCreateInfo := unsafe.Pointer(unsafe.Pointer(createInfo.Vulkanize()))

	// Parameter is a singular input, requires translation - allocator
	pAllocator := unsafe.Pointer(unsafe.Pointer(allocator.Vulkanize()))

	// image is a binding-allocated single return value and will be populated by Vulkan
	pImage := unsafe.Pointer(&image)

	r = Result(execTrampoline(keyvkCreateImage, uintptr(device), uintptr(pCreateInfo), uintptr(pAllocator), uintptr(pImage)))

	return
}

// CreateImageView: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateImageView.html
func CreateImageView(device Device, createInfo *ImageViewCreateInfo, allocator *AllocationCallbacks) (r Result, view ImageView) {
	// Parameter is a singular input, requires translation - createInfo
	pCreateInfo := unsafe.Pointer(unsafe.Pointer(createInfo.Vulkanize()))

	// Parameter is a singular input, requires translation - allocator
	pAllocator := unsafe.Pointer(unsafe.Pointer(allocator.Vulkanize()))

	// view is a binding-allocated single return value and will be populated by Vulkan
	pView := unsafe.Pointer(&view)

	r = Result(execTrampoline(keyvkCreateImageView, uintptr(device), uintptr(pCreateInfo), uintptr(pAllocator), uintptr(pView)))

	return
}

// CreateInstance: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateInstance.html
func CreateInstance(createInfo *InstanceCreateInfo, allocator *AllocationCallbacks) (r Result, instance Instance) {
	// Parameter is a singular input, requires translation - createInfo
	pCreateInfo := unsafe.Pointer(unsafe.Pointer(createInfo.Vulkanize()))

	// Parameter is a singular input, requires translation - allocator
	pAllocator := unsafe.Pointer(unsafe.Pointer(allocator.Vulkanize()))

	// instance is a binding-allocated single return value and will be populated by Vulkan
	pInstance := unsafe.Pointer(&instance)

	r = Result(execTrampoline(keyvkCreateInstance, uintptr(pCreateInfo), uintptr(pAllocator), uintptr(pInstance)))

	return
}

// CreatePipelineCache: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreatePipelineCache.html
func CreatePipelineCache(device Device, createInfo *PipelineCacheCreateInfo, allocator *AllocationCallbacks) (r Result, pipelineCache PipelineCache) {
	// Parameter is a singular input, requires translation - createInfo
	pCreateInfo := unsafe.Pointer(unsafe.Pointer(createInfo.Vulkanize()))

	// Parameter is a singular input, requires translation - allocator
	pAllocator := unsafe.Pointer(unsafe.Pointer(allocator.Vulkanize()))

	// pipelineCache is a binding-allocated single return value and will be populated by Vulkan
	pPipelineCache := unsafe.Pointer(&pipelineCache)

	r = Result(execTrampoline(keyvkCreatePipelineCache, uintptr(device), uintptr(pCreateInfo), uintptr(pAllocator), uintptr(pPipelineCache)))

	return
}

// CreatePipelineLayout: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreatePipelineLayout.html
func CreatePipelineLayout(device Device, createInfo *PipelineLayoutCreateInfo, allocator *AllocationCallbacks) (r Result, pipelineLayout PipelineLayout) {
	// Parameter is a singular input, requires translation - createInfo
	pCreateInfo := unsafe.Pointer(unsafe.Pointer(createInfo.Vulkanize()))

	// Parameter is a singular input, requires translation - allocator
	pAllocator := unsafe.Pointer(unsafe.Pointer(allocator.Vulkanize()))

	// pipelineLayout is a binding-allocated single return value and will be populated by Vulkan
	pPipelineLayout := unsafe.Pointer(&pipelineLayout)

	r = Result(execTrampoline(keyvkCreatePipelineLayout, uintptr(device), uintptr(pCreateInfo), uintptr(pAllocator), uintptr(pPipelineLayout)))

	return
}

// CreateQueryPool: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateQueryPool.html
func CreateQueryPool(device Device, createInfo *QueryPoolCreateInfo, allocator *AllocationCallbacks) (r Result, queryPool QueryPool) {
	// Parameter is a singular input, requires translation - createInfo
	pCreateInfo := unsafe.Pointer(unsafe.Pointer(createInfo.Vulkanize()))

	// Parameter is a singular input, requires translation - allocator
	pAllocator := unsafe.Pointer(unsafe.Pointer(allocator.Vulkanize()))

	// queryPool is a binding-allocated single return value and will be populated by Vulkan
	pQueryPool := unsafe.Pointer(&queryPool)

	r = Result(execTrampoline(keyvkCreateQueryPool, uintptr(device), uintptr(pCreateInfo), uintptr(pAllocator), uintptr(pQueryPool)))

	return
}

// CreateRenderPass: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateRenderPass.html
func CreateRenderPass(device Device, createInfo *RenderPassCreateInfo, allocator *AllocationCallbacks) (r Result, renderPass RenderPass) {
	// Parameter is a singular input, requires translation - createInfo
	pCreateInfo := unsafe.Pointer(unsafe.Pointer(createInfo.Vulkanize()))

	// Parameter is a singular input, requires translation - allocator
	pAllocator := unsafe.Pointer(unsafe.Pointer(allocator.Vulkanize()))

	// renderPass is a binding-allocated single return value and will be populated by Vulkan
	pRenderPass := unsafe.Pointer(&renderPass)

	r = Result(execTrampoline(keyvkCreateRenderPass, uintptr(device), uintptr(pCreateInfo), uintptr(pAllocator), uintptr(pRenderPass)))

	return
}

// CreateSampler: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateSampler.html
func CreateSampler(device Device, createInfo *SamplerCreateInfo, allocator *AllocationCallbacks) (r Result, sampler Sampler) {
	// Parameter is a singular input, requires translation - createInfo
	pCreateInfo := unsafe.Pointer(unsafe.Pointer(createInfo.Vulkanize()))

	// Parameter is a singular input, requires translation - allocator
	pAllocator := unsafe.Pointer(unsafe.Pointer(allocator.Vulkanize()))

	// sampler is a binding-allocated single return value and will be populated by Vulkan
	pSampler := unsafe.Pointer(&sampler)

	r = Result(execTrampoline(keyvkCreateSampler, uintptr(device), uintptr(pCreateInfo), uintptr(pAllocator), uintptr(pSampler)))

	return
}

// CreateSemaphore: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateSemaphore.html
func CreateSemaphore(device Device, createInfo *SemaphoreCreateInfo, allocator *AllocationCallbacks) (r Result, semaphore Semaphore) {
	// Parameter is a singular input, requires translation - createInfo
	pCreateInfo := unsafe.Pointer(unsafe.Pointer(createInfo.Vulkanize()))

	// Parameter is a singular input, requires translation - allocator
	pAllocator := unsafe.Pointer(unsafe.Pointer(allocator.Vulkanize()))

	// semaphore is a binding-allocated single return value and will be populated by Vulkan
	pSemaphore := unsafe.Pointer(&semaphore)

	r = Result(execTrampoline(keyvkCreateSemaphore, uintptr(device), uintptr(pCreateInfo), uintptr(pAllocator), uintptr(pSemaphore)))

	return
}

// CreateShaderModule: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkCreateShaderModule.html
func CreateShaderModule(device Device, createInfo *ShaderModuleCreateInfo, allocator *AllocationCallbacks) (r Result, shaderModule ShaderModule) {
	// Parameter is a singular input, requires translation - createInfo
	pCreateInfo := unsafe.Pointer(unsafe.Pointer(createInfo.Vulkanize()))

	// Parameter is a singular input, requires translation - allocator
	pAllocator := unsafe.Pointer(unsafe.Pointer(allocator.Vulkanize()))

	// shaderModule is a binding-allocated single return value and will be populated by Vulkan
	pShaderModule := unsafe.Pointer(&shaderModule)

	r = Result(execTrampoline(keyvkCreateShaderModule, uintptr(device), uintptr(pCreateInfo), uintptr(pAllocator), uintptr(pShaderModule)))

	return
}

// DestroyBuffer: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyBuffer.html
func DestroyBuffer(device Device, buffer Buffer, allocator *AllocationCallbacks) {
	// Parameter is a singular input, requires translation - allocator
	pAllocator := unsafe.Pointer(unsafe.Pointer(allocator.Vulkanize()))

	execTrampoline(keyvkDestroyBuffer, uintptr(device), uintptr(buffer), uintptr(pAllocator))

}

// DestroyBufferView: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyBufferView.html
func DestroyBufferView(device Device, bufferView BufferView, allocator *AllocationCallbacks) {
	// Parameter is a singular input, requires translation - allocator
	pAllocator := unsafe.Pointer(unsafe.Pointer(allocator.Vulkanize()))

	execTrampoline(keyvkDestroyBufferView, uintptr(device), uintptr(bufferView), uintptr(pAllocator))

}

// DestroyCommandPool: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyCommandPool.html
func DestroyCommandPool(device Device, commandPool CommandPool, allocator *AllocationCallbacks) {
	// Parameter is a singular input, requires translation - allocator
	pAllocator := unsafe.Pointer(unsafe.Pointer(allocator.Vulkanize()))

	execTrampoline(keyvkDestroyCommandPool, uintptr(device), uintptr(commandPool), uintptr(pAllocator))

}

// DestroyDescriptorPool: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyDescriptorPool.html
func DestroyDescriptorPool(device Device, descriptorPool DescriptorPool, allocator *AllocationCallbacks) {
	// Parameter is a singular input, requires translation - allocator
	pAllocator := unsafe.Pointer(unsafe.Pointer(allocator.Vulkanize()))

	execTrampoline(keyvkDestroyDescriptorPool, uintptr(device), uintptr(descriptorPool), uintptr(pAllocator))

}

// DestroyDescriptorSetLayout: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyDescriptorSetLayout.html
func DestroyDescriptorSetLayout(device Device, descriptorSetLayout DescriptorSetLayout, allocator *AllocationCallbacks) {
	// Parameter is a singular input, requires translation - allocator
	pAllocator := unsafe.Pointer(unsafe.Pointer(allocator.Vulkanize()))

	execTrampoline(keyvkDestroyDescriptorSetLayout, uintptr(device), uintptr(descriptorSetLayout), uintptr(pAllocator))

}

// DestroyDevice: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyDevice.html
func DestroyDevice(device Device, allocator *AllocationCallbacks) {
	// Parameter is a singular input, requires translation - allocator
	pAllocator := unsafe.Pointer(unsafe.Pointer(allocator.Vulkanize()))

	execTrampoline(keyvkDestroyDevice, uintptr(device), uintptr(pAllocator))

}

// DestroyEvent: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyEvent.html
func DestroyEvent(device Device, event Event, allocator *AllocationCallbacks) {
	// Parameter is a singular input, requires translation - allocator
	pAllocator := unsafe.Pointer(unsafe.Pointer(allocator.Vulkanize()))

	execTrampoline(keyvkDestroyEvent, uintptr(device), uintptr(event), uintptr(pAllocator))

}

// DestroyFence: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyFence.html
func DestroyFence(device Device, fence Fence, allocator *AllocationCallbacks) {
	// Parameter is a singular input, requires translation - allocator
	pAllocator := unsafe.Pointer(unsafe.Pointer(allocator.Vulkanize()))

	execTrampoline(keyvkDestroyFence, uintptr(device), uintptr(fence), uintptr(pAllocator))

}

// DestroyFramebuffer: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyFramebuffer.html
func DestroyFramebuffer(device Device, framebuffer Framebuffer, allocator *AllocationCallbacks) {
	// Parameter is a singular input, requires translation - allocator
	pAllocator := unsafe.Pointer(unsafe.Pointer(allocator.Vulkanize()))

	execTrampoline(keyvkDestroyFramebuffer, uintptr(device), uintptr(framebuffer), uintptr(pAllocator))

}

// DestroyImage: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyImage.html
func DestroyImage(device Device, image Image, allocator *AllocationCallbacks) {
	// Parameter is a singular input, requires translation - allocator
	pAllocator := unsafe.Pointer(unsafe.Pointer(allocator.Vulkanize()))

	execTrampoline(keyvkDestroyImage, uintptr(device), uintptr(image), uintptr(pAllocator))

}

// DestroyImageView: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyImageView.html
func DestroyImageView(device Device, imageView ImageView, allocator *AllocationCallbacks) {
	// Parameter is a singular input, requires translation - allocator
	pAllocator := unsafe.Pointer(unsafe.Pointer(allocator.Vulkanize()))

	execTrampoline(keyvkDestroyImageView, uintptr(device), uintptr(imageView), uintptr(pAllocator))

}

// DestroyInstance: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyInstance.html
func DestroyInstance(instance Instance, allocator *AllocationCallbacks) {
	// Parameter is a singular input, requires translation - allocator
	pAllocator := unsafe.Pointer(unsafe.Pointer(allocator.Vulkanize()))

	execTrampoline(keyvkDestroyInstance, uintptr(instance), uintptr(pAllocator))

}

// DestroyPipeline: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyPipeline.html
func DestroyPipeline(device Device, pipeline Pipeline, allocator *AllocationCallbacks) {
	// Parameter is a singular input, requires translation - allocator
	pAllocator := unsafe.Pointer(unsafe.Pointer(allocator.Vulkanize()))

	execTrampoline(keyvkDestroyPipeline, uintptr(device), uintptr(pipeline), uintptr(pAllocator))

}

// DestroyPipelineCache: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyPipelineCache.html
func DestroyPipelineCache(device Device, pipelineCache PipelineCache, allocator *AllocationCallbacks) {
	// Parameter is a singular input, requires translation - allocator
	pAllocator := unsafe.Pointer(unsafe.Pointer(allocator.Vulkanize()))

	execTrampoline(keyvkDestroyPipelineCache, uintptr(device), uintptr(pipelineCache), uintptr(pAllocator))

}

// DestroyPipelineLayout: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyPipelineLayout.html
func DestroyPipelineLayout(device Device, pipelineLayout PipelineLayout, allocator *AllocationCallbacks) {
	// Parameter is a singular input, requires translation - allocator
	pAllocator := unsafe.Pointer(unsafe.Pointer(allocator.Vulkanize()))

	execTrampoline(keyvkDestroyPipelineLayout, uintptr(device), uintptr(pipelineLayout), uintptr(pAllocator))

}

// DestroyQueryPool: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyQueryPool.html
func DestroyQueryPool(device Device, queryPool QueryPool, allocator *AllocationCallbacks) {
	// Parameter is a singular input, requires translation - allocator
	pAllocator := unsafe.Pointer(unsafe.Pointer(allocator.Vulkanize()))

	execTrampoline(keyvkDestroyQueryPool, uintptr(device), uintptr(queryPool), uintptr(pAllocator))

}

// DestroyRenderPass: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyRenderPass.html
func DestroyRenderPass(device Device, renderPass RenderPass, allocator *AllocationCallbacks) {
	// Parameter is a singular input, requires translation - allocator
	pAllocator := unsafe.Pointer(unsafe.Pointer(allocator.Vulkanize()))

	execTrampoline(keyvkDestroyRenderPass, uintptr(device), uintptr(renderPass), uintptr(pAllocator))

}

// DestroySampler: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroySampler.html
func DestroySampler(device Device, sampler Sampler, allocator *AllocationCallbacks) {
	// Parameter is a singular input, requires translation - allocator
	pAllocator := unsafe.Pointer(unsafe.Pointer(allocator.Vulkanize()))

	execTrampoline(keyvkDestroySampler, uintptr(device), uintptr(sampler), uintptr(pAllocator))

}

// DestroySemaphore: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroySemaphore.html
func DestroySemaphore(device Device, semaphore Semaphore, allocator *AllocationCallbacks) {
	// Parameter is a singular input, requires translation - allocator
	pAllocator := unsafe.Pointer(unsafe.Pointer(allocator.Vulkanize()))

	execTrampoline(keyvkDestroySemaphore, uintptr(device), uintptr(semaphore), uintptr(pAllocator))

}

// DestroyShaderModule: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDestroyShaderModule.html
func DestroyShaderModule(device Device, shaderModule ShaderModule, allocator *AllocationCallbacks) {
	// Parameter is a singular input, requires translation - allocator
	pAllocator := unsafe.Pointer(unsafe.Pointer(allocator.Vulkanize()))

	execTrampoline(keyvkDestroyShaderModule, uintptr(device), uintptr(shaderModule), uintptr(pAllocator))

}

// DeviceWaitIdle: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkDeviceWaitIdle.html
func DeviceWaitIdle(device Device) (r Result) {

	r = Result(execTrampoline(keyvkDeviceWaitIdle, uintptr(device)))

	return
}

// EndCommandBuffer: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkEndCommandBuffer.html
func EndCommandBuffer(commandBuffer CommandBuffer) (r Result) {

	r = Result(execTrampoline(keyvkEndCommandBuffer, uintptr(commandBuffer)))

	return
}

// EnumerateDeviceExtensionProperties: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkEnumerateDeviceExtensionProperties.html
func EnumerateDeviceExtensionProperties(physicalDevice PhysicalDevice, layerName string) (r Result, properties []ExtensionProperties) {
	// Parameter is a singular input, requires translation - layerName
	pLayerName := unsafe.Pointer(sys_stringToBytePointer(layerName))

	// properties is a double-call array output
	var propertyCount uint32
	pPropertyCount := unsafe.Pointer(&propertyCount)
	var pProperties unsafe.Pointer
	// first trampoline happens here; also, check returned Result value

	r = Result(execTrampoline(keyvkEnumerateDeviceExtensionProperties, uintptr(physicalDevice), uintptr(pLayerName), uintptr(pPropertyCount), uintptr(pProperties)))

	properties = make([]ExtensionProperties, propertyCount)
	pProperties = unsafe.Pointer(&properties[0])

	r = Result(execTrampoline(keyvkEnumerateDeviceExtensionProperties, uintptr(physicalDevice), uintptr(pLayerName), uintptr(pPropertyCount), uintptr(pProperties)))

	return
}

// EnumerateDeviceLayerProperties: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkEnumerateDeviceLayerProperties.html
func EnumerateDeviceLayerProperties(physicalDevice PhysicalDevice) (r Result, properties []LayerProperties) {
	// properties is a double-call array output
	var propertyCount uint32
	pPropertyCount := unsafe.Pointer(&propertyCount)
	var pProperties unsafe.Pointer
	// first trampoline happens here; also, check returned Result value

	r = Result(execTrampoline(keyvkEnumerateDeviceLayerProperties, uintptr(physicalDevice), uintptr(pPropertyCount), uintptr(pProperties)))

	properties = make([]LayerProperties, propertyCount)
	pProperties = unsafe.Pointer(&properties[0])

	r = Result(execTrampoline(keyvkEnumerateDeviceLayerProperties, uintptr(physicalDevice), uintptr(pPropertyCount), uintptr(pProperties)))

	return
}

// EnumerateInstanceExtensionProperties: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkEnumerateInstanceExtensionProperties.html
func EnumerateInstanceExtensionProperties(layerName string) (r Result, properties []ExtensionProperties) {
	// Parameter is a singular input, requires translation - layerName
	pLayerName := unsafe.Pointer(sys_stringToBytePointer(layerName))

	// properties is a double-call array output
	var propertyCount uint32
	pPropertyCount := unsafe.Pointer(&propertyCount)
	var pProperties unsafe.Pointer
	// first trampoline happens here; also, check returned Result value

	r = Result(execTrampoline(keyvkEnumerateInstanceExtensionProperties, uintptr(pLayerName), uintptr(pPropertyCount), uintptr(pProperties)))

	properties = make([]ExtensionProperties, propertyCount)
	pProperties = unsafe.Pointer(&properties[0])

	r = Result(execTrampoline(keyvkEnumerateInstanceExtensionProperties, uintptr(pLayerName), uintptr(pPropertyCount), uintptr(pProperties)))

	return
}

// EnumerateInstanceLayerProperties: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkEnumerateInstanceLayerProperties.html
func EnumerateInstanceLayerProperties() (r Result, properties []LayerProperties) {
	// properties is a double-call array output
	var propertyCount uint32
	pPropertyCount := unsafe.Pointer(&propertyCount)
	var pProperties unsafe.Pointer
	// first trampoline happens here; also, check returned Result value

	r = Result(execTrampoline(keyvkEnumerateInstanceLayerProperties, uintptr(pPropertyCount), uintptr(pProperties)))

	properties = make([]LayerProperties, propertyCount)
	pProperties = unsafe.Pointer(&properties[0])

	r = Result(execTrampoline(keyvkEnumerateInstanceLayerProperties, uintptr(pPropertyCount), uintptr(pProperties)))

	return
}

// EnumeratePhysicalDevices: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkEnumeratePhysicalDevices.html
func EnumeratePhysicalDevices(instance Instance) (r Result, physicalDevices []PhysicalDevice) {
	// physicalDevices is a double-call array output
	var physicalDeviceCount uint32
	pPhysicalDeviceCount := unsafe.Pointer(&physicalDeviceCount)
	var pPhysicalDevices unsafe.Pointer
	// first trampoline happens here; also, check returned Result value

	r = Result(execTrampoline(keyvkEnumeratePhysicalDevices, uintptr(instance), uintptr(pPhysicalDeviceCount), uintptr(pPhysicalDevices)))

	physicalDevices = make([]PhysicalDevice, physicalDeviceCount)
	pPhysicalDevices = unsafe.Pointer(&physicalDevices[0])

	r = Result(execTrampoline(keyvkEnumeratePhysicalDevices, uintptr(instance), uintptr(pPhysicalDeviceCount), uintptr(pPhysicalDevices)))

	return
}

// FlushMappedMemoryRanges: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkFlushMappedMemoryRanges.html
func FlushMappedMemoryRanges(device Device, memoryRanges []MappedMemoryRange) (r Result) {
	memoryRangeCount := len(memoryRanges)
	// memoryRanges is an input slice that requires translation to an internal type
	sl_memoryRanges := make([]_vkMappedMemoryRange, memoryRangeCount)
	for i, v := range memoryRanges {
		sl_memoryRanges[i] = *(v.Vulkanize())
	}
	pMemoryRanges := unsafe.Pointer(&sl_memoryRanges[0])

	r = Result(execTrampoline(keyvkFlushMappedMemoryRanges, uintptr(device), uintptr(memoryRangeCount), uintptr(pMemoryRanges)))

	return
}

// FreeCommandBuffers: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkFreeCommandBuffers.html
func FreeCommandBuffers(device Device, commandPool CommandPool, commandBuffers []CommandBuffer) {
	commandBufferCount := len(commandBuffers)
	// commandBuffers is an input slice of values that do not need translation used
	pCommandBuffers := unsafe.Pointer(&commandBuffers[0])

	execTrampoline(keyvkFreeCommandBuffers, uintptr(device), uintptr(commandPool), uintptr(commandBufferCount), uintptr(pCommandBuffers))

}

// FreeDescriptorSets: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkFreeDescriptorSets.html
func FreeDescriptorSets(device Device, descriptorPool DescriptorPool, descriptorSets []DescriptorSet) (r Result) {
	descriptorSetCount := len(descriptorSets)
	// descriptorSets is an input slice of values that do not need translation used
	pDescriptorSets := unsafe.Pointer(&descriptorSets[0])

	r = Result(execTrampoline(keyvkFreeDescriptorSets, uintptr(device), uintptr(descriptorPool), uintptr(descriptorSetCount), uintptr(pDescriptorSets)))

	return
}

// FreeMemory: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkFreeMemory.html
func FreeMemory(device Device, memory DeviceMemory, allocator *AllocationCallbacks) {
	// Parameter is a singular input, requires translation - allocator
	pAllocator := unsafe.Pointer(unsafe.Pointer(allocator.Vulkanize()))

	execTrampoline(keyvkFreeMemory, uintptr(device), uintptr(memory), uintptr(pAllocator))

}

// GetBufferMemoryRequirements: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetBufferMemoryRequirements.html
func GetBufferMemoryRequirements(device Device, buffer Buffer) (memoryRequirements MemoryRequirements) {
	// memoryRequirements is a binding-allocated single return value and will be populated by Vulkan
	pMemoryRequirements := unsafe.Pointer(&memoryRequirements)

	execTrampoline(keyvkGetBufferMemoryRequirements, uintptr(device), uintptr(buffer), uintptr(pMemoryRequirements))

	return
}

// GetDeviceMemoryCommitment: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeviceMemoryCommitment.html
func GetDeviceMemoryCommitment(device Device, memory DeviceMemory) (committedMemoryInBytes DeviceSize) {
	// committedMemoryInBytes is a binding-allocated single return value and will be populated by Vulkan
	pCommittedMemoryInBytes := unsafe.Pointer(&committedMemoryInBytes)

	execTrampoline(keyvkGetDeviceMemoryCommitment, uintptr(device), uintptr(memory), uintptr(pCommittedMemoryInBytes))

	return
}

// GetDeviceProcAddr: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeviceProcAddr.html
func GetDeviceProcAddr(device Device, name string) (fn PFN_vkVoidFunction) {
	// Parameter is a singular input, requires translation - name
	pName := unsafe.Pointer(sys_stringToBytePointer(name))

	fn = PFN_vkVoidFunction(execTrampoline(keyvkGetDeviceProcAddr, uintptr(device), uintptr(pName)))

	return
}

// GetDeviceQueue: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetDeviceQueue.html
func GetDeviceQueue(device Device, queueFamilyIndex uint32, queueIndex uint32) (queue Queue) {
	// queue is a binding-allocated single return value and will be populated by Vulkan
	pQueue := unsafe.Pointer(&queue)

	execTrampoline(keyvkGetDeviceQueue, uintptr(device), uintptr(queueFamilyIndex), uintptr(queueIndex), uintptr(pQueue))

	return
}

// GetEventStatus: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetEventStatus.html
func GetEventStatus(device Device, event Event) (r Result) {

	r = Result(execTrampoline(keyvkGetEventStatus, uintptr(device), uintptr(event)))

	return
}

// GetFenceStatus: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetFenceStatus.html
func GetFenceStatus(device Device, fence Fence) (r Result) {

	r = Result(execTrampoline(keyvkGetFenceStatus, uintptr(device), uintptr(fence)))

	return
}

// GetImageMemoryRequirements: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetImageMemoryRequirements.html
func GetImageMemoryRequirements(device Device, image Image) (memoryRequirements MemoryRequirements) {
	// memoryRequirements is a binding-allocated single return value and will be populated by Vulkan
	pMemoryRequirements := unsafe.Pointer(&memoryRequirements)

	execTrampoline(keyvkGetImageMemoryRequirements, uintptr(device), uintptr(image), uintptr(pMemoryRequirements))

	return
}

// GetImageSparseMemoryRequirements: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetImageSparseMemoryRequirements.html
func GetImageSparseMemoryRequirements(device Device, image Image) (sparseMemoryRequirements []SparseImageMemoryRequirements) {
	// sparseMemoryRequirements is a double-call array output
	var sparseMemoryRequirementCount uint32
	pSparseMemoryRequirementCount := unsafe.Pointer(&sparseMemoryRequirementCount)
	var pSparseMemoryRequirements unsafe.Pointer
	// first trampoline happens here; also, check returned Result value

	execTrampoline(keyvkGetImageSparseMemoryRequirements, uintptr(device), uintptr(image), uintptr(pSparseMemoryRequirementCount), uintptr(pSparseMemoryRequirements))

	sparseMemoryRequirements = make([]SparseImageMemoryRequirements, sparseMemoryRequirementCount)
	pSparseMemoryRequirements = unsafe.Pointer(&sparseMemoryRequirements[0])

	execTrampoline(keyvkGetImageSparseMemoryRequirements, uintptr(device), uintptr(image), uintptr(pSparseMemoryRequirementCount), uintptr(pSparseMemoryRequirements))

	return
}

// GetImageSubresourceLayout: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetImageSubresourceLayout.html
func GetImageSubresourceLayout(device Device, image Image, subresource *ImageSubresource) (layout SubresourceLayout) {
	// Parameter is a singular input, pass direct - subresource
	pSubresource := unsafe.Pointer(subresource)

	// layout is a binding-allocated single return value and will be populated by Vulkan
	pLayout := unsafe.Pointer(&layout)

	execTrampoline(keyvkGetImageSubresourceLayout, uintptr(device), uintptr(image), uintptr(pSubresource), uintptr(pLayout))

	return
}

// GetInstanceProcAddr: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetInstanceProcAddr.html
func GetInstanceProcAddr(instance Instance, name string) (fn PFN_vkVoidFunction) {
	// Parameter is a singular input, requires translation - name
	pName := unsafe.Pointer(sys_stringToBytePointer(name))

	fn = PFN_vkVoidFunction(execTrampoline(keyvkGetInstanceProcAddr, uintptr(instance), uintptr(pName)))

	return
}

// GetPhysicalDeviceFeatures: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceFeatures.html
func GetPhysicalDeviceFeatures(physicalDevice PhysicalDevice) (features PhysicalDeviceFeatures) {
	// features is a binding-allocated single return value and will be populated by Vulkan
	pFeatures := unsafe.Pointer(&features)

	execTrampoline(keyvkGetPhysicalDeviceFeatures, uintptr(physicalDevice), uintptr(pFeatures))

	return
}

// GetPhysicalDeviceFormatProperties: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceFormatProperties.html
func GetPhysicalDeviceFormatProperties(physicalDevice PhysicalDevice, format Format) (formatProperties FormatProperties) {
	// formatProperties is a binding-allocated single return value and will be populated by Vulkan
	pFormatProperties := unsafe.Pointer(&formatProperties)

	execTrampoline(keyvkGetPhysicalDeviceFormatProperties, uintptr(physicalDevice), uintptr(format), uintptr(pFormatProperties))

	return
}

// GetPhysicalDeviceImageFormatProperties: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceImageFormatProperties.html
func GetPhysicalDeviceImageFormatProperties(physicalDevice PhysicalDevice, format Format, typ ImageType, tiling ImageTiling, usage ImageUsageFlags, flags ImageCreateFlags) (r Result, imageFormatProperties ImageFormatProperties) {
	// imageFormatProperties is a binding-allocated single return value and will be populated by Vulkan
	pImageFormatProperties := unsafe.Pointer(&imageFormatProperties)

	r = Result(execTrampoline(keyvkGetPhysicalDeviceImageFormatProperties, uintptr(physicalDevice), uintptr(format), uintptr(typ), uintptr(tiling), uintptr(usage), uintptr(flags), uintptr(pImageFormatProperties)))

	return
}

// GetPhysicalDeviceMemoryProperties: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceMemoryProperties.html
func GetPhysicalDeviceMemoryProperties(physicalDevice PhysicalDevice) (memoryProperties PhysicalDeviceMemoryProperties) {
	// memoryProperties is a binding-allocated single return value and will be populated by Vulkan
	pMemoryProperties := unsafe.Pointer(&memoryProperties)

	execTrampoline(keyvkGetPhysicalDeviceMemoryProperties, uintptr(physicalDevice), uintptr(pMemoryProperties))

	return
}

// GetPhysicalDeviceProperties: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceProperties.html
func GetPhysicalDeviceProperties(physicalDevice PhysicalDevice) (properties PhysicalDeviceProperties) {
	// properties is a binding-allocated single return value and will be populated by Vulkan
	pProperties := unsafe.Pointer(&properties)

	execTrampoline(keyvkGetPhysicalDeviceProperties, uintptr(physicalDevice), uintptr(pProperties))

	return
}

// GetPhysicalDeviceQueueFamilyProperties: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceQueueFamilyProperties.html
func GetPhysicalDeviceQueueFamilyProperties(physicalDevice PhysicalDevice) (queueFamilyProperties []QueueFamilyProperties) {
	// queueFamilyProperties is a double-call array output
	var queueFamilyPropertyCount uint32
	pQueueFamilyPropertyCount := unsafe.Pointer(&queueFamilyPropertyCount)
	var pQueueFamilyProperties unsafe.Pointer
	// first trampoline happens here; also, check returned Result value

	execTrampoline(keyvkGetPhysicalDeviceQueueFamilyProperties, uintptr(physicalDevice), uintptr(pQueueFamilyPropertyCount), uintptr(pQueueFamilyProperties))

	queueFamilyProperties = make([]QueueFamilyProperties, queueFamilyPropertyCount)
	pQueueFamilyProperties = unsafe.Pointer(&queueFamilyProperties[0])

	execTrampoline(keyvkGetPhysicalDeviceQueueFamilyProperties, uintptr(physicalDevice), uintptr(pQueueFamilyPropertyCount), uintptr(pQueueFamilyProperties))

	return
}

// GetPhysicalDeviceSparseImageFormatProperties: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceSparseImageFormatProperties.html
func GetPhysicalDeviceSparseImageFormatProperties(physicalDevice PhysicalDevice, format Format, typ ImageType, samples SampleCountFlagBits, usage ImageUsageFlags, tiling ImageTiling) (properties []SparseImageFormatProperties) {
	// properties is a double-call array output
	var propertyCount uint32
	pPropertyCount := unsafe.Pointer(&propertyCount)
	var pProperties unsafe.Pointer
	// first trampoline happens here; also, check returned Result value

	execTrampoline(keyvkGetPhysicalDeviceSparseImageFormatProperties, uintptr(physicalDevice), uintptr(format), uintptr(typ), uintptr(samples), uintptr(usage), uintptr(tiling), uintptr(pPropertyCount), uintptr(pProperties))

	properties = make([]SparseImageFormatProperties, propertyCount)
	pProperties = unsafe.Pointer(&properties[0])

	execTrampoline(keyvkGetPhysicalDeviceSparseImageFormatProperties, uintptr(physicalDevice), uintptr(format), uintptr(typ), uintptr(samples), uintptr(usage), uintptr(tiling), uintptr(pPropertyCount), uintptr(pProperties))

	return
}

// GetPipelineCacheData: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetPipelineCacheData.html
func GetPipelineCacheData(device Device, pipelineCache PipelineCache) (r Result, data []byte) {
	// data is a double-call array output
	var dataSize uintptr
	pDataSize := unsafe.Pointer(&dataSize)
	var pData unsafe.Pointer
	// first trampoline happens here; also, check returned Result value

	r = Result(execTrampoline(keyvkGetPipelineCacheData, uintptr(device), uintptr(pipelineCache), uintptr(pDataSize), uintptr(pData)))

	data = make([]byte, dataSize)
	pData = unsafe.Pointer(&data[0])

	r = Result(execTrampoline(keyvkGetPipelineCacheData, uintptr(device), uintptr(pipelineCache), uintptr(pDataSize), uintptr(pData)))

	return
}

// GetQueryPoolResults: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetQueryPoolResults.html
func GetQueryPoolResults(device Device, queryPool QueryPool, firstQuery uint32, queryCount uint32, data []byte, stride DeviceSize, flags QueryResultFlags) (r Result) {
	dataSize := len(data)
	// Parameter is a user-allocated array input that will be written to (?) - data
	pData := unsafe.Pointer(&data[0])

	r = Result(execTrampoline(keyvkGetQueryPoolResults, uintptr(device), uintptr(queryPool), uintptr(firstQuery), uintptr(queryCount), uintptr(dataSize), uintptr(pData), uintptr(stride), uintptr(flags)))

	return
}

// GetRenderAreaGranularity: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkGetRenderAreaGranularity.html
func GetRenderAreaGranularity(device Device, renderPass RenderPass) (granularity Extent2D) {
	// granularity is a binding-allocated single return value and will be populated by Vulkan
	pGranularity := unsafe.Pointer(&granularity)

	execTrampoline(keyvkGetRenderAreaGranularity, uintptr(device), uintptr(renderPass), uintptr(pGranularity))

	return
}

// InvalidateMappedMemoryRanges: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkInvalidateMappedMemoryRanges.html
func InvalidateMappedMemoryRanges(device Device, memoryRanges []MappedMemoryRange) (r Result) {
	memoryRangeCount := len(memoryRanges)
	// memoryRanges is an input slice that requires translation to an internal type
	sl_memoryRanges := make([]_vkMappedMemoryRange, memoryRangeCount)
	for i, v := range memoryRanges {
		sl_memoryRanges[i] = *(v.Vulkanize())
	}
	pMemoryRanges := unsafe.Pointer(&sl_memoryRanges[0])

	r = Result(execTrampoline(keyvkInvalidateMappedMemoryRanges, uintptr(device), uintptr(memoryRangeCount), uintptr(pMemoryRanges)))

	return
}

// MapMemory: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkMapMemory.html
func MapMemory(device Device, memory DeviceMemory, offset DeviceSize, size DeviceSize, flags MemoryMapFlags) (r Result, pData *byte) {
	// pData is a binding-allocated single return value and will be populated by Vulkan
	ppData := unsafe.Pointer(&pData)

	r = Result(execTrampoline(keyvkMapMemory, uintptr(device), uintptr(memory), uintptr(offset), uintptr(size), uintptr(flags), uintptr(ppData)))

	return
}

// MergePipelineCaches: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkMergePipelineCaches.html
func MergePipelineCaches(device Device, dstCache PipelineCache, srcCaches []PipelineCache) (r Result) {
	srcCacheCount := len(srcCaches)
	// srcCaches is an input slice of values that do not need translation used
	pSrcCaches := unsafe.Pointer(&srcCaches[0])

	r = Result(execTrampoline(keyvkMergePipelineCaches, uintptr(device), uintptr(dstCache), uintptr(srcCacheCount), uintptr(pSrcCaches)))

	return
}

// QueueBindSparse: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkQueueBindSparse.html
func QueueBindSparse(queue Queue, bindInfo []BindSparseInfo, fence Fence) (r Result) {
	bindInfoCount := len(bindInfo)
	// bindInfo is an input slice that requires translation to an internal type
	sl_bindInfo := make([]_vkBindSparseInfo, bindInfoCount)
	for i, v := range bindInfo {
		sl_bindInfo[i] = *(v.Vulkanize())
	}
	pBindInfo := unsafe.Pointer(&sl_bindInfo[0])

	r = Result(execTrampoline(keyvkQueueBindSparse, uintptr(queue), uintptr(bindInfoCount), uintptr(pBindInfo), uintptr(fence)))

	return
}

// QueueSubmit: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkQueueSubmit.html
func QueueSubmit(queue Queue, submits []SubmitInfo, fence Fence) (r Result) {
	submitCount := len(submits)
	// submits is an input slice that requires translation to an internal type
	sl_submits := make([]_vkSubmitInfo, submitCount)
	for i, v := range submits {
		sl_submits[i] = *(v.Vulkanize())
	}
	pSubmits := unsafe.Pointer(&sl_submits[0])

	r = Result(execTrampoline(keyvkQueueSubmit, uintptr(queue), uintptr(submitCount), uintptr(pSubmits), uintptr(fence)))

	return
}

// QueueWaitIdle: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkQueueWaitIdle.html
func QueueWaitIdle(queue Queue) (r Result) {

	r = Result(execTrampoline(keyvkQueueWaitIdle, uintptr(queue)))

	return
}

// ResetCommandBuffer: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkResetCommandBuffer.html
func ResetCommandBuffer(commandBuffer CommandBuffer, flags CommandBufferResetFlags) (r Result) {

	r = Result(execTrampoline(keyvkResetCommandBuffer, uintptr(commandBuffer), uintptr(flags)))

	return
}

// ResetCommandPool: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkResetCommandPool.html
func ResetCommandPool(device Device, commandPool CommandPool, flags CommandPoolResetFlags) (r Result) {

	r = Result(execTrampoline(keyvkResetCommandPool, uintptr(device), uintptr(commandPool), uintptr(flags)))

	return
}

// ResetDescriptorPool: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkResetDescriptorPool.html
func ResetDescriptorPool(device Device, descriptorPool DescriptorPool, flags DescriptorPoolResetFlags) (r Result) {

	r = Result(execTrampoline(keyvkResetDescriptorPool, uintptr(device), uintptr(descriptorPool), uintptr(flags)))

	return
}

// ResetEvent: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkResetEvent.html
func ResetEvent(device Device, event Event) (r Result) {

	r = Result(execTrampoline(keyvkResetEvent, uintptr(device), uintptr(event)))

	return
}

// ResetFences: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkResetFences.html
func ResetFences(device Device, fences []Fence) (r Result) {
	fenceCount := len(fences)
	// fences is an input slice of values that do not need translation used
	pFences := unsafe.Pointer(&fences[0])

	r = Result(execTrampoline(keyvkResetFences, uintptr(device), uintptr(fenceCount), uintptr(pFences)))

	return
}

// SetEvent: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkSetEvent.html
func SetEvent(device Device, event Event) (r Result) {

	r = Result(execTrampoline(keyvkSetEvent, uintptr(device), uintptr(event)))

	return
}

// UnmapMemory: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkUnmapMemory.html
func UnmapMemory(device Device, memory DeviceMemory) {

	execTrampoline(keyvkUnmapMemory, uintptr(device), uintptr(memory))

}

// UpdateDescriptorSets: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkUpdateDescriptorSets.html
func UpdateDescriptorSets(device Device, descriptorWrites []WriteDescriptorSet, descriptorCopies []CopyDescriptorSet) {
	descriptorWriteCount := len(descriptorWrites)
	// descriptorWrites is an input slice that requires translation to an internal type
	sl_descriptorWrites := make([]_vkWriteDescriptorSet, descriptorWriteCount)
	for i, v := range descriptorWrites {
		sl_descriptorWrites[i] = *(v.Vulkanize())
	}
	pDescriptorWrites := unsafe.Pointer(&sl_descriptorWrites[0])

	descriptorCopyCount := len(descriptorCopies)
	// descriptorCopies is an input slice that requires translation to an internal type
	sl_descriptorCopies := make([]_vkCopyDescriptorSet, descriptorCopyCount)
	for i, v := range descriptorCopies {
		sl_descriptorCopies[i] = *(v.Vulkanize())
	}
	pDescriptorCopies := unsafe.Pointer(&sl_descriptorCopies[0])

	execTrampoline(keyvkUpdateDescriptorSets, uintptr(device), uintptr(descriptorWriteCount), uintptr(pDescriptorWrites), uintptr(descriptorCopyCount), uintptr(pDescriptorCopies))

}

// WaitForFences: See https://www.khronos.org/registry/vulkan/specs/1.3-extensions/man/html/vkWaitForFences.html
func WaitForFences(device Device, fences []Fence, waitAll bool, timeout uint64) (r Result) {
	fenceCount := len(fences)
	// fences is an input slice of values that do not need translation used
	pFences := unsafe.Pointer(&fences[0])

	waitAll_Bool32 := translateInternal_Bool32(waitAll)

	r = Result(execTrampoline(keyvkWaitForFences, uintptr(device), uintptr(fenceCount), uintptr(pFences), uintptr(waitAll_Bool32), uintptr(timeout)))

	return
}
